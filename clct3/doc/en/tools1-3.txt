/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      CA-Clipper Tools
   $ONELINER$
      Copyright
   $CATEGORY$
      Copyright
   $DESCRIPTION$
      Copyright (C) Computer Associates International, Inc. 1993
      Legend:  * denotes obsolete items or usage
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Introduction
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      CA-Clipper Tools contains over 800 functions which you can use to
      develop CA-Clipper applications and system-level routines.  These
      functions give CA-Clipper programmers capabilities previously reserved
      for C or Assembler programmers with detailed system knowledge.

      In order to use working memory as economically as possible, virtually
      all the functions are written in Assembler and are highly optimized.
      This guarantees high speed with a minimal use of memory.  This
      efficiency is further supported by the modularity of the software within
      the CA-Clipper Tools library.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Installing CA-Clipper Tools
   $ONELINER$
      Installing CA-Clipper Tools
   $CATEGORY$
      Intro
   $DESCRIPTION$
      *Requirements*

      CA-Clipper Tools was designed for use with the CA-Clipper compiler.
      Therefore it should only be used on IBM PC/XTs, PC/ATs, or completely
      compatible systems.  The screen functions may not work on a system where
      a modified CA-Clipper driver module has been used.  (The string
      functions, on the other hand, are generally hardware independent.)

      CA-Clipper Tools requires PC-DOS or MS-DOS, version 2.10 or higher, but
      some functions work with system calls which are not supported until
      PC/MS-DOS version 3.1 or higher.  This applies, for example, to network
      functions: if you work with network functions under a DOS version
      earlier than 3.1, the functions will not work properly.

      We cannot guarantee that CA-Clipper Tools will work under any operating
      system other than PC-DOS or MS-DOS.

      *Installation Program*

      CA-Clipper Tools is supplied with an installation program, located on
      Disk 1.  To install CA-Clipper Tools, perform the following steps:

      ■  Insert Disk 1 in drive A

      ■  Type A: and press Return to change the default drive to A

      ■  Type INSTALL and press Return to start the installation
         procedure

      The installation procedure is self-explanatory.  You will be prompted to
      insert other disks as the installation program needs them.  (Some of the
      files are compressed; therefore you cannot use the DOS COPY command to
      copy them to your hard disk.  You must use the installation program.)

      When the installation is complete, read the READ.ME file (located on
      disk 1) to learn about any last minute changes or enhancements.

      *Compatibility*

      CA-Clipper Tools is generally compatible with previous versions, but
      there are some deviations.  If you require full compatibility for
      existing applications developed under CA-Clipper S'87, you must link in
      the #include file CT.CH.  Notice, however, that we do not recommend this
      procedure for development of new applications.

      As CA-Clipper develops, some of the functions in previous versions of
      the CA-Clipper Tools program are no longer meaningful.  These functions
      remain unchanged in CA-Clipper Tools to avoid problems during the
      compilation of existing applications, but they have been flagged with
      asterisks (*) at the function name.  Again, we do not recommend that you
      use these functions to develop new applications.

      *Documentation*

      All of the CA-Clipper Tools functions are described in detail in this
      four-volume Reference Guide.  To allow you to find the function you need
      in a particular situation, the Reference Guide is divided into chapters.
      Each chapter presents a group of functions that serve a particular
      purpose, such as date functions, database functions, or system
      functions.  Each function is then described in detail on a separate
      page.  Appendixes provide keyboard tables, DOS error codes, and Novell
      network error codes.

      A Quick Reference Guide gives the complete syntax and a short
      description of every function.  In this booklet, the functions are
      organized in alphabetical order for quick reference.  A chapter and page
      number tells you where to look in this four-volume Reference Guide for a
      complete description of the function.

      The CA-Clipper Tools software contains a text retrieval system that lets
      you search online for the expression you need.  This text retrieval
      system finds the appropriate function for your purpose in seconds --
      even if you don't know what that function is -- and provides complete
      documentation on that function online.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Using CA-Clipper Tools
   $ONELINER$
      Using CA-Clipper Tools
   $CATEGORY$
      Intro
   $DESCRIPTION$
      *Programming*

      To use the CA-Clipper Tools functions in your programs, specify the
      CT.LIB library during the LINK procedure.  If required, also specify the
      CTUS.OBJ Extended Driver file.  (See the section called "Extended
      Driver" below.)

      All CA-Clipper rules apply when calling functions.  For example, a
      function's return must not be assigned to a variable.

      Both types of calls are possible:

      FUNCTION(par1, par2)
      Var=FUNCTION(par1, par2)

      *Linking*

      CA-Clipper Tools functions can be linked with MS-LINK (often referred to
      as the DOS linker) as well as with RTLink.

      Here is an example using MS-LINK:

      LINK <Prog1>+<Prog2>+CTUS,,,CT/SE:<nnn> /NOE

      With the exception of small test programs, MS-LINK requires that a value
      be assigned to the /SE: switch.  We cannot recommend an adequate value
      for <nnn>.

      Here is an example using RTLink in FreeFormat mode:

      RTLINK FI<Prog1>,<Prog2>,CTUS LIB CT

      RTLink also contains a positional mode. When using this mode, the link
      command has to be identical to that in MS-LINK. Further information
      regarding RTLink can be found in the CA-Clipper Programming and
      Utilities Guide.

      PLL Files

      CA-Clipper Tools cannot be implemented in conjunction with the
      BASE50.PLL file created at CA-Clipper installation. You can, however,
      create a new corresponding .PLL file with the linker script file CT.LNK
      included in CA-Clipper Tools.  Use the following command:

      RTLINK @CT

      This will exchange a particular module from the CA-Clipper library as
      well as several I/O routines out of TERMINAL.LIB for others in CTUS.OBJ
      or CT.LIB. The new .PLL file is called CT.PLL. If a new .PLL file is not
      created, then the alternative I/O routines and therefore many of the
      CA-Clipper Tools functions will not work for all the programs generated
      via prelinking.

      If the CT.PLL file has been created once, the link procedure can be
      called as follows:

      RTLINK FI <prog> LIB CT PLL CT

      The CTUS.OBJ Extended Driver must not be specified, since it is already
      in the .PLL file.

      Further CA-Clipper Tools modules have not been included in this or other
      .LNK files, since prelinked modules are always loaded at program start
      and increase memory usage accordingly.  Creation of a .PLL file in
      conjunction with other external libraries becomes an individual
      procedure.  However, all CT.LIB modules can be prelinked.  You simply
      need to include a public for the desired module by inserting the REFER
      command.

      Here is an example.  By inserting:

      REFER COM_BREAK, ACOS

      the _COM and _TRI3 modules (serial interfaces and trigonometric
      functions) will be prelinked. The names of the module and the publics
      can be determined with a library manager like MS-LIB.

      CA-Clipper Libraries

      None of the preceding examples mentions any of the files belonging to
      CA-Clipper itself.  This is because, during compiling, CA-Clipper's
      default setting enters the names of its four libraries in the resulting
      .OBJ file.  When you influence this procedure, for example by using the
      /r compiler switch, all the required libraries must be called explicitly
      at linking.

      Static Overlays

      Most functions or CA-Clipper Tools modules cannot be stored to a static
      overlay, as they contain interrupt service routines. They may not reside
      in an overlay. The functions affected are KeySec(), KeyTime(),
      ShowTime(), SHOWKEY(), PRINTSCR(), PRINTSCRX(), and SETTIC(), as well as
      serial interface functions that also work interrupt controlled.

      The Extended Driver CTUS.OBJ may never be placed in an overlay, since it
      is needed by CA-Clipper for every input and output. Linking CTUS.OBJ in
      an overlay will result in a system crash immediately after the start of
      your application.  Therefore, be aware that the overlay will always have
      to be loaded in order for the function to be available.

      All CA-Clipper Tools functions can be called from an overlay.  The
      program code for some functions, however, cannot be placed within an
      overlay.

      Possible Linking Problems

      When implementing CA-Clipper Tools in an existing application for the
      first time, the linker warning message "Duplicate Definitions" may
      occur. In this case, probably one of your own procedures or functions or
      a function from another library has a name that was also used by one of
      the CA-Clipper Tools functions. If the name of this other function or
      procedure cannot be changed, it must be specified as a separate .OBJ
      file.  Otherwise CT.LIB must be designated as the last library.

      Note, also, that an .OBJ file will always overwrite a library module
      with the same name, independent of its position in the LINK command
      line. Therefore, the CA-Clipper Tools Extended Driver is delivered as an
      .OBJ file.

      *Extended Driver*

      In addition to the CT.LIB library, you will find a separate .OBJ module
      on your disk called CTUS.OBJ. This is the CA-Clipper Tools Extended
      Driver.  If this is linked in, it replaces the CA-Clipper library
      driver. Above all, the Extended Driver is important for the
      implementation of window functions, but it also offers other interesting
      possibilities.  For this reason all the functions in the chapter on the
      Extended Driver in this Reference Guide form a part of this module.

      The CTUS.OBJ must only be added to the .OBJ file list to be linked.  The
      sequence is not important.  The Extended Driver replaces the CA-Clipper
      library driver module, so storing out to an overlay is not possible. You
      will find further information in the Extended Driver chapter.

      *Debugging*

      Working with CA-Clipper Tools makes additional debugger features
      available.  These features are also controlled via the CLIPPER
      environmental variable, by setting a switch DEBUG:<n>.

      How Problems Arise

      There are many possible screen modes, fonts, windows, and virtual
      screens, so various problems can arise.  The debugger also uses windows,
      as you can see on the debugger Windows menu.  To avoid a collision with
      the windows of your application, the debugger has an additional
      windowing system.

      Working with One Screen

      When working with one screen, the debugger must be able to switch
      between the application screen and its own screen.  The contents of the
      application screen must be saved.  This can happen in an area of the
      available memory or in a free screen page.

      Using a screen page saves memory and offers better performance, but it
      takes a screen page of the application.  This is, however, taken into
      account by CA-Clipper Tools.  The MAXPAGE() function, for example,
      returns a reduced value.  The default value for the application is
      screen page, which can be changed with the environmental variable.

      Working with Two Screens

      Working intensively with CA-Clipper Tools video functions and the
      debugger on one screen is difficult.  For this situation, the debugger
      supports two screens.  This is possible because the PC can operate two
      cards simultaneously, for example, a Hercules card and a VGA card.  The
      application output always occurs on the screen from which it was
      started, while the debugger output is displayed on the other screen.
      This capability is set via the CLIPPER environmental variable, by
      specifying DEBUG:2.

      DEBUG Values

      The DEBUG: <n> switch can be set with a numeric value.  Each individual
      bit has a certain meaning.  At this time, only two bits are used:

      <table>
          Bit:      When set:      Default

          1         use PAGE       1
          2         two screens    0
         </table>

      Note:  Particular switch combinations in the CLIPPER environmental
      variable can lead to problems. Please construct your environmental
      variable as follows:

      SET CLIPPER=/Fnnn /Ennnn /DEBUG:2 /SWAPPATH:"path"

      *Reference Sensitive[@]*

      CA-Clipper can pass parameters of the character string type to a UDF by
      reference.  This means that what is actually passed is a pointer to the
      original, thus avoiding the creation of an internal copy.  When a
      function takes on this type of parameter and changes it, it is the
      original that is actually changed.  Here is an example:

      VAR := "Hello"
      MYFUNC(@VAR)

      Passing of parameters by reference has advantages and disadvantages.  An
      important advantage is that memory usage is reduced.  This avoids
      runtime errors that result from not having enough memory for string
      manipulation.  If, on the other hand, you do not want the original
      string to be changed, passing of parameters by reference is a
      disadvantage.

      With a normal call (that is, not by reference), it is the copy that is
      changed by the function.  The change must then be passed back to the
      original:

      VAR := "Hello"
      VAR :+ MYFUNC(VAR)

      Particularly in the case of long strings, this method takes up memory
      and time.

      It is not a good idea to pass parameters by reference for most of the
      CA-Clipper Tools functions.  (In some cases there will even be a
      difference in the result when a parameter is passed this way.)  The
      functions then change the string passed as a parameter directly.  This
      saves memory space and the functions work more quickly, since there are
      no internal copy procedures taking place.  Watch for the [@] identifier
      meaning reference sensitive.

      *CSetRef()*

      This function allows you to further optimize memory requirements and
      speed for different string functions. This assumes that a function is
      only working with data passed as a parameter and avoids internal copies
      of returned values as well. When CSetRef() is set, the affected function
      no longer returns a value.

      You will find more information on this function in the chapter on string
      functions.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Additional Programs
   $ONELINER$
      Additional Programs
   $DESCRIPTION$
      *Security*

      If CA-Clipper Tools functions that change interrupts are not properly
      uninstalled or if the Extended Driver is not implemented, you could use
      the INTSAVE.EXE and INTOFF.EXE programs as additional security.

      INTSAVE

      <Drive>:INTSAVE[/S|/R[<FileName>]]<RETURN>

      INTSAVE saves all 256 interrupt vectors to a file called INSAVE.TAB.
      Alternatively, a different filename can be selected, if multiple
      applications need to access the same path in a network.  A call with the
      /S switch saves the interrupt vectors,while a call with /R restores
      them.

      If the program is called without parameters, it explains its operation
      on the screen and, if required, displays a list of interrupt vectors
      that have been changed.

      INTOFF

      <Drive>:INTOFF <RETURN>

      This program represents an "emergency brake".  It sets the vectors
      described below to an IRET in the system ROM, so that there is no danger
      of a system crash as a result of erroneous interrupt vectors.  The mouse
      interrupt (033h) is also newly initialized and the timer tic rate is
      reset.  Memory resident programs are uncoupled from their interrupt
      vectors as well and are thereby rendered unusable. The program sets the
      following interrupt vectors to harmless IRETs:

      <table>
          Operation    Vector         Use in CA-Clipper Tools

          IRET         Timer 1C       KeySec(), SHOWIME()
                       Alarm 4A       KeyTime()
                       COM1 0C        V24 Functions
                       COM2 0B        V24 Functions
          INIT         Mouse 33       If foreign routines linked in
                       Timerspeed     SETTIC()
         </table>

      Both programs could be linked into a batch job which starts your
      CA-Clipper application. This would look as follows:

      ECHO OFF
      INTSAVE /S INTSAVE1.TAB

         CLIPPROG
      INTSAVE /R INTSAVE1.TAB
      ECHO ON

      With INTOFF, it would look like this:

      ECHO OFF
         CLIPPROG
         INTOFF
      ECHO ON

      This will avoid later system crashes.

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Window Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      It is hard to imagine using CA-Clipper without using windows.  Windows
      are the best way to show multiple tasks so you can get a genuine
      overview of the system operation.  The functions in this chapter offer a
      particularly valuable extension to CA-Clipper in this area.

      b>The Window System</b>

      If you are only working with one screen, the CA-Clipper Tools functions
      permit up to 255 windows, depending on available memory.  In conjunction
      with the MONISWITCH() function from the Video Function chapter,
      CA-Clipper Tools can even support two screens linked to a single CPU,
      with one monochrome screen and one color screen.  In this way two
      entirely independent window systems, each with 255 windows, are
      available.

      The window functions take into account the fact that CA-Clipper Tools
      supports larger screens than the common 25 rows x 80 columns.  A screen,
      and therefore also a window, can be up to 255 rows or 255 columns in
      size.  However, the complete contents of a screen can never require more
      than 32 KB of memory.  So with 255 rows, no more than 128 columns are
      possible.

      b>Moving Interactively</b>

      As soon as SCROLL LOCK is activated, the active window can be moved with
      different cursor keys.  Depending on how you open them, windows can even
      overlap.  The gray Plus key in the numeric key pad works like the
      function WCenter().  You use the Plus key to move a partially visible
      window  back into a completely visible area.  All window movements done
      after you activate SCROLL LOCK can be undone using the ESC key.

      b>Programming with Window Functions</b>

      ■  Each window is assigned a number between 1 and 255 when it is
         opened.  This number is known as the window handle.  Handle 0 is the
         original screen, with no open windows.  The window handle returned
         will be used to refer to that window during programming.  (For
         example, you need the window handle when you select a background
         window.)

         WMode(.T., .T., .T., .T.)         // Overlap permitted

         nWindow1 := WOpen(....)
         nWindow2 := WOpen(....)           // This is the active window

         WSelect(nWindow1)                 // Activate first window

      ■  The coordinates used for screen output are relative only to
         the selected window, and not the entire screen.

         nWindow1 := WOpen(....)           // Selected window

         @ 02, 02 SAY  "CA-Clipper Tools"

      ■  Since a window behaves exactly as the normal screen would,
         QOut() style output (?, ??, etc.) will be scrolled up as soon as it
         reaches the bottom row.

      ■  The window in the following example, which extends to row 24,
         will not overwrite the help message on row 25:

         @ 24, 00 SAY "........ HELP-ROW........"
         nWindow1 := WOpen(0, 0, 23, 79)   // Protects the last row
         FOR nI = 1 TO 100
            ? "CA-Clipper Tools ...."
         NEXT nI

      ■  A window displays as a full value, but is a virtual screen,
         which differs from the original physical screen only in size.
         Extended drivers make the MaxRow() and MaxCol() functions available
         in a version enhanced over and above CA-Clipper  to accommodate the
         changed size.  Now the coordinates of virtual screens can also be
         determined; these functions return the last row or column concerned
         with the currently selected window:

         nWindow1 := WOpen(10, 10, 20, 60)

         ? MaxRow()                        // Row:     10
         ? MaxCol()                        // Column: 50

      ■  The underlying screen area is saved automatically when a new
         window is opened.  This applies equally to any area of the screen
         that becomes overlapped by the movement of a window.  At the same
         time, all settings in the areas that have been overwritten are saved.
         These settings include cursor shape and position, as well as color
         attributes.  So you do not have to save anything out of the affected
         screen area; CA-Clipper Tools takes over this task automatically.

      ■  The following example shows you how the window functions save
         both the color and cursor setting:

         SET COLOR TO R                      // Set color RED
         ? "Test-Text 1 ..."                 // Output in RED
         nWindow1 := WOpen(10, 10, 20, 55)
         WBox()                              // RED window border
            SET COLOR TO BG                  // Set color CYAN
            ? "Test-Text 2 ..."              // Output in CYAN
            Inkey(0)                         // Wait for keystroke
         WFCLOSE()                           // Close window again

         ? "Test-Text 3 ..."                 // Output again in RED
                                             // and directly below "Text 1"

      b>Active Windows</b>

      After you close a window, the active window with the highest handle is
      the one selected, not the window that was previously active.  If, for
      example, the highest window handle is 9 and window 5 was just selected,
      a newly opened window is assigned handle 10.  However, after you close
      this window number 10, window 9 is selected.  It is therefore important
      to save the window's handle to a variable when you open it, so that you
      can select the required window later.

      You can save the active window handle by calling WSelect() with no
      parameters.

      ■  The external output of programs called with RUN within a
         CA-Clipper program can be tied to windows:

         DSETWINDOW(.T.)
         nWindow1 := WOpen(10, 10, 22, 70)
         RUN DIR                     // Display results in window

      The only prerequisite is that such output is through DOS or BIOS.  The
      DSETWINDOW() function controls whether or not this output is
      subsequently redirected.  The Extended Driver chapter has more details.

      In addition to the examples shown here there are many more window
      functions available for use that contribute to a comprehensive windows
      system.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WAClose()
   $ONELINER$
      Closes all windows
   $SYNTAX$
      WAClose() --> nError

   $RETURNS$
      WAClose() returns 0 when successful or -1 if an error occurs.

   $DESCRIPTION$
      This function closes all windows in a work session.  If no windows were
      opened with WOpen(), then WAClose() returns a value of -1.  If windows
      were opened with WOpen(), then WAClose() returns a value of 0.

   $EXAMPLES$
      WOpen( ... )            // Many windows will be opened
      WOpen( ... )
      WOpen( ... )

      WAClose()               // Close all windows!

   $PLATFORMS$
      DOS
   $SEEALSO$
      WClose()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WBoard()
   $ONELINER$
      Allocates allowable screen area for windows
   $SYNTAX$
      WBoard([<nTopRow>, <nLeftColumn>, <nBottomRow>,
         <nRight Column>]) --> nError

   $ARGUMENTS$
      <nToprow>, <nLeftcolumn>, <nBottomrow>, <nRightcolumn>  Designate
      the screen coordinates (upper left and lower right) within which windows
      can be opened.

      ()  If WBoard() is called without parameters, then the window border is
      reset to the boundaries of the physical screen, which as a rule
      corresponds to a call of WBoard(0, 0, 24, 79).

   $RETURNS$
      WBoard() returns a -1 if an error occurs.   If no errors occur, WBoard()
      returns a 0.

   $DESCRIPTION$
      This function defines the screen area where windows are permitted.
      Windows are subsequently only visible in this defined area.  You can use
      this function to protect an area of the screen from being overwritten
      with windows, even when you allow the user to move the window
      interactively.  The boundaries designated by WBoard() become the screen
      boundaries for window functions.

   $NOTES$
      ■  WBoard() is only effective when there are no open windows.

      ■  Always consider that closing individual windows or all the
         windows never influences the setting of the window border.  So if you
         neglect to specifically eliminate the window border, you can have
         unanticipated problems later when you open windows.

   $EXAMPLES$
      Leave only the upper half of the screen free for window functions:

      WBoard(0, 0, 12, 79)

   $PLATFORMS$
      DOS
   $SEEALSO$
      WAClose(), WClose(), WSetMove(), WMode()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WBox()
   $ONELINER$
      Places a frame around the active window
   $SYNTAX$
      WBox([<cFramecharacter|nFrametype>]) --> nCurrentWindow

   $ARGUMENTS$
      <cFramecharacter>  Designates a string of up to nine characters.

      <nFrametype>  Designates one of eight different border types.

      ()  If the function is called without parameters, a double line border
      is created automatically and the window is filled with the CLEARB
      character (see SetClearB()).

   $RETURNS$
      WBox() returns the number of the current window.

   $DESCRIPTION$
      This function works like the CA-Clipper @...BOX command, except that
      WBox() always encloses the currently selected window.  You can specify
      an individual character with which to frame the entire window.  You can
      specify up to nine different characters for the corners, and the
      horizontal and vertical lines.  You can also specify a character with
      which to fill the window.  The frame characters start to fill the frame
      in the upper left corner and continue clockwise around the frame.  When
      specified, the ninth character is used to fill the window.

      There is a simplified way to specify eight basic border types.  If you
      choose to pass a numeric entry, instead of the string of characters,
      WBox() interprets the numeric entry as shorthand for defining a box
      type.  The following sample shows the border types assigned to each of
      the 16 values.  Notice that numbers between 0 and 3, and 8 and 11,
      delete the area in the window while the other numbers do not.

      *Frame types:*

      Delete:                     0          1            2      3

      Do Not Delete:              4          5            6      7



      Delete:                      8         9              10   11

      Do Not Delete:              12         13             14   15

   $NOTES$
      ■  The available work area for the window is reduced by two rows
         and two columns (corresponds to a WFormat(1, 1, 1, 1)).  This
         prevents the border from being unintentionally overwritten.  When
         WBox() is called a second time, the window is reduced again.  If a
         window is too small to frame, WBox() returns a value of -1 and
         changes nothing.

      ■  If you want to put a title in a frame, you can place the title
         in the top row of the window border by specifying @ .. SAY for the
         row.

   $EXAMPLES$
      ■  This function frames a window with a double row and then fills
         it.  The window output area is automatically reduced by 1 for each
         page:

         WSelect(nWindow)
         WBox("  ")

      ■  This code shows a frame with simple lines, filled with
         Chr(177):

         SetClearB(177)        // The delete character
         WBox(1)               // Box type 1, delete interior

   $PLATFORMS$
      DOS
   $SEEALSO$
      WOpen(), WSelect(), WFormat(), SETBOXGROW(), SetClearB()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WCenter()
   $ONELINER$
      Returns a window to the visible screen area, or centers it
   $SYNTAX$
      WCenter([<lCenter>]) --> nCurrentWindow

   $ARGUMENTS$
      <lCenter>  Designates the center of the display.  If the parameter
      is .T., the function computes the center of the display and moves the
      window to that position.  If the parameter is .F. or if no parameter is
      passed, the function returns a window to the visible screen area.  The
      default value is .F..

   $RETURNS$
      WCenter() returns the number of the currently selected window.

   $DESCRIPTION$
      WCenter() can take a window that has been moved out of visible range and
      make it fully visible.  The window can also be centered by passing .T.
      for <lCenter>.

   $NOTES$
      ■  WCenter() always relates to the currently selected window.

   $EXAMPLES$
      Make nWindow fully visible:

      WSelect(nWindow)

      WCenter()

   $PLATFORMS$
      DOS
   $SEEALSO$
      WBoard(), WOpen(), WSelect()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WClose()
   $ONELINER$
      Closes the active window
   $SYNTAX$
      WClose() --> nWindow

   $RETURNS$
      WClose() returns the window handle that will subsequently become active.

   $DESCRIPTION$
      This function closes the currently selected window.  Control is returned
      automatically to the window with the highest handle or number.

   $NOTES$
      ■  The window handle closed with WClose() is subsequently
         available again and can be reused with the next WOpen()

      ■  If the physical screen (Window 0) was active prior to the
         window closure with WClose(), then Window 0 is skipped over and the
         window that was active before the WClose() is selected.

   $EXAMPLES$
      After this command sequence you are in window 3, not window 2:

      WSelect(3)
      WSelect(2)
      WSelect(5)
      WClose()

   $PLATFORMS$
      DOS
   $SEEALSO$
      WOpen(), WSelect()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WCol()
   $ONELINER$
      Returns the position of the leftmost column of the active window
   $SYNTAX$
      WCol([<lAfterWCENTER>]) --> nCol

   $ARGUMENTS$
      <lAfterWCENTER>  Designates an optional parameter.  If this
      parameter is .T., the function returns what the position of the leftmost
      column of a window would be after a call of WCenter().  (The function
      does not call WCenter())  The default value (.F.) returns the current
      position.

   $RETURNS$
      WCol() returns the coordinate relative to the leftmost column of the
      selected window.

   $DESCRIPTION$
      This function allows you to determine the current position of the
      leftmost column of the selected window.  This allows you to save a
      window's position if the window was moved previously with the cursor
      keys.  This way the window can later be reopened at exactly the same
      position.

      Additionally, by passing the optional parameter with a .T., you can
      determine what the window position would be after a WCenter() without
      actually calling WCenter().

   $NOTES$
      ■  Values can be negative.  Negative values place the first
         column outside of the visible range.

   $EXAMPLES$
      This program saves the position of a window, then reopens it in that
      position:

      nTop  :=  10
      nLeft :=  15
      WOpen(nTop, nLeft, nTop + 10, nLeft + 40)

      * Someone moves the window!

      nTop := WRow()                     // Save the current
      nBottom := WCol()                  // position of upper left
      WClose()                           // corner and close the window

      * Other program sections

      WOpen(nTop, nLeft, nTop + 10, nLeft + 40)   // Open w/old values

   $PLATFORMS$
      DOS
   $SEEALSO$
      WOpen(), WSelect(), WRow(), WMode()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WFCol()
   $ONELINER$
      Returns the position of the leftmost column of the formatted area of a window
   $SYNTAX$
      WFCol([<lRelative>]) --> nValue

   $ARGUMENTS$
      <lRelative>  Designates an optional parameter.  If this parameter is
      .T., then the function returns the absolute value of the difference
      between WCol() and WFCol().

   $RETURNS$
      WFCol() returns the position of the leftmost column of the formatted
      area within a window, or the difference between the outer border and the
      formatted area of a window.

   $DESCRIPTION$
      This function is particularly useful if information in a window must be
      saved to a file.  There are four functions (WFCol(), WFLastCol(),
      WFRow(), WFLastRow()) which allow you to establish the coordinates of
      the formatted area of a window.  This information can then be saved for
      later use.

      In order to avoid complex calculations, you can determine the difference
      between the outer border and the formatted area when you use the
      optional logical parameter.  You can then pass this value when you call
      WFormat() to restore the old value.

   $NOTES$
      ■  When used in Window 0, the function returns the value for
         WBoard().

   $EXAMPLES$
      Every WFXXX() output corresponds to the currently selected window.
      Please notice that WBox() corresponds to WFormat(1, 1, 1, 1):

      CLEAR
      WOpen(10, 10, 20, 70)
      WBox()

      ? WFRow(), WFRow(.T.)              // 11, 1
      ? WFCol(), WFCol(.T.)              // 11, 1
      ? WFLastRow(), WFLastRow(.T.)      // 19, 1
      ? WFLastCol(), WFLastCol(.T.)      // 69, 1

      Inkey(0)
      WClose()
      RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      WCol(), WFRow(), WFLastCol(), WFLastRow(), WFormat(), WBox()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WFLastCol()
   $ONELINER$
      Returns the position of the rightmost column of the formatted area of a window
   $SYNTAX$
      WFLastCol([<lRelative>]) --> nValue

   $ARGUMENTS$
      <lRelative>  Designates an optional parameter.  If this parameter is
      .T., then the function returns the absolute value of the difference
      between WLastCol() and WFLastCol().

   $RETURNS$
      The function either returns the position of the rightmost column of the
      formatted area within a window, or the difference between the outer
      border and the formatted area of a window.

   $DESCRIPTION$
      This function is particularly useful if information in a window must be
      saved to a file.  There are four functions (WFCol(), WFLastCol(),
      WFRow(), WFLastRow()) which allow you to establish the coordinates of
      the formatted area of a window.  This information can then be saved for
      later use.

      When you use <lRelative>, you can determine the difference between the
      outer border and formatted area of a window.  You can pass this value
      later when you call WFormat() to restore the old value.

   $NOTES$
      ■  When used in Window 0, the function returns the value for
         WBoard().

   $EXAMPLES$
      Notice that WBox() corresponds to a WFormat(1, 1, 1, 1):

      CLEAR
      WOpen(10, 10, 20, 70)
      WBox()

      ? WFRow(), WFRow(.T.)              // 11, 1
      ? WFCol(), WFCol(.T.)              // 11, 1
      ? WFLastRow(), WFLastRow(.T.)      // 19, 1
      ? WFLastCol(), WFLastCol(.T.)      // 69, 1

      Inkey(0)
      WClose()
      RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      WLastCol(), WFCol(), WFRow(), WFLastRow(), WFormat(), WBox()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WFLastRow()
   $ONELINER$
      Returns the position of the bottom row of the formatted area of a window
   $SYNTAX$
      WFLastRow([<lRelative>]) --> nValue

   $ARGUMENTS$
      <lRelative>  Designates an optional parameter.  If this optional
      parameter is .T., then the function returns the absolute value of the
      difference between WLastRow() and WFLastRow().

   $RETURNS$
      The function either returns the position of the bottom row of the
      formatted area within a window, or the difference between the outer
      border and the formatted area of a window.

   $DESCRIPTION$
      This function is particularly useful if information in a window must be
      saved to a file.  There are four functions (WFCol(), WFLastCol(),
      WFRow(), WFLastRow()) which allow you to establish the coordinates of
      the formatted area of a window.  This information can then be saved for
      later use.

      In order to avoid complex calculations, you can determine the difference
      between the outer border and the formatted area of a window when you use
      the optional logical parameter.  You can pass this value later when you
      call WFormat() to restore the old value.

   $NOTES$
      ■  When used in Window 0, the function returns the value for
         WBoard().

   $EXAMPLES$
      Notice that WBox() corresponds to a WFormat(1, 1, 1, 1):

      CLEAR
      WOpen(10, 10, 20, 70)
      WBox()

      ? WFRow(), WFRow(.T.)              // 11, 1
      ? WFCol(), WFCol(.T.)              // 11, 1
      ? WFLastRow(), WFLastRow(.T.)      // 19, 1
      ? WFLastCol(), WFLastCol(.T.)      // 69, 1

      Inkey(0)
      WClose()
      RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      WLastRow(), WFCol(), WFRow(), WFLastCol(), WFormat(), WBox()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WFormat()
   $ONELINER$
      Determines the usable area within a window
   $SYNTAX$
      WFormat([<nTopRow>, <nLeftColumn>, <nBottomRow>,
         <nRightColumn>]) --> nWindow

   $ARGUMENTS$
      <nTopRow>,<nLeftColumn>,<nBottomRow>,<nRightColumn>  Designate the
      coordinate values for the text output area of a selected window.

   $RETURNS$
      WFormat() returns the currently selected window's handle.

   $DESCRIPTION$
      The WFormat() function can be used to reduce the area in which text
      output occurs compared to the actual area of the window.  This allows
      you to define a margin between the text and the borders of a window
      where you cannot write.  The four parameters define the margin between
      the old border and the output area.

   $NOTES$
      ■  The sum of the <nTopRow> and <nBottomRow> values must not
         exceed the internal height of the window and that the sum of the
         <nLeftColumn> and <nRightColumn> values must not exceed the internal
         width of the window.  In any size window, the output area can be
         reduced down to one character.

      ■  Negative values increase the text output area while positive
         values reduce it.  A WFormat() with very large negative values
         removes all borders.

      ■  This function cannot be used with the physical screen (Window
         0).

      ■  To write in the border area, you can also use a negative row
         value in @ .. SAY: (@ -1, 5 SAY "Help with input").

   $EXAMPLES$
      ■  The function reduces the output area of the selected window at
         the top and bottom by one row each, and by two columns each on the
         right and left.  The area becomes two rows and four columns smaller:

         WSelect(nWindow)
         WFormat(1, 2, 1, 2)

      ■  Here, all borders previously set with WFormat() are canceled,
         making it possible to write within the entire window again:

         WFormat()

   $PLATFORMS$
      DOS
   $SEEALSO$
      WSelect(), WBox()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WFRow()
   $ONELINER$
      Returns the position of the top row of the formatted area of a window
   $SYNTAX$
      WFRow([<lRelative>]) --> nValue

   $ARGUMENTS$
      <lRelative>  Designates an optional parameter.  If this parameter is
      .T., then the function returns the absolute value of the difference
      between WRow() and WFRow().

   $RETURNS$
      The function either returns the position of the top row of the formatted
      area within a window, or the difference between the outer border and the
      formatted area of a window.

   $DESCRIPTION$
      This function is particularly useful if information in a window must be
      saved to a file.  Four functions (WFCol(), WFLastCol(), WFRow(),
      WFLastRow()) allow you to establish the coordinates of the formatted
      area of a window.  This information can be saved for later use.

      In order to avoid complex calculations, you can determine the difference
      between the outer border and the formatted area of a window when you use
      the optional logical parameter.  You can transmit this value later when
      you use the WFormat() to restore the old value.

   $NOTES$
      ■  When used in Window 0, the function returns the value for
         WBoard().

   $EXAMPLES$
      Every WFXXX() output corresponds to the currently selected window.
      Please notice that WBox() corresponds to WFormat(1, 1, 1, 1):

      CLEAR
      WOpen(10, 10, 20, 70)
      WBox()

      ? WFRow(), WFRow(.T.)              // 11, 1
      ? WFCol(), WFCol(.T.)              // 11, 1
      ? WFLastRow(), WFLastRow(.T.)      // 19, 1
      ? WFLastCol(), WFLastCol(.T.)      // 69, 1

      Inkey(0)
      WClose()
      RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      WRow(), WFCol(), WFLastCol(), WFLastRow(), WFormat(), WBox()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WLastCol()
   $ONELINER$
      Returns the position of the rightmost column of the active window
   $SYNTAX$
      WLastCol([<lAfterWCENTER>]) --> nColumn

   $ARGUMENTS$
      <lAfterWCENTER>  Designates an optional parameter.  If this
      parameter is .T., the function returns what the position of the
      rightmost column would be after a call of WCenter().  (This function
      does not call WCenter().)  The default value (.F.) returns the current
      position.

   $RETURNS$
      WLastCol() returns the position of the rightmost window column, relative
      to the physical screen.

   $DESCRIPTION$
      The WCol() function allows you to determine the leftmost column (left
      border) of a window.  To avoid complex calculations, you can use the
      WLastCol() function to determine the rightmost column (right border) of
      a window.

      The returned value can be greater than that of the rightmost column of
      the screen.  In such an instance, the window overlaps the right border.

      Additionally, by setting the logical parameter to .T., the position a
      window occupies after a call of WCenter() is returned without actually
      calling WCenter().

   $EXAMPLES$
      A window is moved:

      ? WLastCol() > MaxCol()     // .T.  Window overlaps border

   $PLATFORMS$
      DOS
   $SEEALSO$
      WCol()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WLastRow()
   $ONELINER$
      Returns the position of the bottom row of the active window
   $SYNTAX$
      WLastRow([<lAfterWCENTER>]) --> nRow

   $ARGUMENTS$
      <lAfterWCENTER>  Designates an optional parameter.  If this
      parameter is .T., the function returns what the position of the bottom
      row would be after a call of WCenter().  (This function does not call
      WCenter().)  The default value (.F.) returns the current position.

   $RETURNS$
      WLastRow() returns the position of the bottom row, relative to the
      physical screen.

   $DESCRIPTION$
      The WRow() function allows you to determine the top row (top border) of
      a window.  To avoid complex calculations, you can use the WLastRow()
      function to determine the bottom row (bottom border) of a window.

      The returned value can be greater than that of the bottom row of the
      screen.  In such an instance, the window overlaps the bottom border.

      By passing the logical parameter as .T., the position of a window after
      a call of WCenter() can be determined without actually calling
      WCenter().

   $EXAMPLES$
      A window is moved:

      ? WLastRow() > MaxRow()      // .T.  Window overlaps border

   $PLATFORMS$
      DOS
   $SEEALSO$
      WRow()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WMode()
   $ONELINER$
      Turns the screen border overstep mode on or off
   $SYNTAX$
      WMode(<lTop>,<lLeft>,<lBottom>,<lRight>) --> nError

   $ARGUMENTS$
      <lTop>  Designates the top border.

      <lLeft>  Designates the left border.

      <lBottom>  Designates the bottom border.

      <lRight>  Designates the right border.

      ()  If you designate a parameter as .T., you can move the window over
      that border.  If you designate a parameter as .F., you cannot move the
      window over that border.

   $RETURNS$
      If there is an error the function returns -1.  If no errors occur,
      WMode() returns 0.

   $DESCRIPTION$
      WMode() can be used to define whether each screen page can be moved,
      interactively or with WMove(), beyond the edge of each side of the
      screen or beyond the area defined by WBoard().  The WMode() setting is
      valid for all open windows.

   $NOTES$
      ■  This function can be implemented when windows are already
         open.

   $EXAMPLES$
      Here we specify that the window can only be moved over the top or bottom
      of the screen:

      WMode(.T., .F., .T., .F.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      WBoard(), WMove(), WSetMove(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WMove()
   $ONELINER$
      Moves a window
   $SYNTAX$
      WMove(<nRow>,<nColumn>) --> nWindow

   $ARGUMENTS$
      <nRow>  Designates the row of the new top left corner of the
      currently selected window.

      <nColumn>  Designates the column of the new top left corner of the
      currently selected window.

   $RETURNS$
      WMove() returns the handle of the window that is moved.

   $DESCRIPTION$
      WMove() allows you to move the currently selected window to a particular
      position within the area defined by WBoard().

   $NOTES$
      ■  WSetMove() does not affect the operation of WMove().  By
         comparison, WMode() does have an effect on WMove().

      ■  <nRow> <nColumn> can have negative values.  In contrast to the
         interactive mode, a window can be moved completely under a border
         using WMove().

   $EXAMPLES$
      This function call moves the selected window up one row and over one
      column to the left, if the related border has not already been reached:

      WMove(WRow() - 1, WCol() - 1)

   $PLATFORMS$
      DOS
   $SEEALSO$
      WOpen(), WSelect(), WBoard(), WMode()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WNum()
   $ONELINER$
      Determines the highest window handle
   $SYNTAX$
      WNum() --> nHighestWindow

   $RETURNS$
      WNum() determines the highest open window number (handle) so that you
      can iterate a loop over the range of open windows (see Winstore.prg in
      the samples directory).  Remember that any number of handles, from 0 to
      the highest handle number, can be inactive.

   $EXAMPLES$
      Open three windows, and then close the second window.  WNum() returns
      the highest window number, but there are two inactive handles:

      nW1  :=  WOpen(3, 3, 10, 12)
      nW2  :=  WOpen(10, 10, 20, 70)
      nW3  :=  WOpen(5, 5, 22, 60)
      WSelect(nW2)
      WClose()
      ? WNum()            // Result corresponds to nW3

   $PLATFORMS$
      DOS
   $SEEALSO$
      WSelect()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WOpen()
   $ONELINER$
      Opens a new window
   $SYNTAX$
      WOpen(<nTopRow>, <nLeftColumn>, <nBottomRow>,
         <nRightColumn>, [<lDelete>]) --> nWindow

   $ARGUMENTS$
      <nTopRow>  Designates the top row.  The value can be between 0 and
      24.

      <nLeftColumn>  Designates the leftmost column.  The value can be
      between 0 and 79.

      <nBottomRow>  Designates the bottom row.  The value can be between 0
      and 24.

      <nRightColumn>  Designates the rightmost column.  The value can be
      between 0 and 79.

      <lDelete>  Designates whether the area of the screen selected for
      the newly opened window is erased (.T.) or not (.F.).  The default value
      (.F.) does not erase the area.

   $RETURNS$
      WOpen() returns a handle to the new window.  If there is an error,
      WOpen() returns -1.

   $DESCRIPTION$
      WOpen() opens a new window.  If a window can be opened, then the
      function returns a number (handle) for this window.  If a window is
      opened with invalid coordinates, WOpen() returns -1 and the window that
      was active at the time of the function call is still active.

   $NOTES$
      ■  Beginning with CA-Clipper 5.01, windows that lie completely
         under the actual screen border, or under the borders defined by
         WBoard(), can also be opened.

      ■  After you open a window, all screen output is redirected to
         the window if it is not written directly into screen memory.  This
         applies to output from CA-Clipper, DOS, and other programs.  If the
         output rows are longer than the window is wide, then there is a line
         feed (i.e. for SCOREBOARD output).

      ■  If a shadow has been selected using WSetShadow(), the window
         screen area is cleared when you open the window.

   $EXAMPLES$
      This function opens a window with the top left corner in row 5 at column
      10, and the bottom right corner in row 20 at column 70.  If the window
      opens successfully, the returned value is 1:

      nWindow := WOpen(5, 10, 20, 70)

   $PLATFORMS$
      DOS
   $SEEALSO$
      WBoard(), WSelect(), WClose()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WRow()
   $ONELINER$
      Returns the position of the top row of the active window
   $SYNTAX$
      WRow([<lAfterWCENTER>]) --> nRow

   $ARGUMENTS$
      <lAfterWCENTER>  Designates an optional parameter.  If this
      parameter is .T., the function returns what the postion of the top row
      of a window would be after a call of WCenter().  (This function does not
      call WCenter().)  The default value (.F.) returns the current position.

   $RETURNS$
      WRow() returns the row of the currently selected window, relative to the
      physical screen.

   $DESCRIPTION$
      WRow() determines the current position of the top row of the currently
      selected window.  This allows you to save a window position for a window
      that was moved previously using the cursor keys or WMove().  You can
      later reopen the window at exactly this position.

      If you used invalid parameters with WMove() to move a window, WRow()
      lets you determine the current window position.  WRow() is particularly
      helpful since WMove() automatically adapts to the invalid parameters.
      WRow() can also be helpful after you use the WCenter() function.  The
      new coordinates can be determined using WRow() and WCol().

      Additionally, with the specification of the optional parameter, you can
      determine the position of a window after a call of WCenter() without
      actually calling WCenter().

   $NOTES$
      ■  The value returned can be negative.  If so, the first row is
         outside of the visible area.

   $EXAMPLES$
      This program can determine the position of the window at all times:

      nTop   :=  10
      nLeft   :=  15
      WOpen(nTop, nLeft, nTop + 10, nLeft +40)

         * Someone moved the window!

      nTop    :=  WRow()                 // Save the current position
      nLeft   := WCol()                  // of the upper left corner
      WClose()                           // Close the window

         * Other program sections

      WOpen(nTop, nLeft, nTop + 10, nLeft + 40)   // Open with old
                                                  // values

   $PLATFORMS$
      DOS
   $SEEALSO$
      WOpen(), WSelect(), WCol(), WMode(), WLastCol()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WSelect()
   $ONELINER$
      Activates one of the open windows
   $SYNTAX$
      WSelect([<nActivateWindow>]) --> nSelectedWindow

   $ARGUMENTS$
      <nActivateWindow>  Designates the handle of the window that is
      selected.  Without this parameter, the function returns the handle of
      the currently selected window.

   $RETURNS$
      WSelect() returns the handle of the current window.

   $DESCRIPTION$
      WSelect() allows you to take an already open but inactive window and
      reactivate it.  You can specify numbers from 1 to 255.  Window 0
      corresponds to the physical screen.  By omitting the parameter you can
      determine the handle of the window currently selected.

   $NOTES$
      ■  Many window functions, like WBox(), WCenter(), and WFormat(),
         always relate to the active window.

      ■  With an invalid (i.e. negative) window number, WSelect()
         returns an error code of -1, and the currently selected window
         remains active (no change).

   $EXAMPLES$
      Select nWindow, as long as it was previously opened by WOpen():

      WSelect(nWindow)

   $PLATFORMS$
      DOS
   $SEEALSO$
      WOpen()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WSetMove()
   $ONELINER$
      Turns the interactive movement mode on or off
   $SYNTAX$
      WSetMove([<lNewMoveMode>]) --> lOldMoveMode

   $ARGUMENTS$
      <lNewMoveMode>  Designates whether a window can be moved
      interactively (.T.) or not (.F.) with the SCROLL LOCK key or the
      KSetScroll() function.  The default value (.T.) allows the window to be
      moved.

   $RETURNS$
      When called without parameters the function returns the current setting
      for WSetMove().  If a parameter is passed, it returns the previous
      setting.

   $DESCRIPTION$
      This function allows you to prevent (or permit) a user to interactively
      move a window with the cursor keys.  If no parameter is specified, the
      function returns the current status of the switch without changing the
      current status.

   $NOTES$
      ■  The WSetMove() setting does not affect the WMove() function;
         it only affects the interactive setting.  The WMode() setting
         determines if a window can be moved under a border of an area set by
         WBoard().

   $EXAMPLES$
      This example specifies that the current window cannot be moved
      interactively:

      WSetMove(.F.)
      WOpen(5, 5, 15, 15)

   $PLATFORMS$
      DOS
   $SEEALSO$
      WMove(), WBoard(), WMode(), KSetScroll(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WSetShadow()
   $ONELINER$
      Sets the window shadow colors
   $SYNTAX$
      WSetShadow([<cAttribute>]) --> nOldAttribute

   $ARGUMENTS$
      <cAttribute>  Designates the color attribute for window shadows.  It
      can be represented  as a numeric string ("nn/nn") or as a color string
      ("cc/cc").  A value of -1 turns off the shadow display.

      ()  When you call the function without parameters, it returns the
      current shadow color setting.

   $RETURNS$
      WSetShadow() returns the previously set shadow color, or it returns -1
      if no shadow color has been set.

   $DESCRIPTION$
      WSetShadow() sets individual color attributes for shadows of every
      window, which are displayed below and to the right of each window.  The
      WSetShadow() setting then applies to all subsequently opened windows.

   $NOTES$
      ■  When you use shadows, the window screen area is erased during
         opening.

      ■  The proportions of the right and lower shadows are adapted to
         the height of the characters.  For example, the proportion is  2:1
         with 25 rows; and the proportion is  1:1 with 50 rows.

   $EXAMPLES$
      In order to experiment with shadows, you should first fill the screen
      with a character like Chr(176):

      SetClearB(176)
      CLEAR                    // Fill screen with Chr(176)

      WSetShadow("N+")         // Gray shadows
      WOpen(1, 1, 10, 50)
      WBox()

      WSetShadow(-1)           // Switch shadow display off
      WOpen(15, 1, 20, 50)
      WBox()

      Inkey(0)                 // Switch on move mode using
                               // SCROLL-LOCK

      WAClose()

   $PLATFORMS$
      DOS
   $SEEALSO$
      NToColor(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WStep()
   $ONELINER$
      Determines the step width of interactive window movement
   $SYNTAX$
      WStep(<nVertical>,<nHorizontal>) --> nResult

   $ARGUMENTS$
      <nVertical>  Designates the number of rows the window steps when
      moved interactively.

      <nHorizontal>  Designates the number of columns the window steps
      when moved interactively.

   $RETURNS$
      If an error occurs, WStep() returns -1.   If no errors occur, it returns
      0.

   $DESCRIPTION$
      WStep() allows you to set the number of steps a window moves with each
      key stroke.

      Exact Positioning

      Normally, in the case of a step size greater than (1,1), you would not
      be able to select every screen position.  However, unique interactive
      mode behavior lets you select every screen position anyway!  Pressing
      two opposing arrow keys, one immediately after the other, causes a step
      size of 1 to become effective for that axis.  This step size allows
      precise positioning of the window!

   $NOTES$
      ■  This function only operates when all windows are closed.  The
         preset values are 2 rows for the vertical steps and 5 columns for the
         horizontal steps.  The maximum values are 6 rows for the vertical
         steps and 20 rows for the horizontal steps.  If a step value exceeds
         the maximum value, then the step value is set to the maximum correct
         value.

   $EXAMPLES$
      When you use the cursor keys, the selected window is moved 1 row
      vertically and 3 rows horizontally:

      WStep(1, 3)

   $PLATFORMS$
      DOS
   $SEEALSO$
      WAClose(), WSetMove()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Extended Drivers
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      In addition to supporting the window functions, the CTUS.LIB extended
      driver contains a series of independent functions, all of which are
      described in this chapter.

      We are concerned here with functions that relate directly to CA-Clipper
      keyboard input, screen and printer output, or other internal functions.
      To use these internal functions, the driver must be linked in.  The use
      of CTUS.LIB does not mean that all the code for all the functions
      contained in CTUS.LIB is linked to your application.  An intensive
      modularization effort causes RTLINK to link only those portions that are
      actually needed.

      b>The Use of CTUS.LIB</b>

      The extended driver is delivered as an .OBJ file (CTUS.OBJ) to allow
      replacement of the CA-Clipper driver module in CLIPPER.LIB during
      linking.  The extended driver must be included in the list of object
      files.

      b>Video Modes</b>

      Some functions which relate to screen adapters are found in the Video
      Modes chapter rather than in the  Video Functions chapter.

      b>Changing Modes</b>

      Some settings are reset by a mode change:

      Cursor position to:      Line 0, Column 0

      Screen page 0:           SETPAGE()

      All font information:    SetFont(), FONTLOAD(), FONTSELECT()

      All palette information: EGAPALETTE(), VGAPalette()

      Border settings:         SET COLOR TO

      b>DSETWINDOW()/External Screen Output</b>

      This is a very important switch for CA-Clipper Tools that impacts many
      functions and other modules.  DSETWINDOW() determines whether or not the
      output of external programs or modules is redirected to a window.
      (CA-Clipper Tools functions are considered "external").

      The default setting for this switch (.T.) redirects the output.  To make
      this possible, the driver changes the interrupt vector 10H.  Under
      certain circumstances external programs will not accept changes in
      particular interrupt vectors, which is why you must call DSETWINDOW(.F.)
      before you call the RUN function.

      Certain other functions, like ISANSI() or NUMCOL(), return false or
      differing values in conjunction with DSETWINDOW().  Pay attention to the
      accompanying notes in the function descriptions.

      b>System Settings Are Saved</b>

      When you end an application under CA-Clipper's control (normal program
      termination, Alt-C, or ending after a CA-Clipper error message), the
      cursor type, color attribute, and interrupt vectors 0 to 127 are
      restored.

      However, if you exit a program in any other way (usually with an
      external module containing errors) then the extended driver system
      settings cannot be restored.  Previously changed interrupt vectors are
      probably still changed, which sooner or later result in a system crash.
      If this occurs, reboot as soon as possible.

      b>The QUIT File</b>

      A QUIT file can be added to any of the extended driver functions.  The
      QUIT file provides information at the next program start as to whether
      the previous run ended correctly.  Additionally, the user's keyboard
      input is also recorded.

      The default name for this file is the same name as your CA-Clipper
      program except that it has a .Q extension instead of a .EXE extension.
      However, you can select another name for the file.  For more
      information, please see DSETQFILE(), DSETQNAME() and KEYREAD().
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CGA40()
   $ONELINER$
      Switches to 40-column mode (color or monochrome)
   $SYNTAX$
      CGA40([<lMonochromeMode>]) --> lSwitch

   $ARGUMENTS$
      <lMonochromeMode>  Designates the 40ûcharacter mode.  If this
      parameter is .T., the function switches to the monochrome CGA
      40-character mode.  If this parameter is.F., the function switches to
      the 40-character color mode.  The default value is .F..

   $RETURNS$
      CGA40() returns .T. if the screen adapter you use permits a switch.

   $DESCRIPTION$
      This function can be used with any screen adapter that has CGA emulation
      capability.  You can switch to CGA 40-character mode, color or
      monochrome.  The function IsColor() also returns .T. in the monochrome
      mode because this option activates a "color summing" of the screen
      adapter and does not switch to the monochrome mode for a hercules
      adapter or a monochrome text adapter.

   $NOTES$
      Important!  This function cannot be implemented when windows are
      open.

      ■  Modes set through this function can also be combined with
         other line counts, i.e. EGA43().

      ■  A call with .T. corresponds to BIOS mode 0.  A call with .F.
         corresponds to BIOS mode 1.

   $EXAMPLES$
      ■  Switch to 40-character mode (color):

         ?  CGA40()         //  .T., if successful

      ■  Switch to 40-character mode (monochrome):

         ?  CGA40(.T.)      //  .T., if successful

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETMODE(), CGA80(), EGA43(), VGA50(), MONOCHROME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CGA80()
   $ONELINER$
      Switches to 80-column mode (color or monochrome)
   $SYNTAX$
      CGA80([<lMonochromeMode>]) --> lSwitch

   $ARGUMENTS$
      <lMonochromeMode>  Designates the 40ûcharacter mode.  If this
      parameter is .T., the function switches to the monochrome CGA
      80-character mode.  If this parameter is .F., the function switches to
      the 80-character color mode.  The default value is .F..

   $RETURNS$
      CGA80() returns .T. when the screen adapter you use permits a switch.

   $DESCRIPTION$
      This function can be used with any screen adapter that has CGA emulation
      capability.  You can switch to CGA 80-character mode, color or
      monochrome.  The function IsColor() also returns .T. in the monochrome
      mode because this option activates a "color summing" of the screen
      adapter and does not switch to the monochrome mode for a hercules
      adapter or a monochrome text adapter.

   $NOTES$
      Important!  This function cannot be implemented when windows are
      open.

      ■  A call with .T. corresponds to BIOS mode 2.  A call with .F.
         corresponds to BIOS mode 3.

   $EXAMPLES$
      ■  Switch to 80-character mode (color):

         ?  CGA80()         //  .T., if successful

      ■  Switch to 80-character mode (monochrome):

         ?  CGA80(.T.)      //  .T., if successful

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETMODE(), CGA40(), EGA43(), VGA50(), MONOCHROME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DSetKBIOS()
   $ONELINER$
      Turns the extended keyboard mode on or off through BIOS (additional keys F11, F12)
   $SYNTAX$
      DSetKBIOS([<lNewKeyboardMode>]) --> lOldKeyboardMode

   $ARGUMENTS$
      <lNewKeyboardMode>  Designates whether the extended keyboard input
      mode is on (.T.) or off (.F.).  The default value (.T.) designates that
      the extended keyboard input mode is on.

   $RETURNS$
      When called without the parameter, this function returns the current
      setting for DSetKBIOS().  If you pass a parameter, then it returns the
      previous setting.

   $DESCRIPTION$
      Beginning with CA-Clipper 5.0, all keyboard entries are read through the
      BIOS instead of DOS.  The default setting for DSetKBIOS() is now the
      opposite of what it was in previous versions.  The default setting for
      the enhanced keyboard is on (.T.).  When the enhanced keyboard mode is
      off, keyboard entries are redirected through DOS.  This function is very
      useful if file inputs must be read at program start.

   $NOTES$
      ■  Symbolic constants for keyboard coding are found in the
         CTSCAN.CH include file and in Appendix A.

   $EXAMPLES$
      ■  This example shows a keyboard entry that is redirected through
         DOS:

         C:\>TEST < KEYS.DAT

      ■  This example shows the application TEST.EXE:

         DSetKBIOS(.F.)            // Switch to DOS input mode
         ACCEPT "" TO cInput

   $PLATFORMS$
      DOS
   $SEEALSO$
      KEYREAD(), KEYSEND(), SetKXLat(), SCANKEY(), KBDTYPE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DSETNOLINE()
   $ONELINER$
      Ignores the next line feed sent to the screen
   $SYNTAX$
      DSETNOLINE([<lNewLFMode>]) --> lOldLFMode

   $ARGUMENTS$
      <lNewLFMode>  Designates whether the next line feed for the screen
      is ignored (.T.) or not (.F.).  The default value (.F.) designates that
      the next line feed is not ignored.

   $RETURNS$
      When called without a parameter, the function returns the current
      setting for DSETNOLINE().  If a parameter is passed, it returns the
      previous setting.

   $DESCRIPTION$
      DSETNOLINE() can be used in conjunction with a LIST command when you
      have empty lines you want overwritten by the next line (see example).
      You can also suppress a line feed issued by CA-Clipper before each LIST.
      This makes it possible to begin LIST output on line 0.

   $EXAMPLES$
      When you use DSETNOLINE(), records with the Art_nr field empty are
      written to the screen but are overwritten by the next record where
      Art_nr is present:

      LIST Art_nr, Art_bez, DSETNOLINE(Empty(Art_nr))

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DSETQFILE()
   $ONELINER$
      Creates a protocol file when the program ends normally
   $SYNTAX$
      DSETQFILE([<lNewQuitMode>]) --> lOldQuitMode

   $ARGUMENTS$
      <lNewQuitMode>  Designates whether the automatic QUIT file is
      created (.T.) or not (.F.).  The default value (.F.) does not create an
      automatic QUIT file.

   $RETURNS$
      When called without parameter, the function returns the current
      DSETQFILE() setting.  If a parameter is passed, it returns the previous
      setting.

   $DESCRIPTION$
      This function allows for the creation of a QUIT file.  This file can be
      used to determine if an application has been terminated normally or not
      (i.e.  Ctrl-Alt-Del).  When the program ends, the contents of the
      keyboard buffer are written to a file.  This allows you to determine
      what keyboard input the user made, which can be used to trace errors and
      reconstruct files.  The size of the QUIT file corresponds to the size of
      the keyboard buffer.  To save more than the 16 default characters, you
      must increase the keyboard buffer size with SET TYPEAHEAD.  (The maximum
      buffer size 32768 keystrokes.)

      The name for the QUIT file is normally constructed from the name of the
      .EXE file with a .Q extension.  SETQNAME() lets you use any file name
      you choose.

   $NOTES$
      ■  The keyboard data appears in KEYREAD() format in the QUIT file
         (see Appendix A: Key Codes/ CTSCAN.CH).

      ■  Only those keyboard inputs already processed by the program
         are written to the QUIT file.

      ■  An existing QUIT file is overwritten automatically if it has
         the same name as the QUIT file that is currently being written.

   $EXAMPLES$
      ■  This statement causes the program to create a standard QUIT
         file when you exit the program:

         DSETQFILE(.T.)       // QUIT file will be created

      ■  Select the name of the QUIT file:

         SETQNAME("C:\LOGS\PROTO.LOG")
         DSETQFILE(.T.)       // QUIT file will be created
                              // with an alternate name

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETQNAME(), KEYREAD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DSETTYPE()
   $ONELINER$
      Determines the size of the keyboard buffer (SET TYPEAHEAD TO)
   $SYNTAX$
      DSETTYPE() --> nBufferSize

   $RETURNS$
      DSETTYPE() returns the current size of the CA-Clipper keyboard buffer.

   $DESCRIPTION$
      DSETTYPE() allows you to determine what size the CA-Clipper keyboard
      buffer has been set to with SET TYPEAHEAD TO.  You can use the function
      to determine the number of characters that can be placed in the keyboard
      buffer using KEYSEND().

   $NOTES$
      ■  The keyboard buffer is made of memory that is internal to
         CA-Clipper, which is independent of the system buffer.  In
         CA-Clipper, the standard setting for TYPEAHEAD is 16 characters.
         (This corresponds to the size of the system buffer.)

      ■  For every character that is processed in a CA-Clipper program,
         two bytes must be allocated in the keyboard buffer.  DSETTYPE()
         determines the number of CA-Clipper characters, not the number of
         bytes!  The standard buffer size is not 16, but 32 bytes.

   $EXAMPLES$
      The current size of the keyboard buffer is queried and increased if
      needed:

      nSize  :=  DSETTYPE()

      IF nSize < 256
         SET TYPEAHEAD TO 256
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      KEYREAD(), KEYSEND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DSETWINDOW()
   $ONELINER$
      Reroutes external functions and programs to a window
   $SYNTAX$
      DSETWINDOW([<lNewDisplayMode>]) --> lOldDisplayMode

   $ARGUMENTS$
      <lNewDisplayMode>  Designates whether the screen output from
      external programs or other language UDF's displays in the current
      window.

   $RETURNS$
      When called without a parameter, the function returns the current
      setting for DSETWINDOW().  If a parameter is passed, it returns the
      previous setting.

   $DESCRIPTION$
      DSETWINDOW() allows you to determine if only CA-Clipper screen outputs
      should appear in a window, or if all outputs (all external modules and
      programs, including DOS) should appear.  If you would like to implement
      a subroutine for screen handling with CA-Clipper Tools window functions,
      you can use this switch to turn off these functions for a short time.

      Important!  Before you call external programs using RUN, you should
      set DSETWINDOW() to .F.; if you do not, some programs will not run
      correctly.

   $NOTES$
      Important!  The standard setting for DSETWINDOW() is on.  This means
      that all program output, not written directly into the screen memory,
      displays in the currently active window.

      ■  CA-Clipper screen output is always written in a window if one
         is open and active.  Only screen output from external routines (like
         Assembler or C UDF's, or external programs called using RUN) can be
         affected.  CA-Clipper Tools functions are also viewed as foreign or
         external.

      ■  If you call DSETWINDOW() with .T., a change in cursor position
         in an external module or program also affects the cursor position in
         CA-Clipper.  If you do not want to change the cursor position in
         CA-Clipper, then set DSETWINDOW() to .F. so that the CA-Clipper
         cursor position remains unchanged.  If you still want to pass the
         cursor position to CA-Clipper, then use the SetRC() function without
         parameters.

      ■  Some CA-Clipper Tools functions ignore this switch because
         they work directly with the physical screen memory.

      ■  CA-Clipper Tools has a public variable available for your own
         Assembler or C routines to affect the DSETWINDOW() function.  It can
         be addressed as follows:

         EXTR _WINDOW:WORD
         MOV  _WINDOW, 0               // Window functions OFF, all
                                       // other values switched ON!

      ■  If the switch is set to on, then interrupt 16 (10h, video) and
         function 19 (13h, write string), normally only available on AT's,
         become available on PC XT's.

   $EXAMPLES$
      ■  Do not reroute other program output to the selected window:

         DSETWINDOW(.F.)

      ■  Do a test to see if ANSI.SYS has been linked in to CONFIG.SYS:

         lVar  :=  DSETWINDOW(.F.)
         ? ISANSI()
         DSETWINDOW(lVar)              // Reset to old status

   $PLATFORMS$
      DOS
   $SEEALSO$
      ScreenFile(), FileScreen()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      EGA43()
   $ONELINER$
      Switches to the 43-line EGA mode
   $SYNTAX$
      EGA43() --> lSwitched

   $RETURNS$
      EGA43() returns .T. if the screen graphics adapter successfully switched
      to the 43-line mode.

   $DESCRIPTION$
      This function can be used with either an EGA or VGA card.  A 43-line
      mode is requested, and the maximum number of coordinates for the
      CA-Clipper screen output is automatically increased.  It isn't necessary
      to also call the SETMAXROW() and SETMAXCOL() functions.

   $NOTES$
      Important!  This function cannot be implemented when windows are
      open.

   $EXAMPLES$
      The following example switches to 43-line mode, making lines 0 to 42
      available:

      IF IsEGA()
         EGA43()
      ENDIF

      @ 42, 10 SAY "CA-Clipper"      // Last line
      WAIT
      CGA80()                        // Return to 25-line mode

   $PLATFORMS$
      DOS
   $SEEALSO$
      CGA40(), CGA80(), VGA50(), MONOCHROME(), SETSCRMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FIRSTCOL()
   $ONELINER$
      Sets the first visible column of a virtual screen
   $SYNTAX$
      FIRSTCOL(<nFirstNewColumn>) --> nFirstOldColumn

   $ARGUMENTS$
      <nFirstNewColumn>  Designates which column is the first visible
      column on the left side of a virtual screen.

   $RETURNS$
      If the parameter is passed, the function returns the previous setting.
      If no parameter is passed, it returns the current setting.

   $DESCRIPTION$
      This function is important for use in setting virtual screen size in
      conjunction with SETMAXROW() and SETMAXCOL().  You can select the first
      column that you would like to be visible on the left side of the screen.
      In this way the screen can be moved in any direction.

   $NOTES$
      ■  To simplify programming, values outside of the permissible
         range are automatically corrected to the maximum or minimum values
         (see example).

   $EXAMPLES$
      The following example sets up a screen with 100 lines and 120 columns.
      To help you with screen orientation, the current column number is
      displayed at three locations on this virtual screen.  The virtual screen
      can be moved in any direction using cursor keys and PgUp and PgDn:

      SETMAXROW( 99)                        // screen with 100 lines
      SETMAXCOL(119)                        // and 120 columns
      CLEAR

      FOR nCount = 0 TO MaxRow()            // Build screen
         @ nCount, 0 SAY "Line" + NToC(nCount, 10, 4)
         @ nCount, MaxCol()/2 -5 SAY "Line" + NToC(nCount, 10, 4)
         @ nCount, MaxCol()  -10 SAY "Line" + NToC(nCount, 10, 4)

      NEXT nCount

      @ 99, 00 SAY Center("This is the last line")

      nKeyVal  := 0
      DO WHILE nKeyVal <> 27
         nKeyVal  := Inkey(0)
         DO CASE
         CASE nKeyVal = 5
            FIRSTROW(FIRSTROW() -1)
         CASE nKeyVal = 24
            FIRSTROW(FIRSTROW() +1)
         CASE nKeyVal = 4
            FIRSTCOL(FIRSTCOL() +1)
         CASE nKeyVal = 19
            FIRSTCOL(FIRSTCOL() -1)
         CASE nKeyVal = 18
            FIRSTROW(FIRSTROW() -10)
         CASE nKeyVal = 3
            FIRSTROW(FIRSTROW() +10)
         ENDCASE
      ENDDO

      FIRSTROW(0)                           // reset
      FIRSTCOL(0)
      SETMAXCOL(79)
      SETMAXROW(24)
      CLEAR

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETMAXCOL(), MaxCol(), FIRSTROW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FIRSTROW()
   $ONELINER$
      Sets the first visible line of a virtual screen
   $SYNTAX$
      FIRSTROW(<nFirstNewLine>) --> nFirstOldLine

   $ARGUMENTS$
      <nFirstNewLine>  Designates which line is displayed as the top line
      on the virtual screen.

   $RETURNS$
      If the parameter is passed, the function returns the previous setting
      each time.  If no parameter is passed, it returns the current setting.

   $DESCRIPTION$
      This function is important for use in setting virtual screen size in
      conjunction with SETMAXROW() and SETMAXCOL().  You can select the first
      line that you would like to have visible at the top side of the screen.
      In this way the screen can be moved in any direction.

   $NOTES$
      ■  To simplify programming, values outside of the permissible
         range are automatically corrected to the maximum or minimum values
         (see example).

   $EXAMPLES$
      The following example sets up a screen with 100 lines and 120 columns.
      To help you with screen orientation, the current column number is
      displayed at three locations on this virtual screen. The virtual screen
      can be moved in any direction using cursor keys and PgUp and PgDn:

      SETMAXROW( 99)                        // screen with 100 lines
      SETMAXCOL(119)                        // and 120 columns
      CLEAR

      FOR nCount = 0 TO MaxRow()            // Build screen
         @ nCount, 0 SAY "Line" + NToC(nCount, 10, 4)
         @ nCount, MaxCol()/2 -5 SAY "Line" + NToC(nCount, 10, 4)
         @ nCount, MaxCol()  -10 SAY "Line" + NToC(nCount, 10, 4)
      NEXT nCount

      @@ 99, 00 SAY Center("This is the last line")

      nKeyVal  := 0
      DO WHILE nKeyVal <> 27
         nKeyVal  := Inkey(0)
         DO CASE
         CASE nKeyVal = 5
         FIRSTROW(FIRSTROW() -1)
         CASE nKeyVal = 24
            FIRSTROW(FIRSTROW() +1)
         CASE nKeyVal = 4
            FIRSTCOL(FIRSTCOL() +1)
         CASE nKeyVal = 19
            FIRSTCOL(FIRSTCOL() -1)
         CASE nKeyVal = 18
            FIRSTROW(FIRSTROW() -10)
         CASE nKeyVal = 3
            FIRSTROW(FIRSTROW() +10)
         ENDCASE
      ENDDO

      FIRSTROW(0)                           // reset
      FIRSTCOL(0)
      SETMAXCOL(79)
      SETMAXROW(24)
      CLEAR

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETMAXROW(), MaxRow(), FIRSTCOL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETBOXGROW()
   $ONELINER$
      Gets the time delay with which boxes are opened
   $SYNTAX$
      GETBOXGROW() --> nTimeDelay

   $RETURNS$
      GETBOXGROW() returns the value set in SETBOXGROW() for the delay in
      creating a box.

   $DESCRIPTION$
      GETBOXGROW() retrieves the time delay that a box in "grow" mode has when
      it is opened.

   $EXAMPLES$
      Here is an example of a box with 10 milliseconds between each growth
      step:

      SETBOXGROW(10)
      WOpen(2, 2, 23, 78)            // Sets box coordinates only
      WBox()                         // Generates box with delay
      ? GETBOXGROW()                 // Result: 10

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETBOXGROW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETCURSOR()*
   $ONELINER$
      Determines the setting for the cursor form
   $SYNTAX$
      GETCURSOR([<lMode>]) --> nCursorForm

      *  This function has been retained for compatibility reasons only.
         Its use in development of future applications is not recommended.
         For future applications use the SetCursor() function.

   $ARGUMENTS$
      <lMode>  Sets the cursor form to the overwrite (.F.) or the insert
      (.T.) mode.  The default value (.F.) sets the cursor form to the
      overwrite mode.

   $RETURNS$
      The returned value designates how many scan lines are used to display
      the cursor.

   $DESCRIPTION$
      GETCURSOR() allows you to save the current cursor form for an input
      field in a function called with a VALID, before you change it in a UDF.
      GETCURSOR() then allows you to restore its old form before returning to
      the GET field.

      CA-Clipper Tools stores the form for two cursor displays: one for
      overwriting and one for inserting.  If <lMode>  is .F. or omitted, then
      the overwrite cursor form is returned.  If <lMode> is .T., then the
      insert cursor form is returned.  (See the note with SetCursor()).

      The cursor is broken down into lines on the screen called scan lines.
      The form and height of the cursor are specified by two instructions that
      correspond to the first and the last line used for the cursor display.
      GETCURSOR() returns both numbers combined into one value, according to
      the following formula:

            (Starting Line * 256) + Final Line

      The NumHigh() and NumLow() functions let you separate the starting and
      final lines very easily.

   $NOTES$
      ■  The word "line" here does not mean a screen (output) line, but
         the scan or pixel lines from which screen characters are created.

      ■  This function works independently of the SET CURSOR setting.

   $EXAMPLES$
      Break down cursor information into a starting line and a final line:

      nCursor  :=  GETCURSOR()
      ? NumHigh(nCursor)            // Cursor start line
      ? NumLow(nCursor)             // Cursor final line

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetCursor(), NumHigh(), NumLow()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetKXLat()
   $ONELINER$
      Determines the current key code table
   $SYNTAX$
      GetKXLat(<nKeyValue>) --> nKeyValue

   $ARGUMENTS$
      <nKeyValue>  Designates the original key code so that its current
      value can be tested for translation or lock out.

   $RETURNS$
      GetKXLat() returns the status of the key designated by <nKeyValue>.  A
      return value of 0 indicates that there is no translation.  A return
      value of -1 indicates that the key is locked out.  And any other return
      indicates that the designated key is translated into that key value.

      With Chr(NumLow(<nkeyValue>)) + Chr(NumHigh(<nkeyValue>)) the return
      value can be converted to the form used in the include file CTSCAN.CH

   $DESCRIPTION$
      GetKXLat() allows you to test to see if a key designated under
      SetKXLat() has been locked out or translated.  <nKeyValue> is the
      original key code.  The key codes used are described in detail in the
      SetKXLat() function.

   $NOTES$
      ■  Symbolic constants for key codes can be found in the CTSCAN.CH
         file.

      ■  You can also use the symbolic constants from the CA-Clipper
         file INKEY.CH for <cKeyValue>.

   $EXAMPLES$
      Has the "A" key been locked out or translated?

      nVar  := GetKXLat(KS_A)

      IF nVar <> 0
         * Undo translation/lock out for "A"
         SetKXLat(KS_A)               // "A" returns to "A"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetKXLat(), SetKXTab(), GetKXTab()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetKXTab()
   $ONELINER$
      Retrieves the entire key code table
   $SYNTAX$
      GetKXTab() --> cTable

   $RETURNS$
      GetKXTab() returns a character string that contains all of the
      previously defined key translations.

   $DESCRIPTION$
      A CA-Clipper Tools key table can be as large as the maximum allocatable
      string.  The number of translations corresponds to:

      ((Memory(1) * 1024)/4),

      where the required memory is allocated dynamically.  The key code
      translations can be done through SetKXLat() or SetKXTab().

      GetKXTab(), in contrast to GetKXLat(), always returns a table of all
      defined key code translations as a string.  A translation table can then
      be saved in a variable and reset using SetKXTab().

   $EXAMPLES$
      Save the entire key table and reinstall it later:

      cKXTab  := GetKXTab()

         DO KEYCHANGE

      SetKXTab(cKXTab)

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetKXTab(), SetKXLat(), GetKXLat()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETLINES()
   $ONELINER$
      Determines the number of lines after which the screen display pauses
   $SYNTAX$
      GETLINES() --> nLineNumber

   $RETURNS$
      GETLINES() returns the value established with SETLINES()

   $DESCRIPTION$
      GETLINES() queries the value previously set with SETLINES().

   $EXAMPLES$
      ■  Set a value:

         SETLINES(20)

            LIST ...

      ■  Query that value:

         ? GETLINES()               // Result: 20

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETLINES()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETMODE()
   $ONELINER$
      Uses the current screen mode as a function name
   $SYNTAX$
      GETMODE() --> cFunctionName

   $RETURNS$
      GETMODE() returns a character string that represents the active mode.
      The character string corresponds to the CA-Clipper Tools function call
      used to switch to that mode.

   $DESCRIPTION$
      This function substitutes for a difficult to understand numeric code for
      the return value of a function.  This character string corresponds to
      the function call used to switch to the current mode.  The returned
      value can be held in a variable, and this function can be called later
      using the compile and run operator.

   $NOTES$
      Important!  You must declare all function calls for setting a mode
      which could occur as a return value from this function as EXTERNAL.

   $EXAMPLES$
      Notice the mode and reset it later:

      cVar := GETMODE()                 // Save current mode
      ? cVar                            // For example "CGA80(.T.)"

      CGA40(.T.)                        // Select other mode

      ? &(cVar)                         // Reset old mode.

   $PLATFORMS$
      DOS
   $SEEALSO$
      CGA40(), CGA80(), MONOCHROME(), EGA43(), VGA50()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETPAGE()
   $ONELINER$
      Determines the current screen page
   $SYNTAX$
      GETPAGE([<lHiddenPage>]) --> nScreenPage

   $ARGUMENTS$
      <lHiddenPage>  Designates an optional parameter.  If this parameter
      is .T., the function returns the number of the currently hidden page.
      If this parameter is .F., the function returns the number of the visible
      screen page.  The default value is .F..

   $RETURNS$
      GETPAGE() returns the number of the currently set screen pages.

   $DESCRIPTION$
      GETPAGE() allows you to determine which screen page is currently
      available.  The screen page that is currently available can be switched
      by using the SETPAGE() function.

      Since screen output can be directed to a hidden screen page, you can
      determine the number of this hidden page by setting the parameter to .T.

   $EXAMPLES$
      Determine the active screen page:

      ? GETPAGE()                        // i.e. 2

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETPAGE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETPBIOS()
   $ONELINER$
      Determines if printing is through DOS or the BIOS
   $SYNTAX$
      GETPBIOS() --> nPrintMode

   $RETURNS$
      GETPBIOS() returns the setting made in SETPBIOS() as a numeric value
      between 0 and 3.

   $DESCRIPTION$
      This function allows you to determine the current setting for rerouting
      the printer through extended drivers.  If the function returns a value
      of 0, the print output is through DOS.  If the value is between 1 and 3,
      the output is through the BIOS on the corresponding printer.

   $EXAMPLES$
      Determine the current setting:

      ? GETPBIOS()                        // 0  Output via DOS

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETPBIOS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETPXLAT()
   $ONELINER$
      Retrieves the current printer table
   $SYNTAX$
      GETPXLAT() --> cPrintTable

   $RETURNS$
      GETPXLAT() returns the entire print table or returns an empty character
      string if a print table has not been defined.

   $DESCRIPTION$
      GETPXLAT() retrieves the current printer table set by SETPXLAT().  The
      string returned can be assigned to a variable and restored later.  If
      you use a printer with different font styles, this function allows you
      to switch print tables as required.

   $EXAMPLES$
      ■  Save the existing table:

         cOldTab  := GETPXLAT()

      ■  Install new table:

         SETPXLAT(......)
         SETPXLAT(......)
         SETPXLAT(......)

      ■  Output to another printer:

         SET PRINTER TO LPT2

      ■  Restore the old table starting at position 0:

         SETPXLAT(0, cOldTab)

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETPXLAT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETSCRMODE()
   $ONELINER$
      Determines the number of the active video mode
   $SYNTAX$
      GETSCRMODE() --> nModeNumber

   $RETURNS$
      The function returns the mode number of the currently set video mode.

   $DESCRIPTION$
      In contrast to GETMODE(), GETSCRMODE() returns the current video mode as
      a numeric value.  This allows you to query special modes for particular
      screen adapters and reset them using SETSCRMODE().  The following modes
      are accommodated by other functions within CA-Clipper Tools:

      Table 2-1: Modes and Their Coding
      <table>
          Mode                Mode Number

          CGA40 Monochrome    0
          CGA40 Color         1
          CGA80 Monochrome    2
          CGA80 Color         3
          Monochrome          7
          EGA43 (EGA only)    299 (43+256)
          VGA28 (VGA only)    284 (28+256)
          VGA50 (VGA only)    306 (50+256)
         </table>

   $NOTES$
      ■  GETSCRMODE() returns the value previously set with
         SETSCRMODE() and the current BIOS or CA-Clipper Tools mode.  If you
         switch into a special mode for a particular screen adapter, there is
         no guarantee that this is the mode number that GETSCRMODE() returns.
         This is a factor of the unique behavior of the specific screen
         adapter.

   $EXAMPLES$
      ■  Set the EGA 43-line mode:

         EGA43()

      ■  The current video mode is saved:

         nOldMode  := GETSCRMODE()

      ■  The current video mode is restored later:

         SETSCRMODE(nOldMode)

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETSCRMODE(), GETMODE(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETTAB()
   $ONELINER$
      Retrieves tab values for CA-Clipper screen output
   $SYNTAX$
      GETTAB() --> cTabTable

   $RETURNS$
      GETTAB() returns the currently installed tab locations for CA-Clipper
      screen output in the form of a character string.

   $DESCRIPTION$
      This function gives the tab definitions specified in SETTAB() for
      CA-Clipper screen output.  You can use this function to save the active
      tab definitions.

   $EXAMPLES$
      Save the tab definitions:

      cTabs := GETTAB()

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETTAB()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      INKEYTRAP()
   $ONELINER$
      Behaves like Inkey() with support for key traps
   $SYNTAX$
      INKEYTRAP(<nDelay>) --> nKeyCode

   $ARGUMENTS$
      <nDelay>  Designates the delay time in seconds.

   $RETURNS$
      The function returns the same key code as Inkey().

   $DESCRIPTION$
      This function operates in essentially the same way as Inkey().  It
      supports the same time delays and returns the same key codes as values.
      The most significant difference to Inkey() is that all key traps defined
      using SET KEY <Key> TO <Procedure> are supported.  This function saves
      the programmer time; for example, the programmer does not have to
      develop extensive CASE constructs after each Inkey().

   $NOTES$
      ■  After the trap procedure ends, the <nDelay> time is reset.

   $EXAMPLES$
      SET KEY 28 TO HELP               // F1 Key
      nVar  :=  INKEYTRAP(10)          // 10-second delay
      RETURN

      PROCEDURE Help(a, b, c)          // Parameter c is always
                                       // a null string
      ("")

      * Program code desired

      RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      SaveSetKey()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      INPUTMODE()
   $ONELINER$
      Determines the previously active or the currently active input mode
   $SYNTAX$
      INPUTMODE([<lActiveMode>]) --> nInputMode

   $ARGUMENTS$
      <lActiveMode>  Designates an optional parameter.  If this parameter
      is .T., the function returns the currently active mode.

   $RETURNS$
      INPUTMODE() returns a numeric value that indicates the input command for
      the previously active or the currently active input mode.

      Description

      INPUTMODE() allows you to determine what type of input command has been
      interrupted.  When called without a parameter or with .F., the function
      returns the currently active mode or, if no input has occurred, the
      previously active input mode.

      If the function is called with <lActiveMode> set to .T., then only the
      currently active input mode or 0 is returned.  The following table shows
      the return values as well as the symbolic constants and their
      accompanying definitions.

      Table 2-2  Coding the Input Mode
      <table>
          Return  Symbolic Const.    Definition

          0      IMODE_NO            No input command currently.
          1      IMODE_WAIT          WAIT
          2      IMODE_ACCEPT        ACCEPT
          3      IMODE_INPUT         INPUT
          4      IMODE_READ          READ
          5      IMODE_MEMOEDIT      MemoEdit()
          6      IMODE_MENU          MENU
          7      IMODE_INKEY         Inkey()
          8      IMODE_DEBUG         Debugger input
          9      IMODE_GETINPUT      Input within GetInput()
          10     IMODE_GETSECRET     Input within GetSecret()
         </table>

   $EXAMPLES$
      PROCEDURE HELP(A, B, C)

         nArea  := Select()
         nMode  := INPUTMODE()

         IF nMode = 5               // Calling from MemoEdit()
            SELECT MEMOHELP
         ELSE
            SELECT HELP
         ENDIF

         SELECT (nArea)

         RETURN

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KEYREAD()
   $ONELINER$
      Reads already processed CA-Clipper keyboard buffer input
   $SYNTAX$
      KEYREAD() --> cKeyValue

   $RETURNS$
      The returned string contains the characters from the CA-Clipper keyboard
      buffer that have already been read and processed by the program.

   $DESCRIPTION$
      With KEYREAD() you can read the keys that have already been processed by
      your application from the keyboard buffer.  KEYREAD() offers the
      possibility of "looking into the past" of the current program execution
      so you can determine what the user has done up to that point.  This
      gives you the ability to repeat particular actions, perform and undo
      functions, or build keyboard macros.  KEYREAD() can also be very useful
      in searching for errors.

   $NOTES$
      ■  All the keys processed since the last execution of SET
         TYPEAHEAD TO or KEYSEND() are placed in the keyboard buffer.
         Characters already in the buffer, but not yet read by a CA-Clipper
         program through an input instruction, are ignored by KEYREAD().  If
         the keyboard buffer is empty (as at program start, or after executing
         a KEYSEND() or SET TYPEAHEAD TO), the function returns a null string.

      ■  In contrast to the Clipper release form the Summer of 1987,
         KEYREAD() in CA-Clipper returns the entire BIOS key code as defined
         in the CTSCAN.CH include file.  If complete key code compatibility is
         required for an existing application, the CT.CH include file must be
         included.  The CTSCAN.CH file also contains information regarding new
         keyboard function behavior.

   $EXAMPLES$
      cHistory   :=  KEYREAD()                  // Prior input
      IF Right(cHistory, 2) == cSequence
         ? "You have left MEMOEDIT using Ctrl-END!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      KEYSEND(), DSETTYPE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KEYSEND()
   $ONELINER$
      Simulates CA-Clipper keyboard buffer input
   $SYNTAX$
      KEYSEND(<cKeyValue>,[<lAdditiveMode>]) --> lPassed

   $ARGUMENTS$
      <cKeyValue>  Designates one or more sequences that are placed in the
      keyboard buffer.

      <lAdditiveMode>  Designates an optional parameter.  If this
      parameter is .T., then the key codes passed are added to the contents of
      the keyboard buffer.  If the parmeter is .F. or if no parameter is
      passed, the contents of the keyboard buffer are overwritten.

   $RETURNS$
      When the string has been placed successfully in the CA-Clipper keyboard
      buffer, the function returns a value of .T..  If an error occurs, the
      return value is .F..

   $DESCRIPTION$
      KEYSEND() works similarly to the CA-Clipper KEYBOARD command.  However,
      it allows you to use other codes for the characters that are stuffed.
      Symbolic constants for these key codes can be found in the CTSCAN.CH
      include file and in Appendix A.  By using this unique coding for
      characters in the keyboard buffer, KEYSEND() allows you to place keys in
      the buffer that CA-Clipper's KEYBOARD command does not permit, such as
      codes smaller than 0 or greater than 255 (e.g.  all function keys and
      most Alt combinations).  This unique coding is also helpful for two keys
      that have the same Inkey() value and cannot be differentiated with the
      KEYBOARD command.

      If you want to place normal characters like letters and numbers in the
      keyboard buffer, it is better to use the CA-Clipper KEYBOARD command.
      Using CA-Clipper Tools functions for normal characters provides no real
      advantage.  If, on the other hand, you want to simulate other keyboard
      input, like function or control keys, then KEYSEND() is best to use
      because function and control keys can be clearly differentiated.

      As with the CA-Clipper KEYBOARD command, the entire contents of the
      keyboard buffer are cleared as soon as KEYSEND() passes a new character.
      If <lAdditiveMode> is .T., the function adds the key codes to the
      current buffer contents.

   $NOTES$
      ■  Key codes in CA-Clipper Tools have been extended, but the old
         codes are still valid (see include file CTSCAN.CH).

      ■  The maximum length of the string to be saved is now calculated
         as follows:

            maximum allocatable memory / 2

   $EXAMPLES$
      Simulate the function key Alt-F10:

      KEYSEND(KS_ALT_F10)

   $PLATFORMS$
      DOS
   $SEEALSO$
      KEYREAD(), DSETTYPE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MaxCol()
   $ONELINER$
      Extends the CA-Clipper MaxCol() function
   $SYNTAX$
      MaxCol([<lMode>]) --> nMaxColumn

   $ARGUMENTS$
      <lMode>  When .F. is passed, or when no parameter is specified, the
      function returns the highest column number of the selected window.  When
      .T. is passed, it returns the highest column number for the entire
      screen.  The default value (.F.) returns the highest column number for
      the selected window.

   $RETURNS$
      MaxCol() returns the highest column number available within a window or
      within the physical screen.

   $DESCRIPTION$
      MaxCol() is also a CA-Clipper function.  Without parameters, or when
      specifying .F., MaxCol() always returns a value for the selected window.
      In the absence of CA-Clipper Tools, this value is always Window 0, which
      is exactly the same size as the entire screen.  However, if the extended
      driver CTUS.LIB and the CA-Clipper Tools window functions are
      implemented, this value can change.  If you want the highest column for
      the entire screen, regardless of the window selected, you can pass .T.
      for the optional <lMode> parameter.

   $NOTES$
      ■  The explanation of this function was taken from the Video
         Functions chapter and placed in the Extended Driver chapter.  Now all
         CA-Clipper Tools functions that replace and/or extend CA-Clipper
         functions when CTUS.LIB is linked in are in the same chapter.  The
         extensions to the CA-Clipper versions of these functions are only of
         interest when used in conjunction with the other extended driver
         functions and their accompanying windows.

   $EXAMPLES$
      Display the highest column number:

      WOpen(10, 10, 20, 70)            // Open a window
      ? MaxCol()                       // Relates to a window
      ? MaxCol(.T.)                    // Back to the physical screen

   $PLATFORMS$
      DOS
   $SEEALSO$
      NUMCOL(), MaxRow(), CGA40(), SETMAXCOL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MAXPAGE()
   $ONELINER$
      Determines the number of available screen pages
   $SYNTAX$
      MAXPAGE() --> nMaxPage

   $RETURNS$
      This function returns the number of the maximum available video "pages".
      A return of 0 means that only one page is available; so, the actual
      number of available pages is MAXPAGE() +1.

   $DESCRIPTION$
      MAXPAGE() allows you to determine the number of screen pages that are
      available for use on the display adapter.  This information can be
      particularly valuable when you use the SETPAGE() or PAGECOPY() function.

   $EXAMPLES$
      Find the maximum number of available screen pages:

      ? MAXPAGE()                  // Result 3 means 4 pages

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETPAGE(), GETPAGE(), PAGECOPY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MaxRow()
   $ONELINER$
      Extends the CA-Clipper MaxRow() function
   $SYNTAX$
      MaxRow([<lMode>]) --> nMaxRow

   $ARGUMENTS$
      <lMode>  Designates the highest row nmber for the selected window or
      for the entire screen.  When .F. is passed, or when no parameter is
      specified, the function returns the highest row number of the selected
      window.  When .T. is passed, it returns the highest row number for the
      entire screen.  The default value (.F.) returns the highest row number
      for the selected window.

   $RETURNS$
      MaxRow() returns the highest row number available within a window or
      within the physical screen.

   $DESCRIPTION$
      MaxRow() is also a CA-Clipper function.  Without parameters, or when you
      specify .F., MaxRow() always returns a value for the selected window.
      In the absence of CA-Clipper Tools, this value is always Window 0, which
      is exactly the same size as the entire screen.  However, if the extended
      driver CTUS.LIB and the CA-Clipper Tools window functions are
      implemented, this value can change.  If you want the highest row for the
      entire screen, regardless of the window selected, you can pass .T.  for
      the optional <lMode> parameter.

   $NOTES$
      ■  The explanation of this function was taken from the Video
         Functions chapter and placed in the Extended Driver chapter. Now all
         CA-Clipper Tools functions that replace and/or extend CA-Clipper
         functions when CTUS.LIB is linked in are in the same chapter.  The
         extensions to the CA-Clipper versions of these functions are only of
         interest when used in conjunction with the other extended driver
         functions and their accompanying windows.

   $EXAMPLES$
      Display the highest row number:

      WOpen(10, 10, 20, 70)         // Open a window
      ? MaxRow()                    // Relates to a window
      ? MaxRow(.T.)                 // Back to the physical screen

   $PLATFORMS$
      DOS
   $SEEALSO$
      MaxCol(), EGA43(), VGA50(), SETMAXROW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MONOCHROME()
   $ONELINER$
      Switches to the monochrome mode
   $SYNTAX$
      MONOCHROME() --> lSwitched

   $RETURNS$
      MONOCHROME() returns .T. when the screen adapter successfully changes
      modes.

   $DESCRIPTION$
      This function can be used on any screen adapter capable of emulating a
      monochrome card.

   $NOTES$
      Important!  This function cannot be used when windows are open.

      ■  MONOCHROME() sets the BIOS mode to 7.

      ■  This function cannot be used with a second monochrome monitor
         (Hercules).

   $EXAMPLES$
      Switch to monochrome mode:

      ? MONOCHROME()                  // .T., if successful

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETMODE(), CGA40(), CGA80(), EGA43(), VGA50()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PAGECOPY()
   $ONELINER$
      Copies one screen page to another
   $SYNTAX$
      PAGECOPY(<nOriginalPage>, <nCopyPage>) --> lStatus

   $ARGUMENTS$
      <nOriginalPage>  Designates the page from which you copy.

      <nCopyPage>  Designates the target page, the page to which you copy.

   $RETURNS$
      The function returns a value of .T. if the copy is successful.

   $DESCRIPTION$
      A complete screen page (<nOriginalPage>) can be moved to another screen
      page (<nCopyPage>).  With this function, the entire contents of the
      screen memory can quickly be copied to another page, without the need
      for additional working memory for a string.

   $NOTES$
      ■  To find the valid range of page numbers, use the MAXPAGE()
         function.

   $EXAMPLES$
      Copy screen page 0 to page 1:

      ? PAGECOPY(0, 1)                  // .T., if successful

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETPAGE(), GETPAGE(), MAXPAGE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PRINTERROR()
   $ONELINER$
      Returns the error code for the last printer output
   $SYNTAX$
      PRINTERROR() --> nError

   $RETURNS$
      PRINTERROR() returns the code for the last error that occurred in a
      print output.  The following table provides an overview of all the error
      codes and their meanings:

      Table 2-3: Print Output Error Coding
      <table>
          Code    Definition

          0       No error occurred
          5       Access denied
          6       Invalid Handle
          127     Canceled by Ctrl-Break
         </table>

   $DESCRIPTION$
      PRINTERROR() allows you to determine why the last print output failed.
      This function gives you the ability to determine the source of the error
      from within the CA-Clipper error system and react accordingly.  To
      identify an abort command that used Ctrl-Break, CA-Clipper Tools returns
      a value of 127.

   $NOTES$
      ■  PRINTERROR() only returns an error code for print errors that
         occur during a CA-Clipper printing operation.

   $EXAMPLES$
      React to an error during a print operation:

      nStatus  :=  PRINTERROR()

      IF nStatus = 127
      ? "Print operation aborted by user!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETBELL()
   $ONELINER$
      Sets the tone frequency and duration for Chr(7) or CA-Clipper's "beep"
   $SYNTAX$
      SETBELL([<nFrequency>,<nDuration>]) --> cBlank

   $ARGUMENTS$
      <nFrequency>  Designates the frequency for the bell tone in Hertz.
      Values from 21 to 65535 are possible.

      <nDuration>  Designates the duration of the bell tone in 1/100
      seconds.  Values from 1 to 65535 are possible.

      ()  Calling this function without parameters resets the function to the
      default value of 880.30 (a frequency of 880 Hertz and a duration of 0.3
      seconds).

   $RETURNS$
      This function always returns a null string.

   $DESCRIPTION$
      Previously, when you output Chr(7) or completed a GET command with SET
      BELL ON, only an unchangeable tone was produced.  With SETBELL(), the
      frequency and duration of this tone can be modified.  The frequency
      range for this tone is between 21 and 65535 Hertz.  However, the use of
      frequencies outside the audible range (above approximately 16000)
      doesn't make much sense.

      The bell tone default setting is 880 Hertz with a duration of 0.3
      seconds.  These values are reset if no parameters are passed.

   $EXAMPLES$
      ■  Select a tone of 300 Hz with 0.2 second duration:

         SETBELL(300, 20)

      ■  Reset the function to the default values:

         SETBELL()

   $PLATFORMS$
      DOS
   $SEEALSO$
      SOUND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETBOXGROW()
   $ONELINER$
      Opens boxes with a time delay
   $SYNTAX$
      SETBOXGROW(<nTimeDelay>) --> cBlank

   $ARGUMENTS$
      <nTimeDelay>  Designates the time delay in milliseconds with which
      boxes are opened in "grow" mode.

   $RETURNS$
      The function always returns a null string.

   $DESCRIPTION$
      Normally boxes are only formed with the WBox() function, the CA-Clipper
      @ ..  BOX command, or the CA-Clipper @ ..  CLEAR TO ..  [DOUBLE]
      command.  By using SETBOXGROW(), you can establish the display for empty
      boxes in a "grow" mode

      A box grows from the midpoint of the window outward when SETBOXGROW()
      has been set.  The <nTimeDelay> parameter is the time delay in
      milliseconds between the individual steps.

      But there are two exceptions to the rule on the <nTimeDelay> parameter.
      If the parameter is 0, the box is (re)opened, but not in "grow" mode.
      And if the parameter is 1, the box is opened in "grow" mode, but without
      a time delay.

   $NOTES$
      ■  The "grow" mode is only functional when a fill character has
         been specified.  If you do not specify a parameter with WBox(),  the
         default settings are used.

      ■  When you work with "snow prevent", do not specify a time delay
         for boxes.

   $EXAMPLES$
      Specify 10 milliseconds between each growth step of a box:

      SETBOXGROW(10)

      WOpen(2, 2, 23, 78)        // Nothing happens
      WBox()                     // The box is generated with
                                 // a time delay

   $PLATFORMS$
      DOS
   $SEEALSO$
      WBox(), GETBOXGROW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetCursor()
   $ONELINER$
      Sets the cursor form
   $SYNTAX$
      SetCursor([[<nCursorType>],[<lMode>]]) --> nCursor

      or:

      SetCursor([[<idCursorForm>],[<lMode>]]) --> nCursor

      or:

      SetCursor([[<nTopLine>,<nBottomLine>], [<lMode>]])
         --> nCursor

   $ARGUMENTS$
      <nCursorType>  Designates a cursor type between 0 and 4 (see Clipper
      5.0, SETCURS.CH).

      <idCursorForm>  Designates a value previously returned from this
      function.  The <nCursor> return value is a 16-bit integer.

      <nTopLine>  Designates the beginning scan line of the new cursor.

      <nBottomLine>  Designates the ending scan line of the new cursor.

      <lMode>  Designates whether the cursor is set to the overwrite (.F.)
      or the insert (.T.) mode.  The default value (.F.) designates that the
      cursor is set to the overwrite mode.

   $RETURNS$
      If the SetCursor() function is called with parameters, it returns the
      previous setting.  When the function is called without parameters, it
      returns the current cursor setting.  When a value between 0 and 4 is
      returned, then the cursor type was set through CA-Clipper's SetCursor()
      function.  When the return value is less than 0, the return value is the
      cursor value that had been set using <nTopLine> and <nBottomLine>.

   $DESCRIPTION$
      SetCursor() is also a function under CA-Clipper.   The CA-Clipper Tools
      implementation makes several extensions available over and above the
      CA-Clipper function.  When the CTUS.LIB extended driver is linked in,
      these extensions become available.

      One method for using the SetCursor() function is with only a numeric
      parameter between 0 and 4.  With this parameter, the function is
      CA-Clipper compatible.  Please refer to your CA-Clipper documentation
      for the cursor type corresponding to the individual values.

      The second method for using the SetCursor() is exclusively for restoring
      a cursor type previously saved from the return value.  A cursor saved
      using GETCURSOR() can also be implemented this way, however, use of the
      GETCURSOR() function for the creation of new applications is not
      recommended!

      The third and last method allows you to implement a cursor completely of
      your own design by specifying the start and stop pixel lines.  Specify
      the <nTopLine> and <nBottomLine>; the first parameter serves as the
      start line, and the second parameter serves as the end line for the
      cursor display.

      In all three variants of this function's syntax, you can determine the
      type of cursor you want to change, in the overwrite or the insert modes,
      by specifying <lMode>.

   $NOTES$
      ■  The range used for the <nTopLine> and <nBottomLine> parameters
         is dependent on the screen adapter used and the font installed.

      ■  To preserve complete compatibility with the former version of
         the function call without parameter, CT.CH must be linked in.

   $EXAMPLES$
      ■  In this example, the cursor for both modes is saved, and then
         restored:

         nNormCursor  :=  SetCursor(.F.)         // Overwrite mode
         nInsCursor   :=  SetCursor(.T.)         // Insert mode

         * Cursor is changed in the program

         SetCursor(nNormCursor, .F.)             // Reset cursor
         SetCursor(nInsCursor, .T.)              // Reset cursor

      ■  Here is an example of a setting using the first and last pixel
         line:

         SetCursor(10, 13)                       // Cursor as thick
                                                 // underscore

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETCURSOR()*, CharPix()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetKXLat()
   $ONELINER$
      Redefines key codes or lock keys
   $SYNTAX$
      SetKXLat([<nOrgKeyValue>],[<nNewKeyValue>])
         --> lAccepted

   $ARGUMENTS$
      <nOrgKeyValue>  Designates the original key code that is translated
      into the value of <nNewKeyValue>.

      <nNewKeyValue>  Designates a new key code for <nOrgKeyValue>.  If
      not specified, SetKXLat() turns off the key translation designated by
      <nOrgKeyValue>.

      ()  Calling this function without a parameter uninstalls all of the key
      translations previously performed.

   $RETURNS$
      SetKXLat() returns .T. when the translation code is successfully
      installed, and .F. if a parameter contains errors or additional memory
      can not be allocated.  The number of allowable key code translations can
      be calculated as follows:

      maximum allocatable memory / 4

   $DESCRIPTION$
      With this function, keyed input can be translated or even switched off.
      Symbolic constants for the codes have been defined in the CTSCAN.CH
      include file.  The following formula applies to each key:

      cKeyValue = Chr(ASCII) + Chr(SCAN_CODE)

      Many key combinations have no ASCII equivalent.  In these cases, the
      Chr(ASCII) byte is 0.  However, some key and key combinations have a
      scan code, allowing the differentiation of keys with the same ASCII code
      (e.g.  the decimal point on the numeric key pad and the period in the
      alpha numeric field).

      Scan code 0 is returned when you input an ASCII code through the numeric
      key pad in the form Alt + <number>.

      When the function is called without <cNewKeyValue>, the translations
      specified in <cOrgKeyValue> are uninstalled.

      Calling the function without any parameters discards all existing
      translations.

   $NOTES$
      ■  The numeric coding previously used for the key codes is still
         valid.

      ■  All symbolic constants from the CA-Clipper file INKEY.CH can
         be used.

      ■  A new translation for a key overwrites the previous one.

      ■  Memory for the key code translations is allocated dynamically.

   $EXAMPLES$
      ■  Press the "A" and the keyboard returns the code of "B' (in
         reality you would seldom use this):

         SetKXLat(KS_A, KS_B)                   // .T. if successful

      ■  Translate the left arrow into the down arrow on the key pad.
         Both keys then return the same code:

         ? SetKXLat(KS_LEFT, KS_DOWN)           // .T. if successful

      ■  Turn the up arrow in the cursor control block off.  Key code:

         ? SetKXLat(KS_DOWN, KS_DISABLE)        // .T. when successful

      ■  Turn the up arrow back on:

         ? SetKXLat(KS_DOWN)

      ■  Uninstall all translations:

         SetKXLat()

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetKXLat(), GetKXTab(), SetKXTab()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetKXTab()
   $ONELINER$
      Installs key tables
   $SYNTAX$
      SetKXTab(<idKeyTable>) --> lInstalled

   $ARGUMENTS$
      <idKeyTable>  Designates a character string that contains the key
      definitions as described below.

   $RETURNS$
      The function returns .T. when the key table is successfully installed.

   $DESCRIPTION$
      With SetKXLat() code translations can only be defined for individual
      keys.   In contrast, with SetKXTab() an entire table can be implemented.
      SetKXLat() is primarily for use in the restoration of a key table that
      has been saved with GetKXTab().  Four bytes are needed to translate a
      single key; two bytes are needed for the scan code for the original key;
      and two bytes are needed for the scan code for the key that is
      simulated.  The construction of the table progresses in the following
      form:

      cByte1  := Chr(ASC1)            // Key to be translated
      cByte2  := Chr(ASC2)            // Key to be translated
      cByte3  := Chr(ASC1)            // Key to be simulated
      cByte4  := Chr(ASC2)            // Key to be simulated

      cTable := cByte1 + cByte2 + cByte3 + cByte4

      with symbolic constants:

      cTable := KS_A + KS_B           // Translate "A" to "B"

      The symbolic constants for key codes can be found in the CTSCAN.CH
      include file.

   $NOTES$
      ■  The installation of a new key table overwrites the existing
         table.

   $EXAMPLES$
      Save the existing key table and reset it later:

      cKXTab := GetKXTab()
      DO KEYCHANGE
      SetKXTab(cKXTab)

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetKXTab(), SetKXLat(), GetKXLat()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETLINES()
   $ONELINER$
      Determines the number of lines after which the screen display pauses
   $SYNTAX$
      SETLINES(<nLines>) --> cNullString

   $ARGUMENTS$
      <nLines>  Designates the number of lines after which the screen
      display pauses.

   $RETURNS$
      The function always returns a null string.

   $DESCRIPTION$
      SETLINES() allows you to simulate a DOS MORE command for commands like
      LIST or DISPLAY.  To properly function, one input command must always be
      present in the related instruction (see example).

   $NOTES$
      ■  Only line feeds are counted.

      ■  If you use values less than or equal to 0 for <nNrLines>, the
         screen display does not pause.

   $EXAMPLES$
      In this example, the screen output stops after 20 lines.  Inkey() allows
      you to continuously query the keyboard, while the Nul() suppresses the
      return value for Inkey().

      USE DATA
      SETLINES(20)                  // Stop after 20 lines
      LIST Field1, Field2, Nul(Inkey())

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETMAXCOL()
   $ONELINER$
      Sets the number of columns for a virtual screen
   $SYNTAX$
      SETMAXCOL(<nLastColumn>, [<nScrollBorder>])
         --> lSuccessful

   $ARGUMENTS$
      <nLastColumn>  Designates the rightmost column that the extended
      driver supports for screen output.  The highest value possible is 253,
      assuming sufficient screen memory is available.  Only odd numbers of
      columns are permitted because the value is 0-based.

      <nScrollBorder>  Designates the left and right column borders that
      move the screen when crossed by the cursor.  Values from 0 to
      MaxCol(.T.)/2 are valid.  Larger values are corrected to the maximum
      value.  When a value is passed for this parameter, scroll is turned on.
      When no parameter is passed, scroll is off.

   $RETURNS$
      SETMAXCOL() returns .T. when <nLastColumn> is successfully set.

   $DESCRIPTION$
      This function allows you to set the number of columns that the extended
      driver accepts for CA-Clipper screen output.  Two different types of
      screen output can be determined:

      Special Screen
      It is possible to use full page screens or other special screens that
      display more than 80 columns, and whose column count is not
      automatically recognized by the BIOS (this is always hardware based).
      These screens must be compatible with the usual screen adapter with
      regard to the organization of the screen memory (character attributes),
      the attribute bytes themselves, and the basic address of the screen
      memory.  The function doesn't switch any modes; the internal settings of
      the extended drivers are simply adjusted.  Specific screen settings must
      be carried out through the hardware's driver module.

      Virtual Screen
      It is also possible to set a column count higher than what can be
      displayed on the screen.  In this case there is only a portion of the
      total screen memory visible.  If a CA-Clipper input command (such as
      GET/READ) is built larger than the visible area, the extended driver
      automatically moves screen memory in accordance with cursor movement.
      This movement always occurs when the cursor moves beyond the left or the
      right borders set in <nScrollBorder>.  In this way, the portion of text
      that is worked on is always visible.  The visible area of the virtual
      screen can also be set using the FIRSTCOL() function if needed.

      Virtual screens are possible on CGA, EGA, and VGA adapters as well as
      those that can fully emulate them.  The maximum number of columns you
      can install, assuming a 25-line and 80-column mode (CGA80() or
      MONOCHROME()), can be determined in the following manner:

      nColumns   := (MAXPAGE() +1) * 2048 / 25
      nMaxColumn   := Min(INT(nColumn /2) * 2, 253)

      With eight screen pages you will have a value of >255.  In other words a
      maximum of 254 columns can be used, which exactly equals the maximum
      value for SETMAXCOL() of 253.  To switch back to the number of actually
      displayed columns, call the function with the corresponding value and no
      border.

   $NOTES$
      ■  We are not able to provide any kind of technical support when
         unknown screen hardware is used.  Full page screens do exist on the
         market which fulfill the conditions described above.

      ■  Changing the number of columns breaks down the existing screen
         contents and renders it unusable.  This switch should always be
         linked to a CLEAR.

      ■  Virtual screens use the memory area for additional screen
         pages.  The number of screen pages decreases in proportion to the
         growth of the virtual screen.

      ■  If the <nScrollBorder> is larger than or equal to half of the
         visible columns, then the display in the middle of the screen is
         scrolled under the cursor.

      ■  If the cursor is switched off, the automatic scroll depends
         only on keyboard input.

      ■  When windows are open, the column count cannot be changed,
         regardless of the automatic scroll setting.

   $EXAMPLES$
      ■  Set the number of columns to 96 (special screen):

         SETMAXCOL(95)           // 96 columns
         @ 10, 80 SAY "CA-Clipper"

      ■  Switch a VGA adapter already in 50-line mode (VGA50()) to a
         virtual 100-column mode with a border of 3 characters:

         CLEAR                   // Best to have the screen clear
         ? SETMAXCOL(99, 3)      // Returns .T. if successful

      ■  Switch off the automatic scroll:

         SETMAXCOL(MaxCol(.T.))

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETMAXROW(), FIRSTCOL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETMAXROW()
   $ONELINER$
      Sets the number of lines for a virtual screen
   $SYNTAX$
      SETMAXROW(<nLastLine>, [<nScrollBorder>])
         --> lSuccessful

   $ARGUMENTS$
      <nLastLine>  Designates the last line that the extended driver
      supports for screen output.  The highest value possible is 254, assuming
      sufficient screen memory is available.

      <nScrollBorder>  Designates the top and bottom borders that move the
      screen when crossed by the cursor.  Values from 0 to MaxCol(.T.)/2 are
      valid.  Larger values are corrected to the maximum value.  When a value
      is passed for this parameter, scroll is turned on.   When no parameter
      is passed, scroll is turned off.

   $RETURNS$
      SETMAXROW() returns .T. when <nLastLine> is successfully set.

   $DESCRIPTION$
      This function allows you to set the number of lines that the extended
      driver accepts for CA-Clipper screen output.  You can determine two
      different types of screen output.

      Special Screen
      It is possible to use full page screens or other special screens that
      display more than 25 lines, and whose line count is not automatically
      recognized by the BIOS (this is always hardware based).  These screens
      must be compatible with the usual screen adapter with regard to the
      organization of the screen memory (character attributes), the attribute
      bytes themselves, and the basic address of the screen memory.  The
      function doesn't switch any modes; the internal settings of the extended
      drivers are simply adjusted.  Specific screen settings must be carried
      out through the hardware's driver module.

      Virtual Screen
      It is also possible to set a line count higher than what can be
      displayed on the screen.  In this case, only a portion of the total
      screen memory is visible.  If a CA-Clipper input command such as
      GET/READ is built larger than the visible area, the extended driver
      automatically moves screen memory in accordance with cursor movement.
      This movement always occurs when the cursor moves beyond the left or the
      right borders set in <nScrollBorder>.  In this way, the portion of text
      that is worked on is always visible.  The visible area of the virtual
      screen can also be set using the FIRSTROW() function if needed.

      Virtual screens are possible on CGA, EGA, and VGA adapters as well as
      those that can fully emulate them.  The maximum number of lines you can
      install, assuming a 25-line and 80-column mode (CGA80() or
      MONOCHROME()), can be determined in the following manner:

      Min(INT((MAXPAGE() +1) * 2048 / 80), 254)

      With eight screen pages you have:

      Min(INT(8 * 2048 / 80), 254)   204

      In other words, a maximum of 204 lines can be used, which exactly equals
      the maximum value for SETMAXROW() of 203.

      You can switch back to the number of lines that actually display by
      calling the function with the corresponding value and no border.

   $NOTES$
      ■  We are not able to provide any kind of technical support when
         unknown screen hardware is used.  Full page screens do exist on the
         market which fulfill the conditions described above.

      ■  Please notice that virtual screens use the memory area for
         additional screen pages.  The number of screen pages decreases in
         proportion to the growth of the virtual screen.

      ■  If the <nScrollBorder> is larger than or equal to half of the
         visible columns, then the display in the middle of the screen is
         scrolled under the cursor.

      ■  If the cursor is switched off, the automatic scroll depends
         only on keyboard input.

      ■  When windows are open, the line count cannot be changed,
         regardless of the automatic scroll setting.

   $EXAMPLES$
      ■  Set the number of lines to 72 (full page screen):

         SETMAXROW(71)                 // 72 lines
         @ 65, 20 SAY "CA-Clipper"

      ■  Switch a VGA adapter to a 100-line screen.  As soon as the
         cursor is in the region of the top or bottom tow lines, the screen
         moves:

         ? SETMAXROW(99, 2)            // Returns .T. if successful

      ■  Switch off the automatic scroll:

         SETMAXROW(MaxRow(.T.))

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETMAXCOL(), FIRSTROW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETPAGE()
   $ONELINER$
      Selects a new screen page
   $SYNTAX$
      SETPAGE(<nScreenPage>,[<lHidden>]) --> lSwitched

   $ARGUMENTS$
      <nScreenPage>  Designates the screen page number to select.  The
      value can be as high as you like, depending on the screen card, its
      mode, and available memory.  The first page is 0.

      <lHidden>  Designates whether or not output is displayed.  If this
      parameter is .T., the output is in the page selected, but is not
      displayed.  If this parameter is .F., the output is displayed.  The
      default value is .F..

   $RETURNS$
      SETPAGE() returns .T. when it is possible to physically or virtually
      select the screen page.

   $DESCRIPTION$
      SETPAGE() allows you to switch to another screen page on the video
      adapter that you use.  If the <lHidden> parameter is not passed (or is
      designated as .F.), the output, and therefore the selected page, is
      visible.  By contrast, if <lHidden> is .T., the output is sent to the
      new page, but the page that was visible when you invoked SETPAGE()
      remains visible.  It is therefore possible to construct hidden screens.

   $NOTES$
      Important!  This function cannot be implemented when windows are
      open.

      ■  Virtual screen output cannot be achieved using a string output
         (i.e. SETSCRSTR()).  Use SETSCRSTR() when there is only one page
         available on the screen adapter.

   $EXAMPLES$
      ■  Select two pages with the output immediately visible.  The
         output with the returned value is on the new page:

         ? SETPAGE(1)            // .T., if OK

      ■  Hide the output:

         SETPAGE(0)              // Displayed
         SETPAGE(1, .T.)         // Output here

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETPAGE(), MAXPAGE(), PAGECOPY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETPBIOS()
   $ONELINER$
      Redirects print output to the BIOS or DOS, and establishes the timeout
   $SYNTAX$
      SETPBIOS(<nPrinter>,[<nRefreshRate>]) --> lBIOSPrint

   $ARGUMENTS$
      <nPrinter>  Designates whether the printer output is through DOS (0)
      or BIOS on printer 1, 2, or 3.

      <nRepeatRate>  Designates how frequently an output attempt is made
      from extended drivers if the printer is not ready.  The default value is
      1000 attempts.

   $RETURNS$
      The function returns .T. when the selected output setting is
      successfully established.

   $DESCRIPTION$
      The default setting for CA-Clipper's printer output is through DOS.
      SETPBIOS() configures the extended driver in such a way that all
      subsequent printer output is directed through the BIOS.  This
      configuration gives you certain advantages.  You can determine the
      timeout for printers that are not ready.  Using <nRepeatRate>, you
      determine how frequently the output should be attempted before the
      program falls into an error trap.  Printer output on local printers is
      usually quicker, at least as long as the printer is able to accept the
      files quickly enough (hardware spoiler, built in printer buffer memory).

      For BIOS output, you must always designate the selected printer with the
      <nPrinter> parameter.  This setting then has absolute priority over any
      previously setting using the CA-Clipper SET PRINTER TO command.

   $NOTES$
      ■  If you use the SET PRINTER TO command, the extended drivers
         ignore the SETPBIOS() setting.

      ■  The extended driver can test to see if the printer is busy or
         not, before the output of a single character, but only when the
         extended driver outputs with BIOS.  In this case, the extended driver
         waits until the printer can once again receive files.

      ■  BIOS output functions in all systems that have an interrupt
         17h that is compatible with the IBM BIOS.

      ■  BIOS output successfully operates in those networks that
         reroute the corresponding interrupt 17h.

   $EXAMPLES$
      ■  Specify printer output through BIOS to LPT2, independently of
         the CA-Clipper SET PRINTER TO setting:

         SET PRINTER TO LPT1
         ? SETPBIOS(2)                  // .T. if OK

      ■  This is the same setting with a shortened timeout:

         SETPBIOS(2, 100)               // 100 repetitions

      ■  Reset the print output to DOS:

         ? SETPBIOS(0)                  // .F. when via DOS

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETPBIOS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETPXLAT()
   $ONELINER$
      Establishes translation tables for printer output
   $SYNTAX$
      SETPXLAT([<nASCIIPos|cCharacter>,
         <cPrintCharacter>]) --> lActiveTable

   $ARGUMENTS$
      <nASCIIPos|cCharacter>  Designates the position or the character in
      the key table that is overwritten by the <cPrintCharacter>.  This
      parameter can be designated as a numeric value, between 0 and 255, or as
      an individual character.

      <cPrintCharacter>  Designates the sequence of characters that are
      copied into the key table, starting from the <nASCIIPos> position.

      ()  By invoking the function with no parameters, the existing key table
      is cleared.

   $RETURNS$
      SETPXLAT() returns .T. when the key table is active.

   $DESCRIPTION$
      CA-Clipper normally passes all characters between 0 and 255 to the
      printer, without changing any of the characters.  This always leads to
      problems when the printer is set up with a different font style.  For
      example, a 7 bit printer, which looks for things like German umlauts,
      can cause problems with the IBM extended character set.  Output through
      a key table that you can build yourself is more flexible than a special
      drive module for different printers.

      Imagine the key table as a memory area of 256 bytes.  Memory position 65
      normally contains the character Chr(65).  Using SETPXLAT() you could
      exchange this character for Chr(66).  Thus an "A" sent to the printer no
      longer produces an "A", but a "B".  There are also other ways to
      substitute characters from a particular position.

   $NOTES$
      ■  The key table is only created at the moment that an exchange
         under SETPXLAT() is requested.  Therefore, memory is not used up
         unnecessarily.

   $EXAMPLES$
      ■  Here is the solution for multiple calls of SETPXLAT():

         SETPXLAT(65, Chr(66))            //  B

      ■  You can also call the function as follows:

         SETPXLAT("1", "AB")              // 12  AB

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETPXLAT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETQNAME()
   $ONELINER$
      Changes the file and path name for the QUIT file
   $SYNTAX$
      SETQNAME([<cFileSpecification>]) --> lAmended

   $ARGUMENTS$
      <cFileSpecification>  Designates the new file name for the QUIT file
      which can include a path and file extension.  The default name for this
      file is the name of the active .EXE file with a .Q extension.

   $RETURNS$
      SETQNAME() returns .T. when the new name and path are successfully set.

   $DESCRIPTION$
      The DSETQFILE() function allows you to create a QUIT file when a
      CA-Clipper application returns to DOS.  The default name for this file
      is the name of the .EXE file with a .Q extension.  Unless otherwise
      specified, the QUIT file is saved in the directory from which the
      application was started.

      Using SETQNAME() you can designate an alternate name and a completely
      different path for saving the QUIT file.

   $NOTES$
      ■  Calling this function without parameters returns .F., the
         default value.  The QUIT file name is reset to the default name.

   $EXAMPLES$
      Change the name for the QUIT file:

      SETQNAME("C:\LOGS\PROTO.LOG")
      DSETQFILE(.T.)               // Alternative name for QUIT file

   $PLATFORMS$
      DOS
   $SEEALSO$
      DSETQFILE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETSCRMODE()
   $ONELINER$
      Establishes a new video mode
   $SYNTAX$
      SETSCRMODE(<nModeNumber>) --> lStatus

   $ARGUMENTS$
      <nModeNumber>  Designates the number of the selected mode that
      corresponds to the designation in the table below.

   $RETURNS$
      The function returns .T. when the selected mode is installed.

   $DESCRIPTION$
      SETSCRMODE() supports every video mode that the current screen adapter
      supports.  However, non standard mode settings under the CA-Clipper and
      CA-Clipper Tools combination are not a good idea.  For example, this
      applies to all graphic modes where CA-Clipper or CA-Clipper Tools cannot
      work.  The following modes are anticipated within the CA-Clipper Tools:

      Table 2-4: Modes and Their Coding
      <table>
          Mode                Mode Number

          CGA40 Monochrome    0
          CGA40 Color         1
          CGA80 Monochrome    2
          CGA80 Color         3
          Monochrome          7
          EGA43 (EGA only)    299 (43+256)
          VGA28 (VGA only)    284 (28+256)
          VGA50 (VGA only)    306 (50+256)
         </table>

   $NOTES$
      Important!  We cannot guarantee that you won't have problems if you
      use any special mode and screen adapter together with Clipper and
      CA-Clipper Tools.

      ■  This function cannot be implemented when windows are open.

   $EXAMPLES$
      ■  Implement the EGA43-line mode:

         EGA43()

      ■  Save the current screen mode:

         nOldMode := GETSCRMODE()

      ■  Reinstall the current screen mode later:

         SETSCRMODE(nOldMode)

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETSCRMODE(), GETMODE(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETTAB()
   $ONELINER$
      Sets the tab widths for CA-Clipper screen outputs
   $SYNTAX$
      SETTAB([<cTabTable>|<nTabWidth>]) --> lAccepted

   $ARGUMENTS$
      <cTabTable>  Designates a character string with tab definitions in a
      format as defined below.  Can be a maximum of 32 characters long.

      or:

      <nTabWidth>  Designates (as an exception) an individual numeric
      value for the tab value.  A blank is then used for the tab setting.

      ()  If you call the function without parameters, the tab settings from
      the CA-Clipper console output are uninstalled.

   $RETURNS$
      SETTAB() returns .T. when the character string that contains the tab
      settings is installed successfully.

   $DESCRIPTION$
      Using this function, you can switch to a mode in which CA-Clipper
      console output (with the exception of @..SAY) can interpret tab
      characters.  This function allows tabs to be blanks or any other
      character you choose.  The tab positions and the character used for each
      tab jump are passed in a character string with the following format:

      Chr(tab-pos) + Chr(character) + Chr(tab-pos) + Chr(character)...

      You do not need to specify every tab position within a line.  Any tab
      position that is not specified is worked out as follows:

      <previous Tab Pos.> + <previous Tab Pos.>

      For example, if the first position is 0, the second is 8, and no other
      positions are specified, then the tab positions are 16, 24, 32 etc.

      When you call the function with <nTabWidth>, only one tab width can be
      specified.  All positions are calculated as multiples of this value.  A
      space is used as the tab character.

   $NOTES$
      ■  A tab position within a string can never be less than one
         previously designated.  The function returns .F., indicating an
         error.

      ■  If the difference between the last and the next to last tab
         positions is 0, or if the last position specified is 0, then
         additional tabs on this line are not taken into account.

      ■  The tabs are exclusively for screen output, not for printer or
         ALTERNATE files.

   $EXAMPLES$
      ■  Set tabs that expand to spaces with a tab width of 8:

         SETTAB(8)

      ■  Set tabs for positions 8, 16, 24, etc.  Use a "." as the tab
         character:

         cTab := Chr(9)
         cTabString := Chr(8) + "." + Chr(16) + "."
         SETTAB(cTabString)

         ? "AAAA" + cTab + "BBB" + cTab + "CCCCCC" + cTab + "DDD"


         * The resulting output: AAAA. . . .BBB. . . . .CCCCCC. .DDD

      ■  Format the output in conjunction with LIST:

         USE <file>
         LIST OFF cTab + FIELD1 + cTab + FIELD2 + cTab + FIELD3

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETTAB(), TabExpand()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TRAPANYKEY()
   $ONELINER$
      Calls a procedure with any keyboard input
   $SYNTAX$
      TRAPANYKEY(<cProcedure>) --> cOldProcedure

   $ARGUMENTS$
      <cProcedure>  Designates the name of the procedure that is called
      when any input key is touched.

      ()  If you call the function without parameters, the procedure to
      monitor selected keyboard input is uninstalled.

   $RETURNS$
      At any given time, the function returns the name of the previously
      active trap procedure.  If no call has ever been made to TRAPANYKEY(),
      the function returns a null string.

   $DESCRIPTION$
      TRAPANYKEY() calls a given procedure for all keys that generate input.
      This is somewhat similar to SET KEY <AnyKey> TO <cProcName>.

      The scan code transmitted by the key is passed as a parameter to the
      trap procedure, but it is not yet stored in the keyboard buffer.  To
      input normally, each character must be sent to the keyboard buffer using
      either the KEYBOARD command, or the KEYSEND() function.  Using KEYSEND()
      is generally preferred because the previous keyboard buffer is always
      added to the characters that have not yet been amended by the CA-Clipper
      application -- therefore you do not lose input.

      The Procedure Call
      When you use this function, you do not call any CA-Clipper key trap.
      When CA-Clipper tries to collect a keyboard input, this call is
      redirected within the driver by the TRAPANYKEY() procedure.  CA-Clipper
      checks the keyboard, with the exception of special input commands like
      GET/READ, so these traps almost always work.

      Important!  In contrast to CA-Clipper key traps, these internal
      input commands do not have the option to ignore the interruption because
      no internal input routine is reentrant.  You cannot, under any
      circumstances, use the same input command in the called procedure.  This
      applies the GET/READ, PROMPT, ACCEPT, and any similar input
      instructions.  You can easily use INPUTMODE(.T.) to determine which
      input command is currently active when you call a procedure.

   $NOTES$
      ■  The transmitted key codes must continue to be processed within
         the trap procedure.  Otherwise no additional input is possible, and
         you cannot even exit the program using Alt-C.

      ■  In contrast to CA-Clipper KEY TRAPS, recursions are
         automatically avoided.

      ■  If the designated procedure does not exist, then the function
         uninstalls itself and does not produce a runtime error.  If a warning
         regarding a missing procedure is required during linking, use the
         EXTERNAL <procedure> statement.

   $EXAMPLES$
      In this example, two established abbreviations are input within
      MemoEdit(), and then the accompanying phrases are expanded into the
      text.  The trap procedure recognizes the last three keys that were input
      and compares this sequence with the defined abbreviations.  In each
      case, these phrases are sent using KEYSEND() and inserted in the
      existing keyboard buffer.  Since the functions are called with .T. for
      the second parameter, no characters are lost even if you type quickly.

      At this time, the third character of the recognized abbreviation has not
      yet been placed in the keyboard buffer and therefore does not yet exist
      in text, so only two Chr(8) (backspace) characters are used to delete
      the two characters that have already been transmitted.  The entire
      sequence must be expanded with Chr(0) before it can be placed in the
      keyboard buffer because KEYSEND() works on the basis of scan codes.

      Notice the SET TYPEAHEAD enlarged keyboard buffer.

      CLEAR

      cLastThree := ""
      SET TYPEAHEAD TO 50

      TRAPANYKEY("Trap_Key")

      cTextVar := Space(5000)
      @@ 00, 00 TO MaxRow(), MaxCol(), DOUBLE
      cTextVar := MemoEdit(cTextVar, 1, 1, MaxRow() -1,    MaxCol() -1)

      TRAPANYKEY()

      RETURN

      PROCEDURE Trap_Key(nKey)

         cLastThree := Right(cLastThree, 2) + Chr(nKey)

         DO CASE
         CASE cLastThree == "ys"
            cLine := Chr(8) + "Yours Sincerely"
            KEYSEND(CharMix(cLine, Chr(0)), .T.)
         CASE cLastThree == "yvt"
            cLine := Chr(8) + "Yours Very Truly"
            KEYSEND(CharMix(cLine, Chr(0)), .T.)
         OTHERWISE
            KEYSEND(I2Bin(nKey), .T.)
         ENDCASE

         RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      TRAPSHIFT(), INPUTMODE(), KEYSEND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TRAPINPUT()
   $ONELINER$
      Allows supervision of CA-Clipper input commands
   $SYNTAX$
      TRAPINPUT(<cProcedure>,[<lParameter>]) --> cOldProcedure

   $ARGUMENTS$
      <cProcedure>  Designates the name of the procedure that is called
      during active CA-Clipper input commands.

      <lParameter>  Designates whether a parameter is passed internally to
      the specified trap procedure.  If this logical parameter is .T., then no
      parameter is passed internally to the specified trap procedure.  This
      allows you to significantly improve performance.

      ()  If this function is called without a parameter, the previously set
      trap is uninstalled.

   $RETURNS$
      This function returns the name of the previously set trap procedure.  If
      no trap was set, TRAPINPUT() returns a null string.

   $DESCRIPTION$
      This function is different from a CA-Clipper key trap.  When one of the
      CA-Clipper input commands is active, the specified trap procedure is
      always called when CA-Clipper attempts to retrieve the keyboard input.
      This function is completely independent of whether or not there really
      has been a keyboard input.  Additionally, the ensuing inputs are not
      influenced in any way, but are passed to the CA-Clipper command
      unchanged.

      The Procedure Call
      Three parameters are transmitted by the called procedure, as with
      CA-Clipper trap procedures.  These parameters are the procedure name,
      the line number, and the variable name.  All three parameters are
      transmitted unless the <lParameter> option is .T.

      Important!  In contrast to CA-Clipper key traps, these internal
      input commands do not have the option to ignore the interruption because
      no internal input routine is reentrant.  You cannot, under any
      circumstances, use the same input command in the called procedure.  This
      applies the GET/READ, PROMPT, ACCEPT, and any similar input
      instructions.  You can easily use INPUTMODE(.T.) to determine which
      input command is currently active when you call a procedure.

   $NOTES$
      ■  In contrast to CA-Clipper SET KEY TO traps, recursions are
         automatically avoided.

      ■  If the designated procedure does not exist, then the function
         uninstalls itself and does not produce a runtime error.  If a warning
         regarding a missing procedure is required during linking, use the
         EXTERNAL <procedure> statement.

   $EXAMPLES$
      The following example shows a MemoEdit() extension to a very simple
      communications program.  This is only intended to demonstrate a possible
      application.  This solution is unsuitable for a full fledged
      communications program because at some point the memory available to
      MemoEdit() would be insufficient.

      The main purpose of the example is to show how using TRAPINPUT() can
      convert characters from the serial port into keyboard input for a
      CA-Clipper application.  Each time the CA-Clipper program looks for
      keyboard input, the characters in the serial port input buffer are added
      to the available keyboard buffer.  Please notice that the example uses
      KEYSEND().

      To complete this example, all local keyboard input is transmitted
      through the TRAPANYKEY() procedure over the serial port.  The other
      terminal is expecting an echo of these characters.  Alt-C remains
      functional in this example.  The application can also be changed to take
      into account other control keys.

      CLEAR

      nPort := 1

      com_Open(nPort, 1000)
      CON_DTR(2, .T.)
      com_Init(nPort, 1200, "N", 8 , 1)

      TRAPINPUT("Trap1")
      TRAPINPUT("Trap2")


      cTextVar := Space(5000)
      cTextVar := MemoEdit(cTextVar)

      com_Close(nPort)

      RETURN

      PROCEDURE Trap1(a, b, c)

         IF com_Count(nPort) > 0
            KEYSEND(CharMix(com_Read(nPort), Chr(0), .T.)
         ENDIF

         RETURN

      PROCEDURE Trap2(nKey)

         IF nKey <= 255
            com_Send(nPort, Chr(nKey))
         ELSE
            KEYSEND(I2Bin(nKey), .T.)
         ENDIF

         RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      TRAPANYKEY(), TRAPSHIFT(), INPUTMODE(), KEYSEND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TRAPSHIFT()
   $ONELINER$
      Calls a procedure that depends on switching keys
   $SYNTAX$
      TRAPSHIFT(<cProcedure>, <nBitMap>) --> cOldProcedure

   $ARGUMENTS$
      <cProcedure>  Designates the procedure name that is called when the
      specified shift keys are selected.

      <nBitMap>  Designates the bit values that allow you to specify which
      of the shift keys should call the procedure.  The description section
      below has a table of valid values.

      ()  If you call the function without parameters, you uninstall a
      previously selected function that monitored the switching keys.

   $RETURNS$
      The function returns the name of the previously set trap procedure.  If
      no trap was set, TRAPINPUT() returns a null string.

   $DESCRIPTION$
      This function makes it possible for all the shift keys, like Shift,
      Ctrl, Alt, Num-Lock etc., to trigger a procedure call.  If the system
      has the European extended (MF-2) keyboard available, which can be
      determined by using the KBDTYPE() function, then additional differences
      like left and right Ctrl keys must be taken into account.  The key scan
      codes and their assigned bits must be added to determine the value for
      the <nBitMap> parameter.  The following code applies:

      Table 2-5: Coding the Switching Keys
      <table>
          Bit     Key

          1       Right shift at the instant actuated
          2       Left shift at the instant actuated
          3       Ctrl at the instant actuated (left or right)
          4       Alt at the instant actuated (Alt - Shift/Alt)
          5       Scroll-Lock ON/OFF
          6       Num-Lock ON/OFF
          7       Caps-Lock ON/OFF
          8       Insert ON/OFF
          9       Ctrl left at the instant actuated
          10      Alt left at the instant actuated
          11      Ctrl right at the instant actuated
          12      Right Alt (not valid for US keyboards)
          13      Scroll Lock at the instant actuated
          14      Num-Lock at the instant actuated
          15      Caps-Lock at the instant actuated
          16      Alt Print Scrn at the instant actuated
         </table>

      The Procedure Call
      If the selected switching key or keys are actuated, then the specified
      procedure is called.  The call is always passed as a numeric parameter
      and the status of all the switching keys at the time of the call.  The
      coding of the passed value corresponds to the table above.

      Using this function will not reproduce any CA-Clipper key trap.  Each
      time that CA-Clipper queries the keyboard, the switching keys are
      checked, and if required, the procedure is called directly from the
      driver.  In this way, these traps are always functional.

      Important!  In contrast to CA-Clipper key traps, these internal
      input commands do not have the option to ignore the interruption because
      no internal input routine is reentrant.  You cannot, under any
      circumstances, use the same input command in the called procedure.  This
      applies the GET/READ, PROMPT, ACCEPT, and any similar input
      instructions.  You can easily use INPUTMODE(.T.) to determine which
      input command is currently active when you call a procedure.

   $NOTES$
      ■  In contrast to CA-Clipper KEY TRAPS, recursions are
         automatically avoided.

      ■  The parameter passed to the trap must be passed in every case,
         even when it is not needed.

      ■  If a designated procedure does not exist, then the function
         uninstalls itself and does not produce a runtime error.  If a warning
         regarding a missing procedure is required during linking, use the
         EXTERNAL <procedure> statement.

   $EXAMPLES$
      In this example, the Trap_Alt procedure is called as soon as the Alt key
      is actuated.  It is not in any way necessary for a GET/READ mask to be
      active for this example.   This is only intended to be an example of an
      application.

      The trap procedure waits in a loop for as long as you hold the Alt key,
      or until an additional combination key that delivers an INKEY code is
      actuated.  Pressing the Alt key displays an additional help list from
      which you can select the program option.  In this case, Alt-M appends
      the text "Yours Sincerely" to the keyboard buffer.

      CLEAR

      TRAPSHIFT("Trap_ALT", 8)

      cVar1 := Space(50)
      cVar2 := Space(50)

      @ 10, 20 GET cVar1
      @ 11, 20 GET cVar2
      READ

      TRAPSHIFT()

      RETURN

      PROCEDURE Trap_ALT(nStatus)

         @ MaxRow(), 0 SAY "........Help Line........"

         nInVar := 0

         DO WHILE NumAnd(KbdStat(), 8) = 8 .AND. nInVar = 8
            nInVar := Inkey()
         ENDDO

         DO CASE
         CASE nInVar = 306                  // ALT-M
            KEYSEND(CharMix("Yours Sincerely", Chr(0), .T.)
         ENDCASE

         @ MaxRow(), 0

         RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      TRAPANYKEY(), INPUTMODE(), KBDTYPE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      VGA28()
   $ONELINER$
      Switches to 28-line VGA mode
   $SYNTAX$
      VGA28() --> lStatus

   $RETURNS$
      VGA28() returns .T. when the screen adapter that you use (VGA only)
      successfully switches to this mode.

   $DESCRIPTION$
      In order to generate a pixel height of 14, like that of EGA (for
      instance, to use the accompanying font editor on a VGA adapter), this
      mode must be implemented.

   $NOTES$
      Important!  This function cannot be used when windows are open.

   $EXAMPLES$
      Switch to 28-line mode:

      IF IsVGA()
         VGA28()
      ENDIF

      @ 27, 00 SAY Center("CA-Clipper")       // Last screen line

      WAIT

      CGA80()                                 // Return to 25 line
                                              // mode

   $PLATFORMS$
      DOS
   $SEEALSO$
      CGA80(), VGA50(), EGA43(), SETSCRMODE(), GETMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      VGA50()
   $ONELINER$
      Switches to 50-line VGA mode.
   $SYNTAX$
      VGA50() --> lSwitched

   $RETURNS$
      VGA50() returns .T. when the screen adapter that you use successfully
      switches to this mode.

   $DESCRIPTION$
      This function can only be used on a VGA card.  It generates a 50-line
      mode, which automatically increases CA-Clipper screen output to the
      maximum allowable coordinates.  It is therefore not necessary to also
      call the SETMAXROW() and SETMAXCOL() functions.

   $NOTES$
      Important!  This function cannot be used when windows are open.

   $EXAMPLES$
      Switch to 50-line mode.  You can then output from line 0 to 49:

      IF IsVGA()
         VGA50()                      // Switch mode
      ENDIF

      @ 49, 10 SAY "CA-Clipper"       // Last line

      WAIT

      CGA80()                         // Return to 25 line mode

   $PLATFORMS$
      DOS
   $SEEALSO$
      CGA40(), CGA80(), EGA43(), MONOCHROME(), SETSCRMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Serial Communication
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      There are a number of ways that the serial port can be used.  Modems,
      bar code readers, and many other devices deliver data over this port or
      are regulated by it.  Although standards do exist, in the final
      analysis, the type of communication is different every time.

      The functions in this chapter offer possibilities for data transmission
      and allow you to influence control signals.  These functions do not
      support any particular protocol or any specific instrument.  For a few
      expanded applications, like the XMODEM protocol, you should find
      sufficient information in the example programs for CA-Clipper Tools.

      b>Port Parameters</b>

      All the parameters for the port, like baud rate, parity, file length,
      and stop bits, are fully adjustable.  It is possible to change the
      settings for a port without closing it.  In this way the transmission
      speed can be changed without losing the contents of the buffer or
      terminating an existing connection (DTR-signal).

      b>Data Transmission</b>

      Using CA-Clipper Tools, you can use up to four serial ports
      simultaneously.  You can create a sending and a receiving buffer of up
      to 64kB in size.  The characters for the background transmission mode
      are placed in the sending buffer, while characters received through the
      port are stored using an interrupt handler.  You can determine the
      number of characters in the receive buffer from your CA-Clipper program,
      and as many of the available characters as you like can be read.
      Additional special control functions exist for the sending buffer that
      give the governing program full control.  It is also possible to engage
      a software or hardware handshake that is performed completely in the
      background.

      b>Handshake</b>

      As previously mentioned, CA-Clipper Tools functions support both a
      hardware and software handshake.  As soon as the receiving buffer
      threatens to overflow by at least one page, a special handshake
      character is transmitted that tells the other side that no further data
      should be transmitted.  Whether you implement the hardware or software
      handshake depends upon the type of data transmission.  Hardware
      handshakes use physical port controls.  These port controls are usually
      RTS and CTS, so within the scope of CA-Clipper Tools functions, these
      control ports cannot be used for modem transmission.  Modems are
      generally not able to reproduce port controls directly over the
      transmission route (i.e.  telephone connection).  A software handshake
      must be implemented in such cases.

      A software handshake uses characters from the ASCII character set to
      control the data flow.  The ASCII character set is a standard which
      defines the XOFF (stop data, transmission off) as Chr(19) and the XON
      (continue transmission, transmission on) as Chr(17).  (You will
      recognize the similarity to your keyboard since Chr(19) corresponds to
      Ctrl-S, and Chr(17) corresponds to Ctrl-Q).

      If one of the handshake processes is implemented, the software must test
      both sides to see if the receiving buffer has been filled.  The software
      then either deactivates the CTS controls or sends an XOFF character.  By
      contrast, when sending data you must constantly test to see if the RTS
      input from the remote station has been deactivated or if an XOFF
      character has been received.  In both cases transmission must stop
      immediately.

      Since you can never be sure if the remote stations stop immediately
      after receiving an XOFF character, the internal handshake becomes active
      when the buffer is 75% full.  If the remote stations ignore the
      handshake, the 75% limit is probably insufficient at a set buffer size
      of 100 byte (which equals a 25 byte reserve).

      The techniques described here for the handshake are managed completely
      by the CA-Clipper Tools routines.  They do not concern themselves with
      the interface cards or the Universal Asynchronous Receiver Transmitters
      (UARTS).  It is sufficient to activate the selected method, which allows
      your program to regulate the status of the sending and receiving buffers
      on an ongoing basis.

      b>Protocols</b>

      As previously mentioned, remote data transmission is, as a rule,
      implemented only through a software handshake.  A significant
      disadvantage to this method is that the characters used for flow
      control, CHR (19) and Chr(17) can no longer appear in the original data.
      Because these characters appear in binary files, remote data
      transmission is not possible -- transmission protocols must be used.
      You find XMODEM routines written in CA-Clipper in the example programs.
      Using the CA-Clipper Tools port functions and this example as a basis,
      other protocols can be developed fairly simply.

      Firm protocols are not provided within CA-Clipper Tools because their
      realization in CA-Clipper code presents no real advantage.  It is more
      important that you have the ability to create your own protocols so that
      you are not locked into whatever protocol is within CA-Clipper Tools.

      b>Control Signals</b>

      You can set or query all important port connector control signals, like
      CD (carrier detect), DTR (data terminal ready), etc..  To simplify your
      programming, there is a separate function for each signal.  For all
      other status and control information, which is seldom required in serial
      communications, you can read or describe the corresponding UARTS
      register of the port directly.

      b>Direct Hardware Access</b>

      All CA-Clipper Tools port functions directly address the hardware.
      Working over BIOS or even DOS calls would be impractical or even
      impossible.  We therefore presuppose 100% hardware compatibility with
      the established IBM personal computer industry standard.

      In order to guarantee that everything is functioning properly, both
      ports must be equipped with either UART 8250 or the compatible 16450.
      When you use the 8250, interrupt controlled transmission is only
      possible up to 2400 baud.  Technical details regarding the ports and the
      UART registers can be found in the corresponding technical instructions,
      like the IBM Technical Reference Manuals.

      b>I/O Addresses and Interrupt Requests</b>

      CA-Clipper Tools assumes the following basic settings for the four
      ports:

      Table 1: Standard Port Settings
      <table>
          Port    I/O Address    IRQ

          COM1:   3F8H           4
          COM2:   2F8H           3
          COM3:   3E8H           4 - Not specifically defined
          COM4:   2E8H           3 - Not specifically defined
         </table>

      In contrast to COM1 and COM2, the I/O addresses and IRQs for other ports
      are often different.  If you want to use hardware that is not entirely
      compatible, CA-Clipper Tools has additional functions that you can use:
      com_SetIO() and com_SetIRQ().  When you use these functions, the I/O and
      IRQ settings for the port routines can be changed to the selected
      values.  However, please notice that incorrect settings can have a wide
      range of consequences when they come in conflict with other hardware.
      These consequences include data loss or damage to hardware.

      The correct settings for your hardware can be found at any given time in
      its accompanying documentation.

      b>Possible Hardware Conflicts</b>

      CA-Clipper Tools recognizes the four addresses mentioned above for the
      ports COM1 to COM4.  The com_Num() function uses these addresses to
      determine the number of available ports.  For example, if the PC has a
      built-in ArcNet adapter, you can have a conflict between the I/O
      addresses.  The CA-Clipper Tools routine addresses 02EAh, which is
      defined totally differently for the ArcNet adapter than for a serial
      interface.  In this case an existing network connection would probably
      be disconnected.  The com_SetIO() function can provide assistance by
      designating the second parameter as 0:

      com_SetIO(<port>,0)

      The corresponding standard address within the internal address table is
      deleted and access to other hardware is avoided.  However, this is only
      possible if the com_Num() function has not previously been called within
      the program.  (In this case the interface would have already been marked
      "in use.")

      b>Important Notes</b>

      As the table of default settings indicates, it is possible for multiple
      ports to use the same IRQ -- a procedure known as interrupt sharing.

      While CA-Clipper Tools functions support these procedures, standard port
      hardware usually does not.  Specialized multiple port cards are
      available from different manufacturers for this purpose.

      Generally we cannot guarantee that interrupt sharing can be
      implemented.

      CA-Clipper Tools supports up to four ports, each with sending and
      receiving buffers of up to 64kB and speed of up to 19200 baud.  This is
      not to say that all this could be used at the same time to its highest
      limit.  Eight buffers at 64kB are not possible.  The buffers must be in
      conventional memory because the buffers are handled by interrupt
      routines.  The number of ports and the speed with which they can
      function correctly is dependent upon the computer being used.

      b>Differences from BASIC</b>

      In contrast to other programming languages (like BASIC),
      com_Open()/com_Init() do not influence control signals.  If you want to
      address a modem over the serial port using CA-Clipper, you must set DTR
      and any other signals yourself, using the corresponding CA-Clipper Tools
      functions.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Break()
   $ONELINER$
      Creates a break on a transmission line
   $SYNTAX$
      com_Break(<nComPort>,<nDuration>) --> lSuccess

   $ARGUMENTS$
      <nComPort>  Designates the serial interface (1 to 4) where a break
      is set.

      <nDuration>  Designates the time in milliseconds that the break
      remains active.  The default value is 100 milliseconds.

   $RETURNS$
      com_Break() returns .T. when the break has been successfully set.

   $DESCRIPTION$
      The output of a break means that the transmission line of an interface
      is held at a specific level for a fixed period of time.  This time can
      be selected as a numeric parameter between 1 and 65535 milliseconds.

      As a rule, a break is usually between 100 and 350 milliseconds long.

   $EXAMPLES$
      Output a 200 millisecond on interface COM1:

      com_Break(1, 200)

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Key(), com_Event()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Close()
   $ONELINER$
      Clears the receiving buffer and closes the com port
   $SYNTAX$
      com_Close(<nComPort>) --> lClosed

   $ARGUMENTS$
      <nComPort>  Designates which port is closed, COM1(1) to COM4(4).

   $RETURNS$
      A return of .T. indicates that the port is open and can be closed
      successfully.

   $DESCRIPTION$
      This function closes one of the ports (1 to 4).  This means that the
      buffer is cleared, and all signals in the modem control register (MCR)
      are deactivated.  Characters remaining in the buffer are lost.  The DTR
      and RTS signals become inactive, and any existing modem connection is
      broken.

   $NOTES$
      Warning!  All characters in the buffer are cleared, and the status
      register is set to 0.  Existing connections are always broken!

   $EXAMPLES$
      nCharacter  :=  com_Count(1)      // How many characters in
                                        // the buffer ?

      IF nCharacter > 0
         * Read everything from buffer!
         cContent  :=  com_Read(1, nCharacter)
      ENDIF

      com_Close(1)

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Open(), com_Init(), com_DTR(), com_RTS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Count()
   $ONELINER$
      Counts the number of characters in the input buffer
   $SYNTAX$
      com_Count(<nComPort>) --> nTotalCharacters

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the number of
      characters in the input buffer is determined.

   $RETURNS$
      com_Count() returns the number of characters in the selected buffer.

   $DESCRIPTION$
      This function allows you to determine the number of characters in one of
      the four possible buffers.  This lets you determine how many characters
      can be read with the com_Read() function.

   $NOTES$
      ■  If an attempt is made to read the number of characters
         available in a closed port, the function returns a value of -1.

   $EXAMPLES$
      nCharacter  :=  com_Count(1)   // Number of characters-port 1

      IF nCharacter > 0
         com_Read(1, 1)              // Read 1 character
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Open(), com_Read()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_CRC()
   $ONELINER$
      Computes a Cyclic Redundancy Check (CRC) for the string
   $SYNTAX$
      com_CRC(<cString>,[<nStart>],[<nPolynomial>])
         --> nCRCValue

   $ARGUMENTS$
      <cString>  Designates the character string for which a CRC is
      computed.

      <nStart>  Designates a starting value that is added to the CRC.
      This value is computed in order to form a CRC for multiple character
      strings.  The default value is 0.

      <nPolynomial>  Designates another polynomial.  The maximum is a 17-
      bit polynomial.  The default polynomial is CRC-16 X.25 (see below).

   $RETURNS$
      com_CRC() returns the 16-bit CRC for <cString> as a numeric value
      between 0 and 65535.

   $DESCRIPTION$
      CYCLIC  REDUNDANCY  CHECK
      Many file transfer protocols use CRC for accurate error recognition.
      This CRC function offers you decisive help when programming your own
      protocols, like XMODEM or KERMIT.

      The specific CRC value always depends on the polynomial that you use.
      This information can be passed as an optional parameter in the form of
      an integer so that the function has almost universal utility.  The CRC
      16 X.25 polynomial used in X.25 systems,.  XMODEM is the default value
      used in the examples below.

      A few examples of polynomials:

      Table 3-1: The Different Polynomials
      <table>
          Type           Arguments Polynomial

          Parity         3         2^1+1
          LCR-8          257       2^8+1
          CRC-12         5011      2^12+2^11+2^3+2^2 +2^1+1
          CRC-16 X.25    69665     2^16+2^12+2^5+1
          CRC-16         98309     2^16+2^15+2^2+1
         </table>

   $NOTES$
      ■  If <nStart> is not passed, then the loss of the previous
         Chr(0) out of <cString> is not detected by a later CRC review.  This
         can be avoided if <nStart> is given a starting value that is not
         equal to 0.

      ■  A function called XMoBlock() is available for building XMODEM
         blocks.

   $EXAMPLES$
      ■  These are simple CRC calculations:

         com_CRC("abc")                 // 40406
         com_CRC("cba")                 // 54260

      ■  These are calculations for multiple strings:

         nCRC1 := com_CRC("123")
         nCRC2 := com_CRC("456", nCRC1)

         ? nCRC2 == com_CRC("123456")   // .T., values are equal

      ■  Form a block for data transmission.  The string is appended to
         the data:

         cData   := "ABCDEFGHIJKLMNOP"
         nCRC    :=  com_CRC(cData)

         cCRCSTR := I2Bin(CRC)          // CRC as a string
         cCRCSTR := CharSwap(cCRCSTR)   // Exchange both bytes
         cBlock  := cData + cCRCSTR     // Transmission block

      ■  The CRC must be 0 for the entire transmitted block!

         ? com_CRC(cBlock)  = 0         // .T., when correctly
                                        // transmitted

   $PLATFORMS$
      DOS
   $SEEALSO$
      XMoBlock()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_CTS()
   $ONELINER$
      Queries the Clear To Send (CTS) status
   $SYNTAX$
      com_CTS(<nComPort>) --> lCTSActive

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which CTS is tested.

   $RETURNS$
      A return of .T. indicates that CTS is active (MSR Bit 5 = 1).  A return
      of .F. indicates that CTS is inactive (MSR Bit 5 = 0).

   $DESCRIPTION$
      com_CTS() lets you check the Clear To Send (CTS) signal within a
      program.  Whether CTS is used for a hardware handshake or for other
      purposes, depends on the external hardware that you use.

   $NOTES$
      ■  If Delta-CTS is required, you must use com_MSR().

   $EXAMPLES$
      DO WHILE .NOT. com_CTS(1)           // Wait for CTS
         * ...
      ENDDO

      com_Send(1, "Good Morning")         // Transmit text

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_MSR(), com_Hard()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_DCD()
   $ONELINER$
      Queries the Data Carrier Detect (DCD) status
   $SYNTAX$
      com_DCD(<nComPort>) --> lDCDActive

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) on which DCD is tested.

   $RETURNS$
      A return of .T. indicates that DCD is active (MSR Bit 8 = 1).  A return
      of .F. indicates that DCD is inactive (MSR Bit 8 = 0).

   $DESCRIPTION$
      com_DCD() lets you check the Data Carrier Detect signal within a
      program.  When you use a modem, DCD indicates that you have a remote
      connection.

   $NOTES$
      ■  If Delta-DCD is required, you must use com_MSR().

   $EXAMPLES$
      A connection is only established when a valid DCD signal has been
      recognized:

      ? "Call recognized..."

      DO WHILE .NOT. com_DCD(1)         // Wait for carrier (DCD)
         * ...
      ENDDO

      ? "Carrier recognized - connection established ..."

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_MSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_DosCon()
   $ONELINER$
      Provides screen output through DOS (ANSI.SYS terminal emulation)
   $SYNTAX$
      com_DosCon(<cString>,[<nLine>],[<nColumn>]) --> cNull

   $ARGUMENTS$
      <cString>  Designates a string that is output through DOS.

      <nLine>  Designates  the line number where the string is output.
      The default position is the cursor position.

      <nColumn>  Designates  the column number where the string is output.
      The default position is the cursor position.

   $RETURNS$
      This function always returns a null string.

   $DESCRIPTION$
      com_DosCon() allows you to output a string through DOS.  This function
      can be used to provide an interpretation of ANSI control sequences
      through ANSI.SYS.  The installed status of the ANSI driver can be
      determined using the ISANSI() function.

      In this way you can easily create a communications program with ANSI
      terminal emulation.

   $NOTES$
      ■  Notice that DSETWINDOW() should be switched off when using
         this function.  Otherwise the output is routed through the CA-Clipper
         driver module, and operates like a print (?) with a position
         instruction.

   $EXAMPLES$
      When ANSI.SYS is linked in, output is through DOS.  This makes a simple
      terminal emulation possible!

      DSETWINDOW(.F.)               // Important for ISANSI()
      cData  := com_Read(1)         // Data read in

      IF ISANSI()                   // ANSI driver present?
         com_DosCon(cData)
      ELSE
         * Own ANSI handling
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      ISANSI()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_DSR()
   $ONELINER$
      Queries the Data Set Ready (DSR) status
   $SYNTAX$
      com_DSR(<nComPort>) --> lDSRActive

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) on which DSR is tested.

   $RETURNS$
      A return of .T. indicates that DSR is active (MSR Bit 6 = 1).  A return
      of .F. indicates that DSR is inactive (MSR Bit 6 = 0).

   $DESCRIPTION$
      com_DSR() lets you check the Data Set Ready signal within a program.

   $NOTES$
      ■  If Delta-DSR is required, you must use com_MSR().

   $EXAMPLES$
      Many modems give an active DSR as soon as a connection is established:

      DO WHILE .NOT. com_DSR(1)            // Wait for DSR (Call)
         * ...
      ENDDO

      ? "Call recognized."

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_MSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_DTR()
   $ONELINER$
      Queries/sets the Data Terminal Ready (DTR) status
   $SYNTAX$
      com_DTR(<nComPort>,[<lNewDTRStatus>]) --> lOldDTRStatus

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) on which DSR is tested.

      <lNewDTRStatus>  Designates the status of DTR.  .T. designates that
      the DTR signal is active, and .F. designates that the signal is
      inactive.  If the parameter is not specified, CA-Clipper Tools does not
      affect the DTR exit signal.

   $RETURNS$
      The returned value corresponds to the DTR signal status prior to the new
      setting, or in the absence of <lNewDTRStatus>, the returned value
      corresponds to the current DTR.  A return of .T. indicates that the DTR
      is active (MCR bit 1 = 1).  A return of .F. indicates that the DTR is
      inactive (MCR bit 1 = 0).

   $DESCRIPTION$
      com_DTR() queries the DTR signal status.  If the second parameter is not
      supplied, the DTR signal status does not change.

   $NOTES$
      ■  The com_Close() function resets DTR (to inactive).  By
         contrast, COM_OPEN does not automatically make DTR active!

   $EXAMPLES$
      A com_Open() does not set the DTR signal.  You must specifically set the
      DTR signal.

      nBuff_size  :=  4000                      // 4000 byte buffer
      lComOk      :=  com_Open(1, nBuff_size)   // Open COM1

      IF lComOk
         com_DTR(1, .T.)                        // Activate DTR Port 1
         * ...
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Open(), com_Close(), com_MCR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_ErrChr()
   $ONELINER$
      Defines the replacement character for a character that is not received correctly
   $SYNTAX$
      com_ErrChr(<nComPort>,[<nErrorCharacter|cErrorCharacter>])
         --> lChanged

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) where an external line
      termination character is established.

      <nErrorCharacter|cErrorCharacter>  Designates the individual error
      character, which can be given as a number or a character.  When it is
      not specified, the port functions do not set any error character in the
      buffer.

   $RETURNS$
      com_ErrChr() returns .T. when the opened port is addressed.

   $DESCRIPTION$
      It is always possible that characters received during a file
      transmission from the port, UART, are recognized inaccurately.  In such
      cases either an error procedure must be called (i.e.  com_Key()) or the
      inaccurate character must be flagged.  During remote transmission, a
      "trash" character is output.  Chr(177) is the default "trash" character;
      however, you can use whatever error character you choose or you can
      suppress the output of a "trash" character entirely.

   $NOTES$
      ■  The Line Status Register (LSR) setting is used to determine
         whether or not characters were inaccurately received.

   $EXAMPLES$
      ■  Use Chr(250) as an error character for port 2:

         ? com_ErrChr(2, 250)       // .T., when accepted

      ■  Switch off the use of an error character for port 4:

         ? com_ErrChr(4)            // .T., when accepted

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Read(), com_LSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Event()
   $ONELINER$
      Designates which event at the port triggered a key trap
   $SYNTAX$
      com_Event(<nComPort>,<nMode>) --> nCode

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) that is tested for the
      event.

      <nMode>  Designates a numeric value between 1 and 5 (see table 3-2).

   $RETURNS$
      This function returns the code of an incoming character, MSR status, LSR
      status, or the number of errors that have occurred to date as a function
      of the <nMode> parameter value.

   $DESCRIPTION$
      As a rule, it is necessary to determine the cause of a trap if a
      character is placed in the keyboard buffer and the procedure specified
      with SET KEY TO is called.  The numeric parameter determines what
      information is accessed.  The information returned for modes 1 to 5 are
      defined as follows:

      Table 3-2: Query Codes for Event Information
      <table>
          Code    Event Information

          1       The function will return the ASCII code of the incoming
                  character.  If no character is available, a -1 is returned.
          2       The function returns the status of the MS register at the time
                  of the interrupt.
          3       The function returns the status of the LS register at the time
                  of the interrupt.
          4       The value of the internal error counter will be returned. The
                  error events in the LSR since the last com_Init() will be
                  counted.
          5       Returns the number of characters which had to be rejected
                  because the buffer was 100% full.
         </table>

   $NOTES$
      ■  With the exception of the error counter, all status
         information is reset when you open the port or when you call
         com_Key() again.

      ■  The conditions of MSR and LSR are considered at each interrupt
         and are linked to the respective status byte in the internal
         environment through a logical OR operation.  It is therefore possible
         to place multiple bits in one of the registers.

      ■  Overrun errors, parity errors, and frame errors (bits 1 to 3)
         are counted as errors exclusively.

      Important!  The input lines on conventional PC interface cards are
      normally not terminated.  This can lead to inexplicable results when you
      query the MSR.

   $EXAMPLES$
      Determine the number of errors that have occurred:

      nErrorCnt  :=  com_Event(1, 4)

      IF nErrorCnt > 25
         * more than 25 errors?
         ? "Too many errors -  terminate program!"
         lRelease  :=  .T.
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Key()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Flush()
   $ONELINER$
      Clears the receiving buffer
   $SYNTAX$
      com_Flush(<nComPort>) --> lClear

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the receiving
      buffer is cleared.

   $RETURNS$
      If the receiving buffer can be cleared successfully, the function
      returns .T..

   $DESCRIPTION$
      This function allows you to flush all the characters in a receiving
      buffer.  This makes it unnecessary to tediously determine how many
      characters are currently in the buffer in order to remove them with a
      read procedure.

      com_Flush() guarantees a truly empty buffer.  However, a new character
      can be received between the time that you call a com_Count() and a
      com_Read().

   $NOTES$
      ■  A com_Flush() on an unopened port is ineffective.

   $EXAMPLES$
      cHayes  :=  "ATZ"           // Hayes modem reset command
      com_Send(1, cHayes)         // Issue Hayes command
      Inkey(1)                    // Wait one second
      com_Flush(1)                // Reject modem reply messages

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Count(), com_Read()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_GetIO()
   $ONELINER$
      Determines the base address of a port
   $SYNTAX$
      com_GetIO(<nComPort>) --> nIOPort

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) to which the current I/O
      address is delivered.

   $RETURNS$
      com_GetIO() returns the I/O address of the designated port.  With an
      invalid parameter or an unavailable port, the function returns a value
      of -1.

   $DESCRIPTION$
      com_GetIO() determines with which port I/O address CA-Clipper Tools
      functions communicate.  This function only returns a value known to
      CA-Clipper Tools software.  It cannot determine the I/O address of an
      interface card!

   $EXAMPLES$
      ■  Determine the COM1 I/O address:

         ? com_GetIO(1)               // 1016

      ■  Specify that you need the address in hexadecimal form:

         ? NToC(com_GetIO(1), 16)     // "3F8"

      ■  Specify an invalid port number:

         ? com_GetIO(5)               // -1

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_SetIO(), com_SetIRQ(), com_GetIRQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_GetIRQ()
   $ONELINER$
      Determines the interrupt request for a port
   $SYNTAX$
      com_GetIRQ(<nComPort>) --> nIRQ

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) to which the IRQ currently
      in use is delivered.

   $RETURNS$
      com_GetIRQ() returns the IRQ currently in use for the designated port.
      When there are incorrect parameters, the function returns a value of -1.

   $DESCRIPTION$
      com_GetIRQ() determines which IRQ is served by the CA-Clipper Tools
      functions for a particular port.  This value corresponds to an internal
      CA-Clipper Tools software setting.  You cannot determine which IRQ is
      using a particular port.

   $EXAMPLES$
      ■  Determine the interrupt request for IRQ to COM2:

         ? com_GetIRQ(2)      // 3

      ■  Specify an inaccurate port number:

         ? com_GetIRQ(5)      // -1

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_SetIRQ(), com_SetIO(), com_GetIO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Hard()
   $ONELINER$
      Turns the hardware handshake (automatic CTS) on/off
   $SYNTAX$
      com_Hard(<nComPort>,<lNewHandshake>,[<lDTR/DSR>])
         --> lOldHandshake

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the hardware
      handshake is switched on or off.

      <lNewHandshake>  Designates whether the handshake is on (.T.) or off
      (.F.).

      <lDTR/DSR>  Designates whether the function uses the DTR/DSR
      handshake or the RTS/CTS handshake.  When passed as .T., the function
      uses the DTR/DSR handshake instead of the RTS/CTS handshake.

   $RETURNS$
      When called only with <nComPort>, the com_Hard() returns .T. if the
      hardware handshake is on and .F.  if the hardware handshake is off.
      When <lNewHandshake> is passed, the function returns the status prior to
      the new setting.

   $DESCRIPTION$
      The size of a receiving buffer is always limited.  To avoid overflow,
      and thereby a loss of characters, software or hardware handshakes are
      usually implemented.  During a hardware handshake, the port monitors the
      RTS signal.  If you use this function to switch this handshake on, the
      signal is activated as soon as the buffer is 75% full.  As soon as the
      buffer content is once again reduced to 50% or less, the port (the RTS
      signal) is once again released.  Some printers use the port signals, DTR
      (output like RTS) and DSR (entry like CTS) instead of RTS/CTS, to avoid
      buffer overflow.  In this case, <lDTR/DSR> can be passed with .T..

   $NOTES$
      ■  The hardware handshake only supports background transmission
         (when com_Open() is implemented with the third parameter
         <nBufferOut>).

      ■  This function works for data input as well as output.

      ■  If you use a hardware handshake, then the RTS signal should no
         longer be affected by com_RTS() or com_MCR().

   $EXAMPLES$
      Turn on the hardware handshake at a port:

      com_Open(2, 1000, 1000)          // Open COM2, background send
                                       // buffer
      com_Hard(2, .T.)                 // RTS/CTS Hardware handshake
                                       // for port 2

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Read(), com_Send(), com_Soft()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Init()
   $ONELINER$
      Initializes the port parameters
   $SYNTAX$
      com_Init(<nComPort>,[<nBaudRate>],[<cParity>],
         [<nDataLength>],[<nStopBits>]) --> lInitialized

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) that is initialized.

      <nBaudRate>  Designates the selected baud rate for the port.
      Settings of 300, 600, 1200, 2400, 4800, 9600 and 19200 baud are
      possible.  The default value is 300 baud.

      <cParity>  Designates parity in the following form: (E)ven, (O)dd,
      (M)ark, (S)pace, or (N)one.  The default value is (N)one.

      <nDataLength>  Designates the data length; seven or eight bits are
      possible.  The default value is eight bits.

      <nStopBits>  Designates the number of stop bits, one or two.  The
      default value is one stop bit.

   $RETURNS$
      If the com port is initialized successfully, the function returns .T..

   $DESCRIPTION$
      In order to use the serial port after you open it, four operating
      parameters must have been passed to this function.  These operating
      parameters are the transmission speed (baud rate), the data length, the
      parity, and the number of stop bits.  Today most bulletin boards use the
      configuration "300 - 9600 baud, 8N1".  This configuration means eight
      data bits, no parity, and one stop bit.  What is important is that all
      these parameters can be changed while the port is closed.  Neither the
      data buffer or the modem status register (DTR, etc.) are affected.

   $NOTES$
      ■  The port must have been opened previously.  It is impossible
         to initialize a port prior to opening it.

      ■  If any or all of the four operating parameters are not
         designated, or are designated incorrectly, the standard arguments of
         300 baud, no parity, eight data bits, and one stop bit is used.

   $EXAMPLES$
      ■  Open and initialize a port:

         nBuff_size := 4000                     // 4000 character buffer
         lComOk  :=  com_Open(1, nBuff_size)    // Open port

         IF lComOk
               * The port is open, now it is to be initialized with 1200
               * baud, no parity, eight data bits, and one stop bit.

               lInitOk  :=  com_Init(1, 1200, "N", 8, 1)

               IF .NOT. lInitOk
                  ? "Port cannot be initialized !"
               ENDIF
         ENDIF

      ■  You can also omit the last three parameters in the above
         example because they correspond to the default settings:

         lInitOk  :=  com_Init(1, 1200)      // Init. with 1200, N, 8, 1

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Open(), com_Close()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Key()
   $ONELINER$
      Monitors the port using key traps
   $SYNTAX$
      com_Key(<nComPort>,[<nKeyValue1>],[<nKeyValue2>])
         --> lActive

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) where particular activities
      are monitored.

      <nKeyValue1>  Designates the key code placed in the keyboard buffer
      in case an interrupt occurs.  Values permitted with CA-Clipper's SET KEY
      TO command are allowed, as a numeric value or a character.  If this
      parameter is not specified, then the port interrupts are not monitored.

      <nKeyValue2>  Designates another key code that is placed in the
      keyboard buffer when the receiving buffer is 75% or more full.  Values
      permitted with CA-Clipper's SET KEY TO command are allowed, as a numeric
      value or a character.  If this parameter is not specified, the buffer
      overflow is not monitored.

   $RETURNS$
      com_Key() returns .T. when at least one trap is switched on and returns
      .F. when all monitoring is switched off.

   $DESCRIPTION$
      com_Key() allows you to monitor a port while the program is in a READ.
      In this way, various events at the port can cause a particular key code,
      selected by the programmer, to be placed in the keyboard buffer.  This
      happens when:

      ■  Data arrives at the port.

      ■  A transmission error or a BREAK is recognized in the LSR.

      ■  One of the signals in the MSR changes.

      ■  The receiving buffer becomes 75% or more full.

      The MSR and LSR status, the number of errors that have already occurred,
      and the receipt of individual characters can be monitored through the
      <nKeyValue1> key code.  All information is saved in an internal memory
      area and can be queried from there using the com_Event() function.  This
      procedure is important because the register or the flags that release
      the interrupt, are automatically reset during read access.  Otherwise,
      the information is lost.

      If the <nKeyValue2> parameter is specified, then one more procedure can
      be specified using the SET KEY TO command when the receiving buffer is
      75% or more full.  If the <nKeyValue2> parameter is specified, the
      <nKeyValue1> key code is no longer placed in the keyboard buffer when
      characters are received.  However, you can still monitor the MSR and
      LSR.

   $NOTES$
      ■  The status of the various interface registers are connected to
         the internal memory for as long as the event is "serviced" by a new
         com_Key() function call.  This means that the modifications made
         during this period cannot be lost.

      ■  COM_KEY must be newly activated after every executed trap.
         This deletes information concerning the internal environment.

      ■  When com_Key() places a character into the buffer because the
         buffer is close to full, it does so independently of the com_Soft()
         or com_Hard() functions.

   $EXAMPLES$
      Chr(227) is placed in the keyboard buffer and calls the COMERRORS
      procedure if an error is recognized at port 2 or if the modem status
      signal changes.  As soon as the buffer is 75% full or more, Chr(228) is
      placed in the keyboard buffer.  When Chr(228) is placed in the keyboard
      buffer, the BUFFERFULL procedure is called:

      #include CTCOM.CH                   // Symbolic constants
                                          // for interface
      com_Open(2, 1000)                   // Open COM2
      CON_INIT(2, 1200, "N", 8, 1)        // Initialize COM2

      SET KEY 227 TO ComErrors
      SET KEY 228 TO BufferFull

      com_Key(2, 227, 228)                // Monitor COM2

      cName  :=  Space(20)                // The port can arrange
      PROCEDURE COMMERRORS(A, B, C)

         nMSR_Status  :=  com_Event(2, 2) // Read accumulated
                                          // MSR data

         nLSR_Status  :=  com_Event(2, 2) // Read accumulated
                                          // LSR data
         com_Key(2, 227, 228)             // Reactivate traps, reset
                                          // internal values of COM_EVENT

         IF IsBit(nMSR_Status, MSR_RI)          // Ring bit set?
            ? "Call (ring) acknowledged!"
         ELSE
            IF ISBIR(nLSR_Status, nLSR_Break)   // Break bit set?
               ? "Break acknowledged!"
            ENDIF
         ENDIF
         RETURN
      PROCEDURE BUFFERFULL(A, B, C)

         * The input buffer must be read!
         com_Key(2, 227, 228)                 // Traps activated here
         cData  := COM.READ(2)                // Read all data
         SELECT MESSDAT
         REPLACE ComDat WITH cData            // Save data
         SKIP
         SELECT INPUT
         RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Event(), com_Count(), com_MSR(), com_LSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_LSR()
   $ONELINER$
      Reads the Line Status Register (LSR)
   $SYNTAX$
      com_LSR(<nComPort>) --> nLSR

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) that reads the Line Status
      Register (LSR).

   $RETURNS$
      com_LSR() returns the contents of the Line Status Register.

   $DESCRIPTION$
      The Line Status Register makes the following information available:

      Table 3-3: LS Register Coding
      <table>
          Bit     Symb. Const              Definition

           0      LSR_ERROR                Parameter error
           1      LSR_DATA_READY           Data ready
           2      LSR_OVERRUN_ERR          Overflow error
           4      LSR_PARITY_ERR           Parity error
           8      LSR_FRAMING_ERR          Framing error
          16      LSR_BREAK                BREAK recognized
          32      LSR_TRANS_HOLD_EMPTY     Transmission holder register empty
          64      LSR_TRANS_EMPTY          TX shift register empty
         </table>

   $NOTES$
      ■  The Line Status Register can only be examined using this
         function.

      ■  Some bits in this register are reset by a read.

   $EXAMPLES$
      nStatus  :=  com_LSR(2)            // Read LSR port 2

      IF IsBit(nStatus, 5)               // Set bit 5
         ? "BREAK recognized - Abort!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_MCR(), com_MSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_MCR()
   $ONELINER$
      Reads or sets the Modem Control Register (MCR)
   $SYNTAX$
      com_MCR(<nComPort>,[<nMCR>]) --> nMCR

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the Modem Control
      Register (MCR) is read or set.

      <nMCR>  Designates a specified parameter between 0 and 255.  If this
      parameter is not specified, then MCR is read only.

   $RETURNS$
      com_MCR() returns the contents of the Modem Control Register.

   $DESCRIPTION$
      The Modem Control Register can be read only and/or read and set.  The
      second optional parameter determines if a new value is set.  The bits
      have the following meaning:

      Table 3-4: MC Register Coding
      <table>
          Bit     Symb.Const.    Definition

          0       MCR_ERROR      Parameter error
          1       MCR_DTR        Data terminal ready (DTR)
          2       MCR_RTS        Request to send (RTS)
          4       MCR_OUT_1      OUT 1
          8       MCR_OUT_2      OUT 2
          16      MCR_LOOP       LOOP
         </table>

   $NOTES$
      ■  The OUT1, OUT2, and LOOP control bits can only be changed
         using this function.  Additional functions are available for DTR and
         RTS.

   $EXAMPLES$
      nStatus  :=  com_MCR(1)         // Port 1 MCR is read only

      IF NumAnd(nStatus, 3) = 3
         ? "DTR and RTS are active!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_DTR(), com_RTS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_MSR()
   $ONELINER$
      Reads the Modem Status Register (MSR)
   $SYNTAX$
      com_MSR(<nComPort>) --> nMSR

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the Modem Status
      Register is read.  COM1(1) to COM4(4) are possible.

   $RETURNS$
      com_MSR() returns a value between 0 and 255 that corresponds to the
      contents of the MSR.

   $DESCRIPTION$
      Not all the values for this status register can be determined from
      separate functions.  For example, if you need Delta status information,
      you can use this function and test the corresponding bit.  The
      individual bits are defined as follows:

      Table 3-5: MC-Register Coding
      <table>
          Bit     Symb. Const.   Definition

          0       MSR_ERROR      Parameter error
          1       MSR_DELTA_CTS  DELTA ready to send (DCTS)
          2       MSR_DELTA_DSR  DELTA data terminal ready (DDSR)
          4       MSR_TERI       Trailing edge RING (TERI)
          8       MSR_DELTA_DCD  DELTA data carrier detected (DDCD)
          16      MSR_CTS        Clear to send (CTS)
          32      MSR_DSR        Data terminal ready (DSR)
          64      MSR_RI         RING indicator (RI)
          128     MSR_DCD        Data carrier detected (DCD)
         </table>

   $NOTES$
      ■  The simultaneous testing of multiple bits in the MSR is fairly
         simple when using a logical AND operation.

      ■  All delta bits in this register are reset using a read
         procedure.

   $EXAMPLES$
      nStatus  :=  com_MSR(1)

      IF IsBit(nStatus, 5)            // CTS (Bit-5) active?
         . . .
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_CTS(), com_DSR(), com_Ring(), com_DCD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Num()
   $ONELINER$
      Gives the number of the highest available serial interface port
   $SYNTAX$
      com_Num() --> nMaxCom

   $RETURNS$
      com_Num() returns the number of the highest available serial interface
      port.

   $DESCRIPTION$
      This function returns the number of the serial interface port available.
      This is not to say that a return value of 3 necessarily means that ports
      1 through 3 are available; for example, COM2 could be missing.  Whether
      or not a serial port can actually be used can be tested using the
      com_Open() or com_Init() functions.

      Normally the addresses described in the Introduction to this chapter are
      scanned for available ports.  Scanning can happen over alternate
      addresses selected through com_SetIO().

      Important!  Four I/O addresses are assigned to ports COM1 - COM4,
      internal to the port functions.  The com_Num() function goes through
      these four addresses and tests to see if a port is available there.
      This can lead to problems if some other hardware is installed in one of
      the address areas.  For example, problems like this have been noted in
      conjunction with ArcNet network cards, which conflict in the address
      area with COM4.  The critical address areas are listed in the table
      below.

      Table 3-6: I/O Addresses for COM1-COM4
      <table>
          Port    I/O Addresses

          COM1    03F8h - 03FFh
          COM2    02F8h - 02FFh
          COM3    03E8h - 03EFh
          COM4    02E8h - 02EFh
         </table>

      If any kind of hardware is found within this I/O address area, then the
      conflicting COM port can be masked.  Additionally, using com_SetIO()
      (<nComPort>, 0) the accompanying base address within the internal table
      is deleted.  You can only mask the conflicting port when com_Num() has
      not previously been called in the program.  If com_Num() has been called
      in the program, the interface is marked "in use".

   $EXAMPLES$
      ■  Determine the number of ports at the standard addresses:

         ? com_Num()                 // e.g. 4

      ■  Determine the number of ports at unusual addresses:

         com_SetIO(3, "110")         // COM3, 110h
         com_SetIO(4, "120")         // COM4, 120h
         ? com_Num()

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_SetIO(), com_Open()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Open()
   $ONELINER$
      Opens the port and initializes the buffer
   $SYNTAX$
      com_Open(<nComPort>,<nBufferIn>,<nBufferOut>,
         [<lTrapMode>]) --> lStatus

      Tip:  The new optional parameter is an enhancement over previous
      versions!

   $ARGUMENTS$
      <nComPort>  Designates the number of the port (1 to 4).

      <nBufferIn>  Designates the size of the receiving buffer up to 64
      kByte.  The default value is 100 bytes.

      <nBufferOut>  Designates the size of the sending buffer for
      background transmission up to 64 kByte.  The default specification is a
      no send buffer.

      <lTrapMode>  Designates when the port triggers an interrupt.  When
      this parameter is .T., the port only triggers an interrupt while
      receiving data, and not as a result of transmission failure.  The
      default value causes the port to trap all occurrences.

   $RETURNS$
      com_Open() returns .T. when the port has been successfully opened and
      you can select the buffer.

   $DESCRIPTION$
      This function allows you to open a serial interface port from COM1 to
      COM4.  These ports have particular I/O addresses.  For example,
      CA-Clipper Tools uses 3F8H as a base address for COM1.  DOS or BIOS
      routines are not even involved; I/O addresses are not read from the BIOS
      data area.  The default values described in the Introduction to this
      chapter are applied, or the values are set using com_SetIO().  The
      availability of a port is tested for these addresses before the port is
      opened.

      Receiving Data
      A buffer of up to 64 kByte can be reserved for each com port.  All
      arriving characters are saved here, even when the CA-Clipper program is
      active elsewhere with another process.  The number of characters in the
      buffer can be checked and partially read.

      Sending Data
      You can also reserve a sending buffer.  If you reserve a sending buffer,
      com_Send() controls the interrupt function for data transmission, which
      means that the interrupt occurs in the background.  Several functions
      are available to control the send buffer.

      Interrupts during Transmission Errors
      If <lTrapMode> is specified as .T., the UART port only triggers an
      interrupt when there is data incoming or interrupt driven data being
      sent.  Events connected with the MSR or the LSR are no longer taken into
      account.  This affects the status signal and particularly affects
      transmission errors.

      This capability was added as the result of research that indicated that
      some adapter ports seemed to trigger interrupts for no reason.  These
      interrupts are caused by "trash" on the lines; as a rule, serial port
      incoming lines were not terminated (electronically closed).  Overflowing
      interrupts can disturb program execution and lead to significant loss of
      performance.

   $NOTES$
      Important!  In contrast to other programming languages, like Basic,
      com_Open() and com_Init() do not affect any control signals.  If you
      want to address a modem at the serial interface through CA-Clipper, you
      must set the DTR and every other signal using the correct CA-Clipper
      Tools functions.

      ■  Buffer size can be between 100 bytes and 64 kByte.  Settings
         too large or too small are corrected, increased or decreased,
         accordingly.

      ■  To ensure compatibility with earlier versions of CA-Clipper
         Tools, the <nComPort>, <nBufferIn>, and <lTrapMode> parameters can be
         used without <nBufferOut> (see the example).

   $EXAMPLES$
      ■  Open a port with monitoring:

         IF com_Num() > 0
            nBuffSize := 4000                     // 4000 byte buffer

            ComOk  :=  com_Open(1, nBuffSize)     // Open COM1

            IF .NOT. ComOk
               ? "Port cannot be opened  !"
            ENDIF
         ENDIF

      ■  Open COM3 with the corresponding send and receive buffer:

         ? com_Open(3, 1000, 1000)           // .T. when successful

      ■  Trigger interrupts for incoming data only, not for
         transmission failure (receiving buffer 1000 characters, normal
         transmission):

         ? com_Open(3, 1000, .T.)            // .T. when successful

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction, com_Init(), com_Send()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Read()
   $ONELINER$
      Reads characters from the receiving buffer
   $SYNTAX$
      com_Read(<nComPort>,[<nLength>],[<lNoDelete>])
         --> cCharacterstring

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) that is read.

      <nLength>  Designates the number of the characters in the buffer
      that are read.  The default value reads all characters.

      <lNoDelete>  Designates whether or not characters are removed from
      the buffer as they are read.  The default setting removes all characters
      from the buffer as they are read.  However, if the parameter is .T., the
      characters remain in the buffer as long as it is not full.

   $RETURNS$
      The returned string contains the corresponding characters from the
      receiving buffer.

   $DESCRIPTION$
      All characters arriving at the serial port are stored in the appropriate
      buffer under interrupt control.  It is possible to determine the number
      of characters in the buffer and to read one, several, or all of the
      characters.  If the <nLength> parameter is not specified, then all the
      characters in the buffer are read.

   $NOTES$
      ■  Remember that you can receive additional characters between
         calling com_Count() and com_Read().

   $EXAMPLES$
      Wait until at least 10 characters have been received:

      DO WHILE com_Count(1) < 10             // Wait until 10
                                             // characters in buffer
         *...
      ENDDO

      cInput := com_Read(1, 10)              // Read in 10 characters
      ? cInput                               // Display characters
                                             // that are read

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Count()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Remote()
   $ONELINER$
      Determines the clear character for the receiving buffer
   $SYNTAX$
      com_Remote(<nComPort>,[<nCharacter|cCharacter>])
         --> lActive

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) where an external line
      termination character is established.

      <nCharacter|cCharacter>  Designates a line termination character,
      which could be a numeric value or a character.  When it is not
      specified, the existing line termination character (if any) is canceled.
      The default character is the no line termination character.

   $RETURNS$
      com_Remote() returns .F. if the specified port is invalid.

   $DESCRIPTION$
      When longer text is sent, the receiver should be able to break off the
      transmission session or to delete the sending buffer.  To do this, a
      character can be defined as an external line termination character.  If
      this character is received, it deletes the background buffer of the
      sending station, as if you had called com_SFlush().  The sending
      CA-Clipper program no longer concerns itself with this session.

      com_SMode() can help you determine if the buffer of the remote station
      has been deleted.

   $NOTES$
      ■  Before a binary file transfer, an existing line termination
         character should be canceled because the transmission could be
         terminated accidentally.

   $EXAMPLES$
      ■  The remote station can terminate using Ctrl-X (Port 2):

         com_Remote(2, 24)
         com_Send(2, cLongText)

         IF IsBit(com_SMode(2), 4)
            ? "Sending buffer is deleted automatically by remote station!"
         ENDIF

      ■  Eliminate the external line termination character:

         com_Remote(2)

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_SKey(), com_SMode(), com_SFlush()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Ring()
   $ONELINER$
      Queries the ring line
   $SYNTAX$
      com_Ring(<nComPort>) --> lActiveRing

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) on which the ring line is
      tested.

   $RETURNS$
      A return of .T. indicates that the ring line is active (MSR bit-7 = 1).
      A return of .F. indicates that the ring line is inactive (MSR bit-7 =
      0).

   $DESCRIPTION$
      com_Ring() lets you check the ring line of a port from within a program.

   $NOTES$
      ■  When TERI (Trailing edge ring) is required, use the com_MSR()
         function.

   $EXAMPLES$
      Modems generally show the ring signal of an incoming call.  This does
      not mean that a trouble free connection has been established.

      DO WHILE .NOT. com_Ring(1)            // Wait for call (RING)
         * ...
      ENDDO

      ?  "Call detected..."

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_MSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_RTS()
   $ONELINER$
      Queries or sets the Request To Send (RTS)
   $SYNTAX$
      com_RTS(<nComPort>,[<lNewRTSStatus>]) --> lOldRTSStatus

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) where the RTS signal is
      queried or changed.

      <lNewRTSStatus>  Designates the RTS signal status.  When the
      parameter is .T., the function activates the RTS signal.  When the
      parameter is .F., the function deactivates the RTS signal.  If no
      parameter is specified, CA-Clipper Tools does not affect the current DTR
      output signal setting.

   $RETURNS$
      The returned status corresponds to the RTS signal status prior to the
      new setting.

      A return of .T. indicates that the RTS signal is active (MCR Bit-2 = 1).
      A return of .F. indicates that the RTS signal is inactive (MCR Bit-2 =
      0).

   $DESCRIPTION$
      com_RTS() queries or changes the status of the Request To Send signal
      (RTS).  If <lNewRTSStatus> is not specified, the RTS status remains
      unchanged.

   $NOTES$
      ■  The com_Close() function resets (deactivates) the RTS signal.
         The com_Open() function does not automatically activate it!

   $EXAMPLES$
      Set an individually programmable hardware handshake:

      com_RTS(2, .T.)      // Request to send a port 2

      DO WHILE .NOT. com_CTS(2)
         *...
      ENDDO

      com_Send(2, "The quick brown fox jumps over the lazy dog")

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Open(), com_Close(), com_MCR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_SCount()
   $ONELINER$
      Counts the number of characters in the background sending buffer
   $SYNTAX$
      com_SCount(<nComPort>) --> nLength

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the send buffer
      length is returned.

   $RETURNS$
      com_SCount() returns the number of characters in the sending buffer of
      the selected port.

   $DESCRIPTION$
      com_SCount() determines the number of characters in one of the four
      possible sending buffers.  This is only possible when the com interface
      is interrupt controlled, meaning that data is sent in the background.

   $NOTES$
      ■  If you attempt to determine the character count in a port that
         is not open, the function returns a value of -1.

   $EXAMPLES$
      nCharacter := com_SCount(1)            // Number of characters
                                             // in Port 1

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Open(), com_Send(), com_SFlush()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Send()
   $ONELINER$
      Transmits data directly or in the background
   $SYNTAX$
      com_Send(<nComPort>,<cString>) --> nLength

      Tip:  An enhancement over previous versions is that there are no new
      parameters!

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) from which transmission
      occurs.

      <cString>  Designates the string that is transmitted by the selected
      port.  If you only need to transmit a single character, then the second
      parameter can also be numeric and thereby pass the ASCII character code
      directly.

   $RETURNS$
      When transmission is successful, a 0 is returned.  If transmission is
      not successful, the number of characters that have not been transmitted
      or could not be placed in the sending buffer is returned.

   $DESCRIPTION$
      com_Send() transmits one or more characters from one of four ports.
      This transmission can be interrupt driven (i.e. occurs in the
      background).  The third parameter of com_Open() determines whether or
      not the transmission is direct or occurs in the background.

      "Normal" Transmission
      During "normal" transmission, program execution can continue only when
      all of the characters have been sent to the port.  A unique situation
      presents itself when the hardware handshake is activated.  As soon as
      the receiving station deactivates the CTS signal from the sending
      station, any transmission is immediately stopped.  To prevent the
      CA-Clipper program from hanging, com_Send() is terminated and a numeric
      value representing the number of characters not yet sent is returned.
      com_CTS() can determine if CTS input has been deactivated by the remote
      station.  The software handshake is not supported in this mode!

      Background Transmission
      The background mode supports software and hardware handshakes.  The
      handshake automatically occurs in the background.  Several new functions
      are available to help you maintain control of the transmission buffer in
      this situation.  For example, com_SMode() allows you to determine if the
      buffer is waiting for an XON character to release the software
      handshake.  Since this kind of wait can prove futile, you can use
      com_Flush() from within the program to empty the transmission buffer.

   $NOTES$
      ■  The handshake is only supported when the transmission buffer
         is sending in the background.  Use small packets during direct
         transmissions, and regularly query com_Soft_R().

      ■  Software and hardware handshakes are switched on using the
         com_Soft() and com_Hard() functions.

   $EXAMPLES$
      ■  This is an example of "normal" transmission at port 1, with no
         transmission buffer open:

         com_Open(1, 1000)                    // Receiving buffer only
         com_Hard(.T.)                        // Hardware handshake
         ACCEPT "Please input name " TO cInput
         nRest := com_Send(1, cInput)         // 1st attempt to transmit

         DO WHILE nRest > 0
            cInput := Right(cInput, nRest)    // Characters not yet sent
            nRest := com_Send(1, cInput)
         ENDDO

      ■  Here is an example for background or interrupt controlled
         transmission at port 1.  Everything else can proceed through "normal"
         transmission:

         com_Open(1, 1000, 1000)           // 1000 byte transmission buffer
         nRest := com_Send(1, "Attempt")   // Place characters in buffer

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Open(), com_Init(), com_Hard()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_SetIO()
   $ONELINER$
      Changes the base address for a port
   $SYNTAX$
      com_SetIO(<nComPort>,<nIOPort|cIOPort>) --> lChanged

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which a new I/O address
      is selected.

      <nIOPort|cIOPort>  Designates a valid I/O address for the selected
      port.  The parameter can be a decimal or hexadecimal string.  For
      information about the default value, see the Introduction this chapter.

   $RETURNS$
      com_SetIO() returns .T. if the new I/O address is successfully set.

   $DESCRIPTION$
      As is the case for other interface card settings, no true standard
      exists for I/O addresses.  This is particularly true for the COM3 and
      COM4 ports.  By using com_SetIO(), CA-Clipper Tools software can be
      adapted to the I/O addresses of the most eccentric interface card.

   $NOTES$
      ■  The function tests to see if there is a port available at the
         selected I/O address.  com_SetIO() returns .T. or .F. accordingly.

   $EXAMPLES$
      ■  This is an example of a setting for port 2, with the I/O
         address as a decimal:

         com_SetIO(2, 504)               // Address 1F8h

      ■  This is an example of a setting for port 4, with the I/O
         address as a hexadecimal:

         com_SetIO(4, "1F8")             // .T.

      ■  This is an example of an invalid I/O address; the value
         exceeds 1023:

         com_SetIO(4, "10F8")            // .F.

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_SetIRQ(), com_GetIO(), com_GetIRQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_SetIRQ()
   $ONELINER$
      Changes the interrupt request for a port
   $SYNTAX$
      com_SetIRQ(<nComPort>,<nIRQ|cIRQ>) --> lChanged

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) where the interrupt request
      (IRQ) is set.

      <nIRQ|cIRQ>  Designates the new IRQ number for the selected port.
      This parameter can be a decimal or a hexadecimal string and can be from
      2 to 15.

   $RETURNS$
      The function returns .T. when the new IRQ has been successfully set.

   $DESCRIPTION$
      Unfortunately, there is not a binding standard for serial ports,
      particularly for COM3 and COM4.

      Each interface card uses an interrupt request line to advise the
      interrupt controller that a character has been received.  The controller
      then passes this information on to the CPU, which calls a service
      routine through the corresponding interrupt vector.  XT systems have
      eight such interrupt lines available.  AT systems have more than 16
      available interrupt lines, some of which are usually occupied with other
      peripherals.  The allocation of a new IRQ is no small matter and
      requires considerable technical expertise.  Determining which IRQ is
      available and is not currently in use can usually be done by studying
      the configuration of all external devices and the technical
      documentation that accompanies your computer system.  Typically IRQ's 0
      and 1 are used for internal purposes (timer), 2 and 9 for network
      adapters, 5 and 7 for the printer, and 6 and 14 for floppies or hard
      disks.

      Tip:  As you will notice from the default setting in the
      Introduction to this chapter, it is possible for multiple ports to use
      the same IRQ (interrupt sharing).  While CA-Clipper Tools functions do
      support this process, standard port hardware usually does not.  However,
      special multiple port cards for this purpose are offered by a variety of
      manufacturers.

   $NOTES$
      ■  Please notice that the base settings that CA-Clipper Tools
         uses for COM1 to COM4 are described in the Introduction to this
         chapter.

      ■  com_SetIRQ() does not test to see if a port is actually
         serving the selected IRQ.

   $EXAMPLES$
      ■  Set COM3 and COM4 to IRQ 5.  This example requires two calls:

         ? com_SetIRQ(3, 5)            // .T.
         ? com_SetIRQ(4, 5)            // .T.

      ■  Set port 4 to IRQ 10. IRQ in hex:

         ? com_SetIRQ(4, "A")          // .T.

      ■  This is an example of an incorrect value for IRQ:

         ? com_SetIRQ(2, 0)            // Timer tick not allowed  .F.
         ? com_SetIRQ(3, "10")         // This would be decimal 16  .F.

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_SetIO(), com_GetIRQ(), com_GetIO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_SFlush()
   $ONELINER$
      Deletes the sending background buffer
   $SYNTAX$
      com_SFlush(<nComPort>) --> lDeleted

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the sending
      buffer is deleted.

   $RETURNS$
      If the selected sending buffer is successfully deleted, the function
      returns a .T.

   $DESCRIPTION$
      com_SFlush() eliminates all the characters in a sending buffer.  This
      can be useful when the send routine has been futilely waiting for an XON
      character (bad software handshake).

   $NOTES$
      ■  A com_SFlush() to a closed port does not work.

      ■  It is not necessary to test for characters in the sending
         buffer to carry out a com_SFlush().

   $EXAMPLES$
      When the sending buffer is waiting for an XON character and the
      transmission has been delayed 30 seconds, the sending buffer is deleted:

      nStart  := Seconds()                    // When sent

      com_Send(2, cSendText)

      IF IsBit(com_SMode(2), 2)               // Waiting for XON?
         IF Seconds() - nStart > 30           // 30 second delay ...
            com_SFlush(2)                     // Delete sending buffer
         ENDIF
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_SCount(), com_SMode()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_SKey()
   $ONELINER$
      Monitors the port using key traps during background transmission
   $SYNTAX$
      com_SKey([<nComPort>],[<nKeyValue1|cKeyValue1>],
         [<nKeyValue2|cKeyValue2>]) --> lActive

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) that is monitored in the
      background during transmission.

      <nKeyValue1|cKeyValue1>  Designates the key code placed in the
      keyboard buffer as soon as the port send buffer has been cleared.  Like
      the values available in CA-Clipper's SET KEY TO command, the key value
      can be a numeric value or an individual character.  When this parameter
      is not passed, the supervision of buffer overflow can be switched off.

      <nKeyValue2|cKeyValue2>  Designates the key code that the function
      places in the keyboard buffer at the start of a software or hardware
      handshake.  Like the values in CA-Clipper's SET KEY TO command, the key
      value can be a numeric value or an individual character.  When this
      parameter is not passed, the supervision of buffer overflow can be
      switched off.

   $RETURNS$
      com_SKey() returns .T. when the selected character is placed in the
      keyboard buffer by the corresponding event.

   $DESCRIPTION$
      This function allows you to monitor a transmission in the background
      with regard to the hardware or software handshake and the contents of
      the buffers.  If you have designated <nKeyValue1>, it is deposited in
      the keyboard buffer as soon as the sending buffer is empty.

      If the software or hardware handshake has been implemented by com_Soft()
      or com_Hard(), then the COM interface program places <nKeyValue2> in the
      keyboard buffer when an XOFF is encountered or the CTS input is
      deactivated.  If you have passed <nKeyValue1>, it is deposited in the
      keyboard buffer as soon as the sending buffer is empty.

      Both events can prove very effective when combined with a CA-Clipper key
      trap.  In this way the program does not constantly have to review the
      status of the sending buffer; it simply "takes note" when something
      happens.  The specific event is then determined with com_SMode() within
      the called procedure.

   $NOTES$
      Important!  After each execution of a trap, com_SKey() must be
      reactivated.

   $EXAMPLES$
      ■  Determine if the port 2 buffer is empty:

         com_SKey(2, , 225)            // Place code 225

      ■  Monitor the software and hardware handshakes for port 2:

      SET KEY 225 TO HANDSHAKE
         ? com_SKey(2, , 225)          // OK when returns .T.

         com_Soft(2, .T.)              // Software handshake on
         com_Hard(2, .T.)              // Hardware handshake on

         com_Send(2, LongText)         // Transmit something...

      ■  It is important that you always send the parameter:

         PROCEDURE HANDSHAKE(A, B, C)

            * Your Program

            com_SKey(2, 225)           // Must be reactivated
            RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Soft(), LASTKLINE(), LASTKPROC(), LASTKFUNC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_SMode()
   $ONELINER$
      Determines the current status of a background transmission
   $SYNTAX$
      com_SMode(<nComPort>) --> nSendMode

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the background
      transmission status is returned.

   $RETURNS$
      com_SMode() returns a number for which the bits represent various
      meanings shown in the table below.

   $DESCRIPTION$
      The ability to transmit in the background demands the ability to control
      the sending buffer.  For example, com_SMode() allows you to check to see
      if the sending buffer is waiting for an XON character when the software
      handshake is enabled.  The bits in the returned value represent the
      different modes:

      Table 3-7: Coding the Sending Mode
      <table>
          Bit  Symb. Const.   Definition

          1    SMODE_EMPTY    Sending buffer empty
          2    SMODE_SOFT     Wait for software handshake release(XON)
          4    SMODE_HARD     Wait for hardware handshake release(CTS)
          8    SMODE_RFLUSH   Deleted from remote station
         </table>

   $NOTES$
      ■  If no sending buffer has been set up for the designated port
         using com_Open(), the function returns a value of 0.

   $EXAMPLES$
      ■  Determine whether the port 2 sending buffer is empty:

         IF IsBit(com_SMode(2), 1)
            ? "Port 2 sending buffer empty!"
         ENDIF

      ■  Wait 20 seconds while the send buffer for port 2 is waiting
         for an XON, then release:

         WaitPeriod(2000)

         DO WHILE IsBit(com_SMode(2), 2) .AND. WaitPeriod()
            *...
         ENDDO

      ■  Clear the send buffer when XON is not received:

         IF IsBit(com_SMode(2), 2)
            com_SFlush(2)            // Clear send buffer port 2
         ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Hard(), com_Soft(), com_Remote(), com_SFlush()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Soft()
   $ONELINER$
      Queries or sets the software handshake (automatic XON/XOFF)
   $SYNTAX$
      com_Soft(<nComPort>,[<lNewHandshake>],[<cXONchar>],
         [<cXOFFchar>]) --> lOldHandshake

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the software
      handshake is set.

      <lNewHandshake>  Designates whether the handshake is on (.T.) or off
      (.F.).  If this parameter is omitted, the function returns the current
      setting.

      <cXONchar>  Designates any character you choose as an XON character.
      The default character is ASCII 19 - Ctrl-S.

      <cXOFFchar>  Designates any character you choose as an XOFF
      character.  The default value is ASCII 17 - Ctrl-Q.

   $RETURNS$
      The function returns the previously set value.

   $DESCRIPTION$
      With modem connections, a hardware handshake is impossible, which is why
      we are making a software handshake available with this function.  When a
      buffer is 75% full, an XOFF character (Ctrl-Q) is transmitted to the
      remote station.  As soon as the buffer has again been emptied to 50% or
      less, the XON character (Ctrl-S) is transmitted.  You can use characters
      other than Ctrl-S or Ctrl-Q for individual protocols, which would then
      be taken into account in the situations described above.

   $NOTES$
      ■  The software handshake only supports background transmission
         (when com_Open() has been implemented with the third parameter
         <nBufferOut>).

      ■  When you want to transmit binary data, the software handshake
         must always be turned off.

   $EXAMPLES$
      com_Open(1, 1000, 1000)   // Open port, background transmission
      com_Soft(1, .T.)          // Software handshake COM1

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Hard(), com_Soft_R(), com_Soft_S()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Soft_R()
   $ONELINER$
      Tests to see if an XOFF character has been received
   $SYNTAX$
      com_Soft_R(<nComPort>,[<lXOFFFlag>]) --> lXOFFFlag

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the XOFF flag is
      tested.

      <lXOFFFlag>  Designates whether the flag is set (.T.) or reset
      (.F.).  The default value (.F.) resets the flag.

   $RETURNS$
      This function returns .T. after the last inquiry or after you open the
      port when the port has received an XOFF character (Ctrl-S).
      Subsequently the port does not receive an XON character (Ctrl-Q).

   $DESCRIPTION$
      If the software handshake is turned on, the receipt of an XOFF character
      is noted with an internal flag.  This flag can be queried using
      com_Soft_R().  The receipt of an XON character resets that flag again.
      Since in some situations an XON character is never transmitted by the
      remote station, the flag can be reset using the second parameter.

   $NOTES$
      ■  If incoming XOFF characters are monitored, then it is best to
         transmit relatively small strings through com_Send().  You can use
         com_Soft_R() to monitor between incoming XOFF characters.

   $EXAMPLES$
      ■  First open the port:

         com_Open(1, 1000)

      ■  Transmit until an XOFF character is recognized:

         nPos := 1

         DO WHILE .NOT. com_Soft_R() .AND. nPos <= Len(cString)
            com_Send(1, SubStr(cString, nPos, 1))
            nPos := nPos + 1
         ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Send(), com_Soft()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      com_Soft_S()
   $ONELINER$
      Tests to see if the buffer has automatically sent an XOFF character
   $SYNTAX$
      com_Soft_S(<nComPort>) --> lXOFFFlag

   $ARGUMENTS$
      <nComPort>  Designates the port (1 to 4) for which the XOFF flag is
      tested.

   $RETURNS$
      This function returns .T. when the remote station indicates that the
      buffer is 75% or more full.

   $DESCRIPTION$
      If the software handshake has been selected and the buffer is more than
      75% full, an XOFF character is automatically transmitted to the remote
      station.  This is noted with an internal flag, which can be queried
      using com_Soft_S().  When the buffer empties to 50% or less, it
      generates the transmission of an XON character, and this flag is reset.

   $NOTES$
      ■  When selecting the size of the buffer, decide whether the
         remaining 25% will be sufficient at high baud rates.

   $EXAMPLES$
      Test to see if a 75% full buffer automatically transmits an XOFF
      character:

      IF = com_Soft_S(1)
         ? "It's time to empty the buffer! "
         ...
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_Read(), com_Soft()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      XMoBlock()
   $ONELINER$
      Generates a block for XMODEM transmission
   $SYNTAX$
      XMoBlock(<cString>,<nBlockNumber>,[<lCRC>],
         [<nMode>]) --> cXModemBlock

   $ARGUMENTS$
      <cString>  Designates a character string of 128 or 1024 (depending
      on <nMode>) characters.  Excess characters are cut off; missing
      characters are filled with Chr(0).

      <nBlockNumber>  Designates the related block number.

      <lCRC>  Designates whether an XMODEM block is to be formed with a
      checksum (.F.) or with a 16-bit CRC (.T.).  The default value (.F.) is a
      checksum.

      <nMode>  Designates different block types.  Mode 1 designates a 128
      byte block with start character Chr(1).  Mode 2 designates a 1kByte
      block with start character Chr(2).  The default value is a mode 1, 128
      byte block.

   $RETURNS$
      This function returns an XMODEM block that is "ready to go".

   $DESCRIPTION$
      This function generates a data block according to XMODEM conventions,
      which can then be output directly using com_Send().  The block number
      and the packet verification procedure that you choose can be designated.
      The function automatically takes into account the fact that after block
      number 255, XMODEM waits for 0 again (block number %256).  So you can go
      as high as you like with your variables.

      An X-MODEM block has the following construction:

      SOH+<BN>+<Complement of BN>+128 data bytes+1 byte CS
      or:
      SOH+<BN>+<Complement of BN>+128 data bytes+2 byte CRC


      This is the construction for a 1k byte block:

      STX+<BN>+<Complement of BN>+1024 data bytes+1 byte CS
      or:
      STX+<BN>+<Complement of BN>+1024 data bytes+2 byte CRC

      BN = Block number, CS = checksum, and CRC = Cyclic Redundancy Check.

   $NOTES$
      ■  Verification of the 8-bit checksum corresponds to the
         NumLow(ASCII-SUM(Data)) function call.

      ■  A programming sample using XMODEM protocols under CA-Clipper
         can be found in the following example program.

   $EXAMPLES$
      This is an example of a simplified XMODEM transfer.  Initialization of
      the port is assumed:

      nBlockNum := 0                       // 1st block
      lChkMode  := .T.                     // Use CRC
      nBlkSize  := 128                     // XMODEM block size
      nPointer  := 0                       // Start point in file

      cData  := FileStr("TEST.TXT", nBlkSize, nPointer)// Read data

      DO WHILE Len(cData) > 0
         COM_SEND;
         (1, XMoBlock(cData, nBlockNum, lChkMode))   // Send block
         nBlockNum := nBlockNum +1                   // Next block
         nPointer  := nPointer  +nBlkSize            // File pointer
         cData     := FILESTR;
         ("TEST.TXT", nBlkSize, nPointer)            // Read data
      ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_CRC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      XMoCheck()
   $ONELINER$
      Tests a received XMODEM block
   $SYNTAX$
      XMoCheck(<cString>,[<lCRC>]) --> nBlockNumber

   $ARGUMENTS$
      <cString>  Designates a character string that is reviewed to
      determine if it represents a valid XMODEM block.

      <lCRC>  Designates whether to check for a checksum (.F.) or a CRC
      (.T.).  The default value (.F.) tests for a checksum.

   $RETURNS$
      XMoCheck() returns the block number for the <cString> transferred by an
      XMODEM block.  The function returns a value between 0 and 255, or
      returns -1 if the block had errors.

   $DESCRIPTION$
      XMoCheck() checks a received XMODEM block for errors.  The block header
      is checked, and depending on the way the <lCRC> parameter has been set,
      XMoCheck() tests the checksum or the CRC.  The function then returns the
      block number as a value between 0 and 255.  If there were inaccuracies
      in the block, -1 is returned.  The standard XMODEM blocks (128 byte
      blocks) and the 1k blocks are recognized on the first character
      automatically.  The header of a 128 byte block starts with Chr(1).   The
      header of a 1k block starts with Chr(2).

   $NOTES$
      ■  "Unpacking" the data after checking the block for accuracy is
         very simple using SubStr(cBlock, 4, 128) for 128 byte blocks or
         SubStr(cBlock, 4, 1024) for 1k blocks.

      ■  There is an example for the programming of an XMODEM protocol
         in Xmodem.prg in the samples directory.

   $EXAMPLES$
      In this example, the block is received and unpacked.  Test to see if the
      following block has been received:

      cBlock  := com_Read(1)               // If 132 characters
      nBlkNr  := XMoCheck(cBlock)          // Test with checksum

      IF nBlkNr >= 0
      cData  := SubStr(cBlock, 4, 128)     // Extract data
         * ...
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      XMoBlock()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ZeroInsert()
   $ONELINER$
      Inserts a 0-bit after every fifth 1-bit
   $SYNTAX$
      ZeroInsert(<cString>) --> cDataBlock

   $ARGUMENTS$
      <cString>  Designates any character string in which you choose to
      insert a 0-bit.

   $RETURNS$
      The function returns a character string with the 0-bit inserted.

   $DESCRIPTION$
      This function has been incorporated to allow simplified programming of
      data transmission protocols to the CCITT specification.  CCITT
      determines that each data block has a start and a stop flag, like
      "01111110".  To ensure that the flag bit pattern doesn't appear within
      the data, a 0-bit is inserted after every fifth 1-bit.  These explicit
      flags allow a transfer protocol to resynchronize itself more quickly if
      a transmission error occurs.  For example, this process is implemented
      by ISDN or X.25 networks.

   $NOTES$
      ■  Due to the inserted bit, the character string that is returned
         is longer than the character string that is transmitted.  Length
         increases a maximum of 20%, which can be calculated as follows:

            nMaxLen = Len(cString) + Ceiling(Len(cString)/5)

   $EXAMPLES$
      ■  For any five bytes of the original string, a maximum of one
         additional byte can arrive as a result.  This example tests, if there
         is enough available free memory, for the resulting string:

         cCharacter := Chr(CToN("11111111", 2)
         cString    := Replicate(cCharacter, 6)
         nMaxLen    := Len(cString) + Ceiling(Len(cString) /5)
                                                         //Here: 8

         IF nMaxLen  < Memory(1) * 1024 - 100
            cString  := ZeroInsert(cString)
         ENDIF

      ■  This example shows the construction of a typical data block:

         cFlag   :=  Chr(CToN("01111110", 2))            // According to
                                                         // CCITT
         cData   :=  "Also transmit ????!"
         CRC    :=  com_CRC(cData)

         cBlock  := cData + SubStr(L2Bin(CRC), 1, 2)     // Add CRC to
                                                         // string
         cBlock  := ZeroInsert(cBlock)
         cBlock  := cFlag + cBlock + cFlag

   $PLATFORMS$
      DOS
   $SEEALSO$
      ZeroRemove(), com_CRC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ZeroRemove()
   $ONELINER$
      Removes 0-bits in a file block
   $SYNTAX$
      ZeroRemove(<idDataBlock>) --> cString

   $ARGUMENTS$
      <idDataBlock>  Designates a character string in which a 0-bit has
      been inserted using ZeroInsert().

   $RETURNS$
      ZeroRemove() returns the character string to the same condition it was
      in prior to ZeroInsert().

   $DESCRIPTION$
      This function is the opposite of ZeroInsert().  This means that the 0-
      bit that was inserted, according to the special CCITT rule, is now
      removed.  Removing the bit decreases the length of the block up to 20%.

   $EXAMPLES$
      This example shows the construction of a typical data block:

      cFlag   :=  Chr(CToN("01111110", 2))          // According to
                                                    // CCITT
      cData   :=  "Also transmit ????!"
      CRC    :=  com_CRC(cData)

      cBlock  := cData + SubStr(L2Bin(CRC), 1, 2)   // Add CRC to
                                                    // string
      cBlock  := ZeroInsert(cBlock)
      cBlock  := cFlag + cBlock + cFlag

      * ... transmission of the data block:

      cData   := RemAll(cFlag, cBlock)              // Remove flag
      cData   := ZeroRemove(cData)
      *... and subsequently the important CRC checks, etc.

   $PLATFORMS$
      DOS
   $SEEALSO$
      ZeroInsert()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      String Manipulation
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      There are an abundance of powerful string functions described in this
      chapter.  A high degree of speed is assured because these functions and
      all of the CA-Clipper Tools are written exclusively in Assembler.

      We have made an effort to find an appropriate example for as many
      unusual variations as possible.  In view of this, we would like to take
      this opportunity to clarify a few ground rules regarding the use of
      these functions.

      b>Passing Parameters by Reference</b>

      This chapter includes functions that pass parameters by reference.  The
      following paragraphs contain clarification about these functions.

      It has been possible to pass parameters of the character string type by
      reference to a UDF since the summer of 1987.  This means that a
      reference to the original string is passed, thus avoiding the creation
      of an internal copy.  When a function accepts this type of parameter and
      changes it, the original string is actually changed.  This behavior does
      not normally apply to CA-Clipper functions.  However, some CA-Clipper
      Tools functions behave differently and take parameters passed by
      reference.  These functions and their corresponding parameters are
      described as reference sensitive in this section and are identified with
      [@] in the argument section of each function's description.

      Passing parameters by reference has advantages and disadvantages.  The
      most important advantage is that memory requirements are reduced.  This
      allows you to avoid runtime errors that could result when there is
      insufficient memory available for string manipulation.

      Whether or not the insufficient memory is a disadvantage depends on the
      function being used.  Often you will want to change the original string.
      In a call that does not pass parameters by reference, the copy changed
      by the function must then be passed back to the "original" string again:

      VAR := "Hello"
      VAR := FUNCTION(VAR)

      When you work with very long strings, this method takes memory and time!

      Here is an example of the reference method:

      VAR := "Hello"
      FUNCTION(@VAR)

      With most CA-Clipper Tools functions, it doesn't make any sense to pass
      parameters by reference.  In some cases, a result is different when a
      parameter is passed in this way.  However, when you do pass by
      reference, the functions change the parameters passed by the string
      directly.  Memory is saved, and the functions work more quickly because
      you no longer need to make an internal copy.  Watch for the [@] marker,
      indicating that a parameter is reference sensitive.

      Functions which change the length of a string cannot, in principle pass
      by reference.  Here is an overview of the functions that change length,
      or depending upon usage, could change if you attempt to pass by
      reference.

      AtRepl()         PosDel()

      CharEven()       PosIns()

      CharOdd()        PosRepl()

      CharOne()        WordOne()

      CharOnly()       WordOnly()

      CharRem()        WordToChar()

      b>CSetRef()</b>

      This function additionally allows you to significantly optimize
      reference sensitive functions with regard to execution speed and memory
      use.  Full details can be found in the corresponding function
      description later in this chapter.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AddAscii()
   $ONELINER$
      Adds a value to each ASCII code in a string
   $SYNTAX$
      AddAscii(<cString>,<nValue>,[<nPosition>]) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the character string that is processed.

      <nValue>  Designates the value that is added to the ASCII value of
      the character.

      <nPosition>  Designates the position of the character to which the
      <nValue> is added.  The default value tells CA-Clipper Tools to add to
      the ASCII value of the last character.

   $RETURNS$
      AddAscii() returns the modified character string.

   $DESCRIPTION$
      This function is very useful when you call procedures using macros.
      When you use AddAscii(), the string representing the macro can be
      changed without needing to include functions like Left(), Right(),
      Asc(), or SubStr() (see example).

      This function also allows you to subtract a value.  However, a
      conversion is necessary.  If a lower case letter is converted into an
      upper case letter, a value of 32 must be subtracted.  This occurs
      according to the following formula:

      Chr((Asc(<Character>) + 256 - Difference) % 256)

   $NOTES$
      ■  If the <nPosition> is greater than the length of <cString> or
         less than 0, the string remains unchanged.

      ■  Zero changes the value of the last character.

      ■  CSetRef() can be used to suppress the returned value for this
         function in order to save space in working memory.

   $EXAMPLES$
      ■  A value of 1 is added to the next to the last position in a
         string and to the last position in a string (Chr(Asc("2")+1) yields
         "3" etc.):

         ? AddAscii("macro21", 1, 6)        // "macro31"
         ? AddAscii("macro21", 1)           // "macro22"

      ■  You can also subtract; -- 32 is the difference between lower
         case and upper case letters, therefore Chr((Asc("m")+256-32) %256):

         ? AddAscii("macro21", 224, 1)      // "Macro21"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AfterAtNum()
   $ONELINER$
      Returns the remainder of the string after the nth appearance of a sequence
   $SYNTAX$
      AfterAtNum(<cSearchFor>,<cString>,[<nCounter>],
         [<nIgnore>]) --> cString

   $ARGUMENTS$
      <cSearchFor>  Designates the string for which the function searches.

      <cString>  Designates the string to search.

      <nCounter>  Designates which occurrence of <cSearchFor> within
      <cString> is found.  The default value specifies the last occurrence in
      the search expression.

      <nIgnore>  Designates the number of characters that are eliminated
      from the search.  The default value ignores none (0).

   $RETURNS$
      AfterAtNum() returns the remainder of the <cString> string from the
      first character after the nth (<nCounter>) occurrence of <cSearchFor>.
      If the last character in the sequence located is also the last character
      in the string being searched, then a null string is returned.

   $DESCRIPTION$
      This function finds the nth (<nCounter>) occurrence of <cSearchFor>
      within <cString> and returns the remainder of the string from the first
      position behind the located sequence.

      In order to determine the nth (<nCounter>) occurrence of <cSearchFor>,
      AfterAtNum() searches from the left for each instance of this sequence.
      If CSetAtMupa() is off, then the search is continued after the last
      character of the sequence most recently found.  Otherwise the search is
      continued after the first character of the sequence most recently found.

   $NOTES$
      ■  Implementing SetAtLike() allows you to use wild card
         characters within <cSearchFor>.

   $EXAMPLES$
      ■  Search a string for the last appearance of "aa" in two
         different ways:

         CSetAtMupa(.T.)
         ? AfterAtNum("aa", "aBaaBaaX")   // "X"

         CSetAtMupa(.F.)
         ? AfterAtNum("aa", "aBaaBaaX")   // "aX"

      ■  Search a string for the third existing "xx" within the string,
         where the first four characters are ignored!  Notice the differing
         results, depending on the multi-pass mode!

         String  := " AxxBBBBxxCCCCxxxDxxEExx"

         CSetAtMupa(.T.)
         ? AfterAtNum("xx", String, 3, 4)   // "DxxEExx"

         CSetAtMupa(.F.)
         ? AfterAtNum("xx", String, 3, 4)   // "EExx"

      ■  Examples for SetAtLike() can be found under the corresponding
         function description.

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetAtMupa(), SetAtLike()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AsciiSum()
   $ONELINER$
      Finds the sum of the ASCII values of all the characters of a string
   $SYNTAX$
      AsciiSum(<cString>) --> nASCIISum

   $ARGUMENTS$
      <cString>  Designates the character string for which the sum of all
      the ASCII values is computed.

   $RETURNS$
      AsciiSum() returns a number that corresponds to the sum of the ASCII
      codes of all the characters in <cString>.

   $DESCRIPTION$
      AsciiSum() allows you to form simple checksums for character strings.
      For example, this can be implemented during remote data transmission to
      identify transmission errors.

   $NOTES$
      ■  This function does not take character position into account,
         so it cannot determine a character transposition.  The Checksum()
         function should be used to determine character transposition.

   $EXAMPLES$
      ■  Transposed characters yield identical results:

         ? AsciiSum("abc")          // Result: 294
         ? AsciiSum("cba")          // Result: 294

      ■  A null string returns 0:

         ? AsciiSum("")             // Result: 0

   $PLATFORMS$
      DOS
   $SEEALSO$
      Checksum()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AscPos()
   $ONELINER$
      Determines the ASCII value of a character at a particular position within a string
   $SYNTAX$
      AscPos(<cString>,[<nPosition>]) --> nAsciiValue

   $ARGUMENTS$
      <cString>  Designates the character string that is searched.

      <nPosition>  Designates the character of <cString> for which the
      ASCII value is determined.  The default character is the last character.

   $RETURNS$
      The function returns the ASCII value for the character at <nPosition>
      within <cString>.

   $DESCRIPTION$
      AscPos() allows you to determine the ASCII value of a selected key
      within a character string.

   $NOTES$
      ■  The returned value can be between 0 and 255.

      ■  If <cString> is a null string, or <nPosition> is larger than
         the length of the string, AscPos() returns 0.

      ■  If <nPosition> is 0, the ASCII value for the last character is
         returned.

   $EXAMPLES$
      ■  You can specify:

         ? AscPos(String, 5)

      ■  Or you can specify:

         ? ASC (SubStr(String, 5, 1))

   $PLATFORMS$
      DOS
   $SEEALSO$
      ValPos()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AtAdjust()
   $ONELINER$
      Adjusts the beginning position of a sequence within a string
   $SYNTAX$
      AtAdjust(<cSearchFor>,<cString>,<nEndpoint>,
         [<nCounter>],[<nIgnore>],[<nCharacter|
         <cCharacter>]) --> cString

   $ARGUMENTS$
      <cSearchFor>  Designates the character string for which the function
      searches, or the character string that provides the reference point for
      adjustment.

      <cString>  Designates the character string within which the
      adjustment occurs.

      <nTargetPosition>  Designates from which position within the
      character string the search expression is adjusted.

      <nCounter>  Designates which occurrence of the <Searchexpression> is
      taken into account.  The default value is for the last occurrence.

      <nIgnore>  Designates the number of characters at the beginning of
      the search string that are removed.  The default value is none.

      <nCharacter|cCharacter>  Designates a character, as necessary, to
      carry out the adjustment.  It can be an individual character or an ASCII
      value between 0 and 255.  The default value is a space Chr(32).

   $RETURNS$
      AtAdjust() returns the modified character string.

   $DESCRIPTION$
      The function first looks for the <cSearchFor> parameter within the
      character string.  From this point, the rest of the <cString> is moved
      (adjusted) by either inserting or removing blanks until the
      <nTargetPosition> is reached.  In lieu of blanks, <nCharacter>|
      <cCharacter> can be used as a fill character.

      Additionally you can specify that the nth occurrence of <cSearchFor> be
      used and whether or not a specific number of characters at the beginning
      of the search string is eliminated.

   $NOTES$
      ■  Using CSetAtMupa() can influence how the search is performed.
         Using SetAtLike() permits the use of wild cards within the search
         sequence.

   $EXAMPLES$
      ■  Align comments at column 60.  The search is for the first
         occurrence of "//".  Since there is usually at least one space before
         each "//", search for " //":

         ? AtAdjust(" //", Line, 60, 1)

      ■  Move the extensions for the following list of file names to
         position 10 and eliminate the ".":

         WINDOW.DBF
         PLZ.DBF
         BACK.DBF
         HELP.DBF
         LOG.DBF

         CharRem(".", AtAdjust(".", File, 10))

         WINDOW      DBF

         PLZ         DBF
         BACK        DBF
         HELP        DBF
         LOG         DBF

      ■  Use AtAdjust() with CSetAtMupa().  There is always a problem
         determining whether "AA" occurs twice or three times in "AAA".
         Depending on CSetAtMupa(), the function searches behind the last
         character, or starts from the last character of a located sequence:

         CSetAtMupa(.F.)
         ? AtAdjust("AA", "123AAABBB", 7, 2)       // Sequence not found

         CSetAtMupa(.T.)
         ? AtAdjust("AA", "123AAABBB", 7, 2)       // "123A  AABBB"

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetAtLike(), CSetAtMupa()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AtNum()
   $ONELINER$
      Determines the starting position of a sequence within a string
   $SYNTAX$
      AtNum(<cSearchFor>,<cString>,[<nCounter>],
         [<nIgnore>]) --> nPosition

   $ARGUMENTS$
      <cSearchFor>  Designates the expression for which the function
      searches.

      <cString>  Designates the character string to search.

      <nCounter>  Designates which occurrence of <cSearchFor> within
      <cString> is determined.  The default value is for the last occurrence
      of the search expression.

      <nIgnore>  Designates the number of characters that should be
      excluded from the search.  The default value is none (0).

   $RETURNS$
      The function returns the position where <cSearchFor> begins.  If no
      corresponding position can be determined, the function returns 0.

   $DESCRIPTION$
      AtNum() determines the initial position of the nth (<nCounter>)
      occurrence of <cSearchFor> within the <cString>.  Additionally, the
      function takes into account the CSetAtMupa() setting, which causes
      differing results.

      AtNum() searches from the left in order to determine the nth
      (<nCounter>) occurrence of the <cSearchFor>.  If CSetAtMupa() is off,
      the search continues after the last character of the sequence most
      recently located.  However, if the CSetAtMupa() is on, the search always
      continues after the first character in the most recently located
      sequence.

      If the <nIgnore> parameter is not specified, the function initiates the
      search with the first character of <cString>.  If the <nIgnore>
      parameter is specified, <nIgnore> characters are ignored from the start
      of the string and are excluded from the search.

   $NOTES$
      ■  If no value is specified for <nCounter>, the function
         determines the last occurrence of the <cSearchFor> sequence.

      ■  When you implement SetAtLike(), wildcard characters can be
         used within the search expression.

   $EXAMPLES$
      ■  Search for the last occurrence:

         ? AtNum("bc", "abcdeabc")               // Result: 7

      ■  Search for the first occurrence:

         ? AtNum("bc", "abcdeabc", 1)            // Result: 2

      ■  Search for the first occurrence, excluding the first three
         characters:

         ? AtNum("bc", "abcdeabc", 1, 3)         // Result: 7

      ■  Determine the impact of CSetAtMupa() on a search for the last
         occurrence of "aa" in "aaa":

         CSetAtMupa(.F.)                         // Off
         ? AtNum("aa", "aaa")                    // Result: 1

         CSetAtMupa(.T.)                         // On
         ? AtNum("aa", "aaa")                    // Result: 2

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetAtMupa(), SetAtLike()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AtRepl()
   $ONELINER$
      Searches for a sequence within a string and replaces it
   $SYNTAX$
      AtRepl(<cSearchFor>,<cString>,<cReplace>,
         [<nCounter>],[<lMode>]) --> cString

   $ARGUMENTS$
      <cSearchFor>  Designates the expression for which the function
      searches.

      <cString>  [@]  Designates the character string that is searched.

      <cReplace>  Designates the character string that is exchanged for
      the sequence in <cString>.

      <nCounter>  Designates which or how many occurrences of <cSearchFor>
      within <cString> are replaced by <cReplace>.  The default value is for
      the last occurrence of the search expression.

      <lMode>  Designates if only the nth (<nCounter>) sequence is
      replaced (.T.), or if all sequences up to the nth (<nCounter>) are
      replaced (.F.).  The default value (.F.) designates that all sequences
      are replaced.

   $RETURNS$
      The function returns a character string in which one or many of the
      <cSearchFor> sequences have been replaced by <cReplace>.

   $DESCRIPTION$
      AtRepl() allows you to replace one or more sequences within <cString>.
      <cReplace> can be shorter or longer than <cSearchFor>.

      <nCounter> specifies that the function searches for the nth occurrence
      of the sequence.  If no value is specified, then the last occurrence is
      used.  All occurrences of <cSearchFor>, up to and including the one
      sought, are replaced unless <nCounter> is assigned a value greater than
      0 and <lMode> is designated .T..

      The CSetAtMupa() setting is only checked when the length of <cReplace>
      is shorter than or equal to that of <cSearchFor>, yielding different
      results.  Beginning on the left, the character string is searched for
      each occurrence of the <cSearchFor> sequence.  If CSetAtMupa() is off
      (.F.), then the search continues after the last character of the
      replaced sequence.  However, if CSetAtMupa() is on, the search always
      continues from the first character of the replaced sequence.

   $NOTES$
      ■  By implementing SetAtLike() you can use wildcard characters
         within the search sequence.

      ■  <cString> can be passed by reference.  If this is the case,
         then both <cSearchFor> and <cReplace> must be the same length.

      ■  If <cSearchFor> and <cReplace> are identical, the function
         terminates immediately.  Such an exchange makes no sense, and if
         CSetAtMupa() is (.T.), the exchange results in an endless loop.

   $EXAMPLES$
      ■  Exchange all "123" with "ab":

         ? AtRepl("123", "123_123_123", "ab")             // "ab_ab_ab"

      ■  Replace "789" with a longer string "abcd" (ignore multi-pass):

         ? AtRepl("789", "789_789", "abcd")               // "abcd_abcd"

      ■  Exchange all "123" with "ab", up to and including the second
         occurrence:

         ? AtRepl("123", "123_123_123", "ab", 2)          // "ab_ab_123"

      ■  Exchange only the second occurrence of "123" with "ab":

         ? AtRepl("123", "123_123_123", "ab", 2, .T.)     // "123_ab_123"

      ■  Exchange all "aa" for "a" and the change the influence of
         CSetAtMupa():

         CSetAtMupa(.F.)
         ? AtRepl("aa", "aaaa", "a")                      // "aa"

         CSetAtMupa(.T.)
         ? AtRepl("aa", "aaaa", "a")                      // "a"

      ■  Exchange "abc" with "ab", with and without multi-pass:

         CSetAtMupa(.F.)
         ? AtRepl("abc", "123abcc456", "ab")              // "123abc456"

         CSetAtMupa(.T.)
         ? AtRepl("abc", "123abcc456", "ab")              // "123ab456"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetAtMupa(), SetAtLike(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AtToken()
   $ONELINER$
      Finds the position of a token within a string
   $SYNTAX$
      AtToken(<cString>,[<cDelimiter>],[<nCounter>])
         --> nPosition

   $ARGUMENTS$
      <cString>  Designates the character string that is passed.

      <cDelimiter>  Designates the delimiter list used to identify the
      tokens.

      <nCounter>  Designates which token's position is determined.  The
      default value is for the last token located.

   $RETURNS$
      AtToken() returns the beginning position of the nth (<nCounter>) token
      within the <cString>.

   $DESCRIPTION$
      AtToken() allows you to determine the beginning position of a token in
      <cString>.  This value can be extremely helpful when you work with other
      string functions.  The function uses the following list of delimiters as
      a standard:

      CHR 32, 0, 9, 10, 13, 26, 32, 138, 141

      and the characters  ,.;:!?/\<<>>()^#&%+-*

      This list can also be replaced with your own list of separators,
      <cDelimiter>.  Here are some examples of useful delimiters:

      Table 4-1: Recommended Delimiter Sequences
      <table>
          Description         <cDelimiter>

          Pages               Chr(12)(Form Feed)
          Sentences           ".!?"
          File names          ":\."
          Numerical strings   ",."
          Date strings        "/."
          Time strings        ":."
         </table>

   $EXAMPLES$
      ■  Find the beginning position of the last token:

         ? AtToken("Good Day")                      // 6

      ■  Find the beginning position of the fourth token:

         ? AtToken("What a beautiful day.", 4)      // 18

      ■  Attempt to determine the beginning position of an unavailable
         token:

         ? AtToken("What a beautiful day.", 6)      // 0

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumToken(), TOKEN(), TokenLower(), TokenUpper()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      BeforAtNum()
   $ONELINER$
      Returns the string segment before the nth occurrence of a sequence
   $SYNTAX$
      BeforAtNum(<cSearchFor>,<cString>,[<nCounter>],
         [<nIgnore>]) --> cString

   $ARGUMENTS$
      <cSearchFor>  Designates the string for which the function searches.

      <cString>  Designates the string that is searched.

      <nCounter>  Designates which occurrence of the <cSearchFor> within
      the <cString> is determined.  The default value is for the last
      occurrence in the search expression.

      <nIgnore>  Designates the nuber of characters that are eliminated
      from the search.  The default value ignores none (0).

   $RETURNS$
      The function returns all the characters in <cString> in front of the
      sequence determined.  If no corresponding sequence is found, then a null
      string is returned.

   $DESCRIPTION$
      This function determines the beginning position of the nth (<nCounter>)
      occurrence of <cSearchFor> within <cString> and returns the string
      segment before this sequence.  Additionally, the function takes into
      account the CSetAtMupa() setting, which can cause differing results.

      In order to determine the nth (<nCounter>) occurrence of the
      <cSearchFor>, BeforAtNum() searches from the left for each instance of
      this sequence.  If CSetAtMupa() is off, then the search continues after
      the last character of the sequence most recently found.  If CSetAtMupa()
      is on, the search continues after the first character of the sequence
      most recently found.

   $NOTES$
      ■  Implementing SetAtLike() allows you to use wildcard characters
         within the search sequence.

   $EXAMPLES$
      ■  Search a string for the last appearance of a sequence:

         ? BeforAtNum("ab", "abcabdabe")                  // "abcabd"

      ■  Search a string for the first occurrence of a sequence:

         ? BeforAtNum("ab", "abcabdabe", 1)               // ""

      ■  Search a string for the first occurrence of a sequence, where
         the first three characters are not considered in the search:

         ? BeforAtNum("ab", "abcabdabe", 1, 3)            // "abc"

      ■  Search a string for the third occurrence of "xx", where the
         first four characters are not considered!  Notice the different
         results when you use the multi-pass mode:

         String := "AxxBBBBxxCCCCxxxDxxEExx"

         CSetAtMupa(.T.)
         ? BeforAtNum("xx", String, 3, 4)            // "AxxBBBBxxCCCCx"

         CSetAtMupa(.F.)
         ? BeforAtNum("xx", String, 3, 4)            // "AxxBBBBxxCCCCxxxD"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetAtMupa(), SetAtLike()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Center()
   $ONELINER$
      Centers a string using pad characters
   $SYNTAX$
      Center(<cString>,[<nLength>],[<cPadCharacter>],
         [<lMode>]) --> cString

   $ARGUMENTS$
      <cString>  Designates the character string that you choose to
      center.

      <nLength>  Designates the length of the line within which the
      <cString> sequence is centered.

      <cPadCharacter>  Designates the character with which the <cString>
      sequence is centered.  The default character is a space.

      <lMode>  Designates whether only the beginning, or both sides of
      <cString> are padded.  The default value (.F.) only fills the beginning.

   $RETURNS$
      The processed string is returned.

   $DESCRIPTION$
      The Center() function provides a simple way to center text in any line.
      Center() is able to pad only on the left or on the left and right using
      any selected character.  Leading and trailing blanks (if any) are
      replaced with the new character.

      When <nLength> is not specified, Center() assumes the maximum available
      line width to be MaxCol() + 1, so that the correct output appears in the
      windows.  Additionally, the current cursor position or the column
      position selected through a SAY command is also noted.  So, if there is
      an output on an 80-column line that begins at column 20, a section of 40
      characters from column 20 is used to center the output.

   $NOTES$
      ■  If the sum of the pad characters is odd, then one more
         character is inserted at the beginning of the character string.

   $EXAMPLES$
      ■  Center the output with an available line length of 10, and
         insert the leading characters:

         ? Center("xx", 10)                     // "    xx"

      ■  Fill on the left and on the right:

         ? Center("xx", 10, .T.)                // "    xx    "

      ■  When characters that match the <cPadCharacter> are present,
         these characters are removed prior to centering:

         ? Center("xx     ", 10, .T.)           // "    xx    "

      ■  Fill with other characters:

         ? Center("xx", 10, ".")                // "....xx"
         ? Center("xx", 10, ".", .T.)           // "....xx...."
         ? Center("x", 10, ".", .T.)            // ".....x...."

      ■  In the following example, the "X" is intended to represent a
         40-character wide screen.  The string "CLIPPER" is centered there
         with the "." character, starting at position 10:

         @@ 1, 10 SAY Center("CLIPPER", ".", .T.)

         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
         XXXXXXXXX.......CLIPPER......XXXXXXXXX
         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

   $PLATFORMS$
      DOS
   $SEEALSO$
      PadLeft(), PadRight()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharAdd()
   $ONELINER$
      Adds the corresponding ASCII codes of two strings
   $SYNTAX$
      CharAdd(<cString1>,<cString2>) --> cString

   $ARGUMENTS$
      <cString1>  [@]  Designates the character string to which values
      from a second character string <cString2> are added.

      <cString2>  Designates the character string that is added, character
      for character, to <cString1>.

   $RETURNS$
      The processed character string is returned.

   $DESCRIPTION$
      You can use CharAdd() to produce simple character string coding.  The
      function can prove very useful when processes are coded by individual
      characters in a string.

   $NOTES$
      ■  When both character strings are the same length, then the
         first byte of <cString1> can be linked with the first byte of
         <cString2>, and the second byte of <cString1> can be linked with the
         second byte of <cString2>, and so on.  If <cString2> is shorter than
         <cString1>, then as soon as the last byte of <cString2> is reached,
         the process continues and starts again with the first byte of
         <cString2>.  However, if <cString1> is shorter than <cString2>, the
         process terminates with the end of <cString1>.

      ■  Values greater than 256 can result when adding values.  The
         new value is then formed based on the following formula:

            (Asc(Character1) + Asc(Character2))% 256.

      ■  Implementing CSetRef() can suppress the return value for this
         function to save room in working memory.

   $EXAMPLES$
      ■  Add a value of 1 to each character:

         ? CharAdd("01234", Chr(1))        // "12345"

      ■  Adding a value of 255 to each character corresponds to
         subtracting 1:

         ? CharAdd("12345", Chr(255))      // "01234"

   $PLATFORMS$
      DOS
   $SEEALSO$
      AddAscii(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharAnd()
   $ONELINER$
      Links corresponding ASCII codes of paired strings with an AND operation
   $SYNTAX$
      CharAnd(<cString1>,<cString2>) --> cString

   $ARGUMENTS$
      <cString1>  [@]  Designates the character string to which characters
      are added.

      <cString2>  Designates the character string that contains the
      characters that are added to the characters in <cString1>.

   $RETURNS$
      The processed string is returned.

   $DESCRIPTION$
      CharAnd() can be used as a simple way to reset the high bit for all the
      characters in a string.  The function joins (links bit by bit using an
      AND operation) each character in <cString1> with the corresponding
      character in <cString2>.

   $NOTES$
      ■  When both character strings are the same length, then the
         first byte of <cString1> can be linked with the first byte of
         <cString2>, and the second byte of <cString1> can be linked with the
         second byte of <cString2>, and so on.  If <cString2> is shorter than
         <cString1>, then as soon as the last byte of <cString2> is reached,
         the process continues and starts again with the first byte of
         <cString2>.  However, if <cString1> is shorter than <cString2>, the
         process terminates with the end of <cString1>.

      ■  Implementing CSetRef() can suppress the return value for this
         function to save room in working memory.

   $EXAMPLES$
      The second parameter is shorter than the first parameter in this
      example.  As a result, the "1", the "a", and the first blank are joined
      with AND to the "1" in "123"; the "2", the "b", and the second blank are
      joined with AND to the "2" in "123"; and the "3", the "c", and the third
      blank are joined with AND to the "3" in "123":

      ? CharAnd("123abc   ", "123")      // "123!"#   "

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharXor(), CharOr(), CharNot(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharEven()
   $ONELINER$
      Returns characters in the even positions of a string
   $SYNTAX$
      CharEven(<cString>) --> cString

   $ARGUMENTS$
      <cString>  Designates the character string from which all even
      characters are returned.

   $RETURNS$
      CharEven() returns a string containing all the even characters of
      <cString>.

   $DESCRIPTION$
      CharEven() assembles all even characters within a string into a new
      character string.  This allows you to process variables consisting of
      the characters and attributes of a video screen's contents very simply.
      This function can be implemented in conjunction with functions from the
      video section.  You can return the attributes from a screen string, with
      all the characters removed.

   $NOTES$
      ■  The first position in a string is 1, and therefore is not
         even.

   $EXAMPLES$
      ■  Assemble all even characters:

         ? CharEven("1234a")              // "24"

      ■  Return the expanded text to "normal":

         ? CharEven(" H e l l o")         // "Hello"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharMix(), CharOdd(), ScreenMix(), ScreenStr(), StrScreen()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharList()
   $ONELINER$
      Lists each character in a string
   $SYNTAX$
      CharList(<cString>) --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

   $RETURNS$
      CharList() returns a list in which each character in <cString> appears
      only once.

   $DESCRIPTION$
      CharList() determines the list of characters that appear in the
      <cString>.  Each character only appears in the list once.

   $NOTES$
      ■  The CharList() function's return value is never longer than
         256 characters.

      ■  If you sort this result with CharSort(), you have an ascending
         list of characters.

   $EXAMPLES$
      ■  What letters are contained in the text?

         ? CharList("Hello goodbye")                // "Helo gdby"

      ■  Show a sorted list of all letters in a text:

         ? CharSort(CharList("Hello goodbye"))      // "Hbdegloy"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharOne(), CharSort()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharMirr()
   $ONELINER$
      Mirrors characters within a string
   $SYNTAX$
      CharMirr(<cString>,[<lBlank>]) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the character string that is mirrored.

      <lBlank>  Designates whether the function mirrors everything (.F.)
      or does not mirror the blanks at the end of a character string (.T.).
      The default value is .F..

   $RETURNS$
      CharMirr() returns the processed <cString>.

   $DESCRIPTION$
      CharMirr() reverses a string.  The function returns a palindrome of
      <cString>.

      The optional logical parameter allows you to mirror a string and ignore
      the blanks.  This permits you to build index entries that end with a
      particular sequence.

   $NOTES$
      ■  The returned value of this function can be suppressed by
         implementing CSetRef() to save room in working memory.

   $EXAMPLES$
      ■  This example shows a simple exchange:

         ? CharMirr("abc321")         // Result: "123cba"

      ■  This example shows one of the best known palindromes:

         ? CharMirr("ABLE WAS I ERE I SAW ELBA")

      ■  When you index, you must do it without spaces because this is
         the only way a reverse string can be searched for:

         INDEX ON CharMirr(Field, .T.) TO Index

      ■  Search for all expressions in the mirrored index, ending in
         "per":

         SEEK "rep"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharMix()
   $ONELINER$
      Mixes two strings together
   $SYNTAX$
      CharMix(<cString1>,<cString2>) --> cString

   $ARGUMENTS$
      <cString1>  Designates a string that is mixed with <cString2>.

      <cString2>  Designates a string that is mixed with <cString1>.

   $RETURNS$
      CharMix() returns a string that is double the length of <cString1>,
      assuming that <cString2> contains at least one character.

   $DESCRIPTION$
      This function allows you to mix the characters from two character
      strings together.  The characters from <cString1> and <cString2> appear
      alternately in the result string.  The length of <cString1> forms the
      basis for the maximum count of the resulting mix.  A longer <cString2>
      string is cut down to the length of <cString1>.  A shorter <cString2> is
      processed from beginning to end, wrapping to the beginning again until
      there are no more characters in <cString1>.

   $NOTES$
      ■  This function can be used to recombine strings extracted by
         CharEven() or CharOdd().

   $EXAMPLES$
      ■  This is an example of a simple mix:

         ? CharMix("ABC", "123")       // "A1B2C3"

      ■  This is a mix where the second string is shorter:

         ? CharMix("ABCDE", "12")      // "A1B2C1D2E1"

      ■  This is a mix where the second string is longer:

         ? CharMix("AB", "12345")      // "A1B2"

      ■  What you can do with this?

         ? CharMix("HELLO". " ")       // "H E L L O"

      ■  If the second parameter is null, then the first parameter is
         returned unchanged:

         ? CharMix("HELLO", "")        // "HELLO"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharEven(), CharOdd(), Expand(), ScreenMix()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharNoList()
   $ONELINER$
      Lists the characters that do not appear in a string
   $SYNTAX$
      CharNoList([<cString>]) --> cNotContained

   $ARGUMENTS$
      <cString>  Designates the string that is processed.  The default
      value is for an empty string.

   $RETURNS$
      CharNoList() returns a character string that contains all characters not
      found in <cString>.

   $DESCRIPTION$
      This function determines all characters that are not contained in
      <cString>.  The resulting characters might be used as replacement
      characters or for complex deletion procedures.

   $EXAMPLES$
      ■  Delete all characters except "XYZ":

         String := "ABXCDYEF"
         ? CharRem(CharNoList("XYZ"), String)               // "XY"

      ■  Generate a list of all 256 ASCII characters:

         ? CharNoList()

      ■  To save text to a memo field, all null characters (Chr(0))
         must be exchanged for a character that is not being used:

         cNoList   := CharNoList(cMemoText)
         cNoChar   := SubStr(cNoList, 1, 1)
         CharRepl(Chr(0), @cMemoText, cNoChar)

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharList(), CharOne()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharNot()
   $ONELINER$
      Complements each character in a string
   $SYNTAX$
      CharNot(<cString>) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the string that is negated.

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      This function negates each bit in <cString>.  This makes it possible to
      get a decreasing index sequence.

   $NOTES$
      ■  The returned value of this function can be suppressed by
         implementing CSetRef() to save room in working memory.

   $EXAMPLES$
      When a character string that has already been negated is negated again,
      the result is identical to the original:

      CharNot("123ABCabc")     // "     ¥£ "
      CharNot("      ¥£")      // "123ABCabc"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharAnd(), CharXor(), CharOr(), Complement(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharOdd()
   $ONELINER$
      Returns characters in the odd positions of a string
   $SYNTAX$
      CharOdd(<cString>) --> cString

   $ARGUMENTS$
      <cString>  Designates the character string from which all the odd
      characters are returned.

   $RETURNS$
      CharOdd() returns a character string that contains all the odd
      characters from <cString>.

   $DESCRIPTION$
      CharOdd() assembles all odd characters within a string into a new
      character string.  This allows you to process variables where screen
      content, consisting of characters and attributes, is saved.  This
      function can then be used in conjunction with functions from the video
      section.

   $NOTES$
      ■  The first position in a string is 1, and therefore is odd.

   $EXAMPLES$
      ■  Assemble all odd characters:

         ? CharOdd("1234a")            // "13a"

      ■  Return the expanded text to "normal":

         ? CharOdd("H e l l o ")       // "Hello"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharMix(), CharEven(), ScreenMix(), ScreenStr(), StrScreen()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharOne()
   $ONELINER$
      Reduces adjoining duplicate characters in a string to one character
   $SYNTAX$
      CharOne([<cDeleteCharacters>],<cString>) --> cString

   $ARGUMENTS$
      <cDeleteCharacter>  Designates the characters that have their
      adjoining duplicates removed from <cString>. The default value removes
      all adjoining duplicate characters.

      <cString>  Designates the character string that is processed.

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      CharOne() searches within the <cString> for repetitions of adjoining
      characters.  When a character is removed, all of the characters but the
      first are deleted.  This differs significantly from the CharList()
      function, where multiple occurrences of characters within the context of
      the string are removed.

   $NOTES$
      ■  Without the <cDeleteCharacter> parameter, all the repeating
         characters are removed.  If the parameter is specified, only those
         characters in <cDeleteCharacter> are removed.

   $EXAMPLES$
      ■  Check for double occurrences of each character in the
         character string:

         ? CharOne("122333a123")             // "123a123"
         ? CharOne("A  B  CCCD")             // "A B CD"

      ■  Delete multiple side-by-side blanks:

         ? CharOne(" ", "A  B  A  B")        // "A B A B"

      ■  Make the letter "o" only appear once in the character string:

         ? CharOne("o", "122oooB12o")        // "122oB12"

   $PLATFORMS$
      DOS
   $SEEALSO$
      WordOne(), CharList(), CharRem(), CharOnly()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharOnly()
   $ONELINER$
      Determines the common denominator between two strings on the basis of individual characters
   $SYNTAX$
      CharOnly(<cString1>,<cString2>) --> cString

   $ARGUMENTS$
      <cString1>  Designates a sequence of characters that are not removed
      from <cString2>.

      <cString2>  Designates the string that is processed.

   $RETURNS$
      CharOnly() returns the processed string <cString2>.

   $DESCRIPTION$
      CharOnly() removes all characters from <cString2> that are not in
      <cString1>.  The function is particularly useful when comparing data
      that should have a standard format but has been input by different
      people.  This category can consist of things like telephone numbers,
      part numbers, customer numbers, etc. (see example).

   $EXAMPLES$
      Since numbers are the only characters that are relevant in a telephone
      number, any characters that are not numbers are removed.  The result in
      each case is "2133907923":

      ? CharOnly("0123456789", "213 - 39 07 923")
      ? CharOnly("0123456789", "213 / 390 7923")

   $PLATFORMS$
      DOS
   $SEEALSO$
      WordOnly(), CharRem(), CharOne()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharOr()
   $ONELINER$
      Joins the corresponding ASCII code of paired strings with an OR operation
   $SYNTAX$
      CharOr(<cString1>,<cString2>) --> cString

   $ARGUMENTS$
      <cString1>  [@]  Designates the string upon which the OR operation
      is performed.

      <cString2>  Designates the characters that are used when performing
      the OR operation on <cString1>.

   $RETURNS$
      CharOr() returns the processed <cString1>.

   $DESCRIPTION$
      The function joins (links bit by bit using an OR operation) each
      character in <cString1> with the corresponding characters in <cString2>.
      CharOr() can therefore place particular bits within the characters.

   $NOTES$
      ■  If both character strings are the same length, then the first
         byte of <cString1> is linked with the first byte of <cString2>, and
         the second byte of <cString1> is linked with the second byte of
         <cString2>, etc..  If <cString2> is shorter than <cString1>, then
         when the last byte of <cString2> is reached, it continues with the
         first byte of <cString2>.  However, if <cString1> is shorter than
         <cString2>, the process terminates at the end of <cString1>.

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save room in working memory.

   $EXAMPLES$
      ■  Both bytes in the first parameters are joined with OR using
         the "0" character.  This means that Chr(1) is converted into the
         ASCII character æ1", Chr(2) into the ASCII character "2", etc.:

         ? CharOr(Chr(1) + Chr(2), "0")            // "12"

      ■  All bytes in the first parameters are joined (OR) with Chr(32)
         (set bit 5 only):

         ? CharOr("123ABCC[\]abc", CHR (32))       // "123abc(|)abc"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharAnd(), CharXor(), CharNot(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharPack()
   $ONELINER$
      Compresses (packs) a string
   $SYNTAX$
      CharPack(<cString>,[<nMethod>]) --> cPackString

   $ARGUMENTS$
      <cString>  Designates the character string that is packed.

      <nMethod>  Designates which pack algorithm is used on the designated
      character string.  The default value is method 0.

   $RETURNS$
      CharPack() returns the compressed string.

   $DESCRIPTION$
      This function allows you to compress (pack) the contents of strings.
      The function supports two different pack methods:

      Table 4-2: Pack Methods Supported
      <table>
          <nMethod>    Pack Algorithm

          0            Modified run length encoding
          1            Bit oriented algorithm
         </table>

   $NOTES$
      Important!  A packed string can contain Chr(0) or other control
      characters.

   $EXAMPLES$
      Using the bit pack method, compress a text from a DOS file:

      Var := CharPack(FileStr("C:\TEXT\TEST.TXT"), 1)
      StrFile(Var, "C:\TEXT\TEST.PAK")      // New save

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharUnpack()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharRelA()
   $ONELINER$
      Correlates the character positions in paired strings
   $SYNTAX$
      CharRelA(<cSearchFor1>,<cString1>,<cSearchFor2>,
         <cString2>) --> nPosition

   $ARGUMENTS$
      <cSearchFor1>  Designates the character that is searched for in
      <cString1>.

      <cString1>  Designates the character string to search with
      <cSearchFor1>.

      <cSearchFor2>  Designates the character that is searched for in
      <cString2>.

      <cString2>  Designates the character string to search with
      <cSearchFor2>.

   $RETURNS$
      CharRelA() returns the positions where <cSearchFor1> and <cSearchFor2>
      occur in the corresponding character strings.

   $DESCRIPTION$
      This function builds a relationship (CHAR RELAtion) between two
      character strings.  It determines the positions where the characters in
      <cSearchFor1> appear in <cString1> and  where the characters in
      <cSearchFor2> appear in <cString2>.

   $NOTES$
      ■  The function returns a value of 0 if no relationship is found.

   $EXAMPLES$
      Search for the first position in which a "b" appears in the first string
      and a "1" appears in the second:

      ? CharRelA("b", "b b b b", "1", "bbb11111")      // 5

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharRelRep()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharRelRep()
   $ONELINER$
      Replaces characters in a string depending on their correlation
   $SYNTAX$
      CharRelRep(<cSearchFor1>,<cString1>,<cSearchFor2>,
         <cString2>,<cReplaceExpression>) --> cString

   $ARGUMENTS$
      <cSearchFor1>  Designates one or more characters within <cString1>
      for which to search.

      <cString1>  Designates the character string where <cSearchFor1> is
      found.

      <cSearchFor2>  Designates one or more characters within <cString2>
      for which to search.

      <cString2>  [@]  Designates the character string where <cSearchFor2>
      is found.

      <cReplaceExpression>  Designates one or more characters to replace
      those at the established corresponding position within <cString2>.

   $RETURNS$
      The processed <cString2> is returned.

   $DESCRIPTION$
      This function is easier to use than it seems. If we proceed on the
      assumption that both search expressions and the replacement expression
      are only one character long, then the following steps occur:

      ■  All positions are determined where <cSearchFor1> is found
         within <cString1>.

      ■  All positions are found where <cSearchFor2> is found within
         <cString2>.

      ■  The character in the <cString2> string is replaced by the
         character in the <cReplaceExpression>.

      This function can be used to simplify work with variables that contain
      screen memory.  If cPict1 contains the character "|"at position 34 and
      cPict2 contains the character "-" at the same position, then this
      position within cPict2 can be replaced with a new character, "+"', which
      represents the combination of the two.


      Multiple Exchanges
      Both search expressions and the replacement expression can be longer
      than one character.  The previously described exchange procedure occurs
      repeatedly -- initially with the first character in the three character
      strings, then with the second, and so on.  The number of iterations is
      regulated by the length of <cSearchFor1>.  If <cSearchFor2> or the
      <cReplaceExpression> are shorter, then the last byte is used again.

   $NOTES$
      ■  The length of <cString2> determines the number of search
         procedures at any one time.  The length of <cSearchFor1> determines
         the number of possible exchanges.

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

      ■  A use for multiple replacement using CharRelRep() can be found
         in the accompanying sample programs.

   $EXAMPLES$
      Determine every position where a "b" occurs in the first string and a
      "1" occurs in the second string.  The respective character is then
      exchanged for the one designated as the fifth parameter.

      ? CharRelRep("b", "b b b b", "1", "bbb11111", "x")
                                                         //"bbb1x1x1"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharRelA(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharRem()
   $ONELINER$
      Removes particular characters from a string
   $SYNTAX$
      CharRem(<cDelCharacterstring>,<cString>) --> cString

   $ARGUMENTS$
      <cDelCharacterstring>  Designates the characters that are removed
      from <cString>.

      <cString>  Designates the string that is processed.

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      With this function you can remove particular characters from any
      position in <cString>.  It is possible to ensure that the character
      string does not contain these characters later.

   $NOTES$
      ■  No changes occur if you pass invalid or incorrect parameters.

   $EXAMPLES$
      ■  Remove the blanks from a string:

         ? CharRem(" ", " 1  2   ")     // "12"

      ■  Remove the number "3" and the letter "y":

         ? CharRem("3y", "xyz123")      // "xz12"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharOnly(), CharOne()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharRepl()
   $ONELINER$
      Replaces certain characters with others
   $SYNTAX$
      CharRepl(<cSearchFor>,<cString>,   <cReplaceExpression>,
         [<lMode>]) --> cString

   $ARGUMENTS$
      <cSearchFor>  Designates a list of characters to search for in
      <cString>.

      <cString>  [@]  Designates the character string within which to
      search for and replace the characters in <cSearchFor>.

      <cReplaceExpression>  Designates the character list that replaces
      characters in <cString>.

      <lMode>  Designates whether multiple replacements are made.

      <lMode>  Designates one pass of the <cString> (.T.) or multiple
      replacements (.F.).  The default value is for .F..

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      This function allows you to carry out very complex replacement
      procedures.  Every character in the <cSearchFor> is searched for within
      the <cString>.  If found, the character is replaced by the corresponding
      character in the <cReplaceExpression>.

      If <lMode> is not passed, characters are exchanged repeatedly as
      required.  This means that the function goes through each individual
      character in the found characters in sequence, and then searches the
      entire <cString>, exchanging <cSearchFor> for corresponding characters
      in <cReplaceExpression>.  When you use this technique, characters that
      have already been replaced are exchanged again if the replacement
      character also appears in the search list.

      However, if the optional <lMode> parameter is specified, the function
      proceeds differently.  It goes through each character in <cString> in
      sequence, determining whether or not it should be replaced.  Characters
      that have been replaced are not replaced again.

      As a rule, if the same characters appear within <cReplaceExpression> and
      <cSearchFor>, you must check very closely to determine which <lMode>
      parameter should be used (see example).

   $NOTES$
      ■  If the <cReplaceExpression> sequence is shorter than
         <cSearchFor>, the characters that do not have a corresponding
         replacement in <cReplaceExpression> are replaced with the last
         character of <cReplaceExpression> (see example).

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  The number "1" is replaced with the letter "a", the number "2"
         with the letter "b", etc..  If the number "4" appeared in the
         character string, it would be replaced with a "d":

         ? CharRepl("1234", "1x2y3z", "abcd")              // "axbycz"

      ■  The letters a-j are replaced with the numbers 0-9; for
         example, an "f" is replaced with a "6":

         ? CharRepl("abcdefghij", "jhfdb", "1234567890")   // "08642"

      ■  The third parameter makes fewer characters available for the
         exchange.  Therefore the letters f-j are replaced with the last
         characters from "12345":

         ? CharRepl("abcdefghij", "jhfdb", "12345")        // "55542"

      ■  Here is an example of the difference between a specified
         <lMode> parameter (.T.) and the default parameter (.F.):

         ? CharRepl("1234", "1234", "234A")                // "AAAA"
         ? CharRepl("1234", "1234", "234A", .T.)           // "234A"

   $PLATFORMS$
      DOS
   $SEEALSO$
      WordRepl(), WordToChar(), PosRepl(), RangeRepl()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharSort()
   $ONELINER$
      Sorts sequences within a string
   $SYNTAX$
      CharSort(<cString>,[<nElementlength>],
         [<nComparisonlength>],[<nIgnore>],
         [<nElementPosition>],[<nSortlength>],
         [<lDescending>]) --> cString


      Note:  This version of CA-Clipper Tools contains an optional
      parameter that previous versions did not include.

   $ARGUMENTS$
      <cString>  [@]  Designates the character string that is sorted.

      <nElementlength>  Designates the length of the sorting element.  The
      default value is for 1 character.

      <nComparisonlength>  Designates the number of characters that a
      sorting element takes into account in a comparison.  The default value
      is <nElementlength> characters.

      <nIgnore>  Designates the number of characters at the beginning of
      the <cString> that should not be taken into account in the sorting.

      <nElementPosition>  Designates an offset.  This parameter designates
      from what position within the sorting element the comparison is made.
      The default value is the first character (0).

      <nSortlength>  Designates the length of the sort area relative to
      the <nIgnore> offset.

      <lDescending>  Designates whether the function sorts in ascending or
      descending order.  If this parameter is not specified, or is specified
      as .F., then the function sorts in ascending order.  When specified as
      .T., the function sorts in descending order.  The default value is .F..

   $RETURNS$
      The sorted <cString> is returned.

   $DESCRIPTION$
      CharSort() allows you to sort the characters in a string in many
      different ways.  Everything from the length of the sorting elements to
      the sort sequences is taken into account.

   $NOTES$
      ■  Invalid parameters return a null string.

      ■  The function uses a fast sort algorithm.

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Sort characters in a string according to their ASCII code:

         ? CharSort("qwert")                           // "eqrtw"

      ■  Sort 2-byte length elements:

         ? CharSort("qwert", 2)                        // "erqwt"

      ■  Sort 2-byte length elements, but only use the first character
         for the comparison:

         ? CharSort("bla4a3a2a1", 2, 1)                // "a2a1a3a4b1"

      ■  Sort individual characters, excluding the first three:

         ? CharSort("XXXqwert", 1, 1, 3)               // "XXXeqrtw"

      ■  Sort paired sequences for the entire string, where only the
         second character within each sequence is used:

         ? CharSort("bla4a3a2a1", 2, 1, 0, 1)          // "a1b1a2a3a4"

      ■  Sort only the first four characters within a string:

         ? CharSort("384172852", 1, 1, 0, 0, 4)        // "134872852"

      ■  Sort in descending order:

         ? CharSort("qwert", .T.)                      // "wtrqe"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharSpread()
   $ONELINER$
      Expands a string at the tokens
   $SYNTAX$
      CharSpread(<cString>,<nLength>,
         [<cCharacter|nCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  Designates a character string that is expanded with
      spaces or <cCharacter>|<nCharacter> characters to <nLength> length.

      <nLength>  Designates the length of the return string.

      <cCharacter|nCharacter>  Designates the fill character and token
      delimiter.  It can be a numeric value or a character.  If it is a
      numeric value, it must be between 0 and 255.  The default value is a
      space Chr(32).

   $RETURNS$
      CharSpread() returns the expanded string.

   $DESCRIPTION$
      CharSpread() expands a string to a preset length.  However, it behaves
      differently than the Expand() function.

      CharSpread() uses <cCharacter|nCharacter> as the character to insert
      during the expansion.  The string is expanded between tokens delimited
      by this character up to the length specified by <nLength>.  This is
      similar to full justification in a text editor.

   $NOTES$
      ■  Previously existing fill characters <cCharacter|nCharacter>
         are not taken into account in the redistribution (see examples).  If
         this procedure is not satisfactory to you, then you can call the
         CharOne() for the string before you call CharSpread().

   $EXAMPLES$
      For clarity, these examples do not contain blanks.

      ■  When the delimiter does not appear in the string, no expansion
         takes place:

         ? CharSpread("123456", 20, ".")          // "123456"

      ■  This example shows a numeric code for the (".") character:

         ? CharSpread("1.2.3.4.5.6", 20, 46)      // "1...2...3..4...5...6"

      ■  In this example, the fill character is already there:

         ? CharSpread("11..22..33", ".")          // "11.......22.......33"
         ? CharSpread("11.22........33", 20, ".")
                                                  // "11....22..........33"

   $PLATFORMS$
      DOS
   $SEEALSO$
      Expand(), CharOne()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharSwap()
   $ONELINER$
      Exchanges all adjoining characters in a string
   $SYNTAX$
      CharSwap(<cString>) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the character string that is processed.

   $RETURNS$
      The processed character string is returned.

   $DESCRIPTION$
      CharSwap() takes all neighboring characters in <cString> and exchanges
      them.  As a result, bytes in even positions are exchanged for those in
      odd positions.

      CharSwap() is very important when you use string integers generated by
      the CA-Clipper I2Bin() function that must be saved or sorted.  The
      CharSwap() exchange must be carried out prior to calling CharSort()
      (low/high ordering of 16-bit integers) to achieve an accurate result.

   $NOTES$
      ■  Since the length of the character string is not changed, a
         call by reference is recommended.  This increases the speed of the
         function.

      ■  The value this function returns can be suppressed by setting
         CSetRef() to save working memory space.

   $EXAMPLES$
      ■  Exchange characters that can be displayed:

         ? CharSwap("0123456789")               // "1032547698"

      ■  Work with I2BIN:

         ? I2BN(256)                            // 00000000 00000001
         ? I2Bin(1)                             // 00000001 00000000
         ? I2Bin(256) > I2Bin(1)                          // .F.
         ? CharSwap(I2Bin(256)) > CharSwap(I2Bin(1))      // .T.

   $PLATFORMS$
      DOS
   $SEEALSO$
      WordSwap(), CharSort(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharUnpack()
   $ONELINER$
      Decompresses (unpacks) a string
   $SYNTAX$
      CharUnpack(<idPackCharacterstring>) --> cString

   $ARGUMENTS$
      <idPackCharacterstring>  Designates a string that was previously
      compressed with the CharPack() function.

   $RETURNS$
      CharUnpack() returns an uncompressed string.

   $DESCRIPTION$
      This function unpacks strings compressed by the CharPack() function.
      Notice that the related pack method is automatically recognized.  Since
      we presuppose that the CharUnpack() string parameter was compressed
      previously with CharPack(), it is assured that the returned string is
      not longer than the maximum permitted under CA-Clipper.

   $EXAMPLES$
      The CharUnpack() function recreates a string:

      ? CharUnpack(CharPack("AAAAAAAAAAAA"))   // "AAAAAAAAAAAA"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharPack()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharXor()
   $ONELINER$
      Joins corresponding ASCII codes of paired strings using an exclusive OR operation
   $SYNTAX$
      CharXor(<cString1>,<cString2>) --> cString

   $ARGUMENTS$
      <cString1>  [@]  Designates the character string on which the
      exclusive OR (XOR) operation is performed.

      <cString2>  Designates the characters that are joined using XOR with
      <cString1>.

   $RETURNS$
      The processed <cString1> is returned.

   $DESCRIPTION$
      The function performs an exclusive OR operation on each character in
      <cString1> with the corresponding characters in <cString2>.

      You can use CharXor() to code passwords and text.  The advantage of this
      function is that it can be used for both encryption and decryption.

   $NOTES$
      ■  If both character strings are the same length, then the first
         byte of <cString1> is linked with the first byte of <cString2>, and
         the second byte of <cString1> is linked with the second byte of
         <cString2>, etc..  If <cString2> is shorter than <cString1>, then
         when the last byte of <cString2> is reached, it continues with the
         first byte of <cString2>.  However, if <cString1> is shorter than
         <cString2>, the process terminates at the end of <cString1>.

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save room in working memory.

   $EXAMPLES$
      ■  CharXor() returns the coded value once.  The password should
         be as long as possible:

         ? CharXor("Secret", "Password")

      ■  Call CharXor() twice to return the initial value:

         ? CharXor(CharXor("Secret", "Password"), "Password")

      ■  A double encryption is also possible:

         ? CharXor(CharXor("Secret", "Password"), "A12B44")

   $PLATFORMS$
      DOS
   $SEEALSO$
      Crypt(), CharAnd(), CharOr(), CharNot(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Checksum()
   $ONELINER$
      Calculates the checksum for a character string (algorithm)
   $SYNTAX$
      Checksum(<cString>) --> nCheckSum

   $ARGUMENTS$
      <cString>  Designates the character string for which the checksum is
      computed.

   $RETURNS$
      The number returned is the checksum for the <cString>.

   $DESCRIPTION$
      Checksum() calculates the checksum for a character string.  This
      checksum can determine if a character string has been changed, or
      transmitted or typed incorrectly.  Checksum() is position dependent, so
      the likelihood of error recognition is greater than with AsciiSum().

   $NOTES$
      ■  The return value is a 32-bit whole number.

      ■  The checksum cannot be used for definitive coding of data
         because the calculated sum for two different character strings could
         be the same.  For example, the checksum for "PASTETEN" and "PERSONAL"
         are identical.

      ■  If character strings have different lengths, the strings
         cannot have identical values.

   $EXAMPLES$
      ■  In this example, AsciiSum() would have returned identical
         results:

         ? Checksum("abc")               // Result: 247334
         ? Checksum("cba")               // Result: 246822

      ■  Different character strings of identical length can produce
         identical results:

         ? Checksum("PASTETEN")          // Result: 530020
         ? Checksum("PERSONAL")          // Result: 530020

      ■  A null string returns a result of 0:

         ? Checksum("")                  // Result: 0

   $PLATFORMS$
      DOS
   $SEEALSO$
      AsciiSum()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CountLeft()
   $ONELINER$
      Counts a particular character at the beginning of a string
   $SYNTAX$
      CountLeft(<cString>,[<cCharacter|nCharacter>])
         --> nNumber

   $ARGUMENTS$
      <cString>  Designates the character string in which the
      <cCharacter|nCharacter> character is counted.

      <cCharacter|nCharacter>  Designates the character at the beginning
      of the <cString> that is counted.  The default value is a space,
      Chr(32).

   $RETURNS$
      CountLeft() returns the number of <cCharacter|nCharacter> characters
      that appear in an uninterrupted sequence at the beginning of <cString>.

   $DESCRIPTION$
      While RemLeft() removes leading characters from the <cString>,
      CountLeft() only determines the number of leading <cCharacter|
      nCharacter> characters appearing in an uninterrupted sequence at the
      beginning of the <cString>.

   $EXAMPLES$
      ■  Count the blanks:

         ? CountLeft("   123")               // Result: 3

      ■  Count the "." characters:

         ? CountLeft("..4.123", ".")         // Result: 2

      ■  In this example, there is nothing to count:

         ? CountLeft("123456")               // Result: 0

   $PLATFORMS$
      DOS
   $SEEALSO$
      CountRight()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CountRight()
   $ONELINER$
      Counts a particular character at the end of a string
   $SYNTAX$
      CountRight(<cString>,[<cCharacter|nCharacter>]) --> nNumber

   $ARGUMENTS$
      <cString>  Designates the character string in which the
      <cCharacter|nCharacter> character is counted.

      <cCharacter|nCharacter>  Designates the character at the end of the
      <cString> that is counted.  The default value is a space, Chr(32).

   $RETURNS$
      CountRight() returns the number of <cCharacter|nCharacter> characters
      that appear in an uninterrupted sequence at the end of the <cString>.

   $DESCRIPTION$
      While RemRight() removes trailing characters from the <cString>,
      CountRight() only determines the number of trailing <cCharacter|
      nCharacter> characters appearing in an uninterrupted sequence at the end
      of the <cString>.

   $EXAMPLES$
      ■  Count the blanks:

         ? CountRight("abc   ")            // Result: 3

      ■  Count the "." characters:

         ? CountRight("abc.d..", ".")      // Result: 2

      ■  In this example, there are no spaces to count:

         ? CountRight("123456")             // Result: 0

   $PLATFORMS$
      DOS
   $SEEALSO$
      CountLeft()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Crypt()
   $ONELINER$
      Encrypts and decrypts a string
   $SYNTAX$
      Crypt(<cString>,<cKeystring>) --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is that is encrypted.

      <cKeystring>  Designates the password with which the string is
      encrypted.

   $RETURNS$
      Crypt() returns the encrypted string.

   $DESCRIPTION$
      In contrast to a simple lock using CharXor(), this function has a random
      number generator that uses a "random seed" algorithm.  This makes the
      lock even more secure, at least as long as this additional algorithm is
      not known.  Of course, this additional security costs some computer
      time.

      Encrypted character strings can be decrypted with the same password.
      With multiple encryptions, the decryption must occur in reverse order.

   $NOTES$
      ■  Passwords should be as long as possible -- a minimum of six
         characters, preferably more.

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  This example shows a simple encryption:

         cVar:= Crypt("CLIPPER", "CA")

      ■  This example shows the decryption:

         ? Crypt(cVar, "CA")         // "CLIPPER"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharXor(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSetAtMupa()
   $ONELINER$
      Determines the setting of the multi-pass mode for ATXXX() functions
   $SYNTAX$
      CSetAtMupa(<lNewMode>) --> lOldMode

   $ARGUMENTS$
      <lNewMode>  Designates the setting for the multi-pass switch for all
      AT functions.  The default value (.F.) sets the multi-pass switch to off

   $RETURNS$
      If <lNewMode> is not specified, the current setting is returned.  If
      <lNewMode> is specified, CSetAtMupa() returns the previous setting.

   $DESCRIPTION$
      CSetAtMupa() sets a switch, internal to CA-Clipper Tools, that affects
      the operation of several other CA-Clipper Tools functions.  These
      functions permit targeted, extremely flexible substring manipulation.
      The affected functions are:

            AtNum()      AfterAtNum()    BeforAtNum()

            AtRepl()     NumAt()         AtAdjust()

            WordToChar() WordRepl()

      The CSetAtMupa() function sets the multi-pass mode on or off for these
      functions.

   $NOTES$
      ■  The default setting for CSetAtMupa() is .F., indicating that
         the multi-pass mode is off.

   $EXAMPLES$
      Switch the multi-pass mode on and save the previous setting:

      lOldMupa  :=  CSetAtMupa(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      AtNum(), AfterAtNum(), BeforAtNum(), AtRepl()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSetRef()
   $ONELINER$
      Determines whether or not reference sensitive functions return a value
   $SYNTAX$
      CSetRef([<lNewSwitch>]) --> lOldSwitch

   $ARGUMENTS$
      <lNewSwitch>  Designates whether the return value is suppressed for
      specified functions.  When this parameter is .T., it suppresses the
      return value of the functions listed below.  When the parameter is .F.
      (default value), these functions return a value.

   $RETURNS$
      If no parameter is specified, the function returns the current setting.
      If a parameter is specified, the function returns the previous setting.

   $DESCRIPTION$
      A series of CA-Clipper Tools functions enable you to pass parameters by
      reference.  After executing the function, the passed parameter already
      contains the result.  However, each of these functions also returns this
      result as a value.  A copy of the passed string exists for a short time
      in working memory, but it is invisible to you.  In the worst possible
      case, two adjoining memory blocks would require up to 64 kB.

      This behavior can be influenced by implementing CSetRef(.T.).  Then the
      group of affected string functions no longer return a value, which can
      save you up to 64k of memory with large strings.

            Functions affected by CSetRef():

            AddAscii()   Blank()         CharAdd()

            CharAnd()    CharMirr()      CharNot()

            CharOr()     CharRelRep()    CharRepl()

            CharSort()   CharSwap()      CharXor()

            Crypt()      JustLeft()      JustRight()

            PosChar()    PosRepl()       RangeRepl()

            ReplAll()    ReplLeft()      ReplRight()

            TokenLower() TokenUpper()    WordRepl()

            WordSwap()

   $NOTES$
      ■  If, in spite of having CSetRef(.T.), you need one of the
         previously listed functions to return a value, then the target
         variable contains .F. instead of the anticipated string.

   $EXAMPLES$
      ■  Here is how CSetRef() is set to .F.:

         CSetRef(.F.)
         cStr1  :=  "HAGBDCFE"
         cStr2  :=  CharSort(@cStr1)
         ? cStr1, cStr2        // "ABCDEFGH" - cStr1,cStr2 are identical

      ■  Here is how CSetRef() is set to .T.:

         CSetRef(.T.)

         cStr1  :=  "HAGBDCFE"
         cStr2  :=  CharSort(@cStr1)
         ? cStr1               // "ABCDEFGH" - Sort cStr1
         ? cStr2               // .F.

      ■  Determine when memory will be needed:

         cStr1  :=  Space(32000)       // Create large string

         CSetRef(.F.)
         CharSort(@cStr1)              // Additional 32000 bytes

         CSetRef(.T.)
         CharSort(@cStr1)              // Needs no additional memory

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Expand()
   $ONELINER$
      Expands a string by inserting characters
   $SYNTAX$
      Expand(<cString>,[<nNumber>],[<cCharacter|    nCharacter>])
         --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

      <nNumber>  Designates the number of the <cCharacter|nCharacter>
      characters that are inserted between each character in the <cString>.
      The default value is one character.

      <cCharacter|nCharacter>  Designates the character that is inserted
      between each character in <cString>.  The default value is a space,
      Chr(32).

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      Expand() can be used to justify text output, although the text is stored
      normally.  This saves memory capacity with text constants or in
      databases.

   $NOTES$
      ■  Expansion only takes place when the <cString> contains at
         least two characters.

      ■  To fill out a character string at the ends, use the PadLeft()
         and PadRight() functions.

   $EXAMPLES$
      ■  Use the default value and expand with one space:

         ? Expand("123456")               // "1 2 3 4 5 6"

      ■  Expand with two spaces:

         ? Expand("123456", 2)            // "1  2  3  4  5  6"

      ■  Expand with a ".":

         ? Expand("123456", ".")          // "1.2.3.4.5.6"

      ■  Expand with two "."s:

         ? Expand("123456", 2, ".")       // "1..2..3..4..5..6"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharSpread(), PadLeft(), PadRight()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      JustLeft()
   $ONELINER$
      Moves characters from the beginning to the end of a string
   $SYNTAX$
      JustLeft(<cString>,[<cCharacter|nCharacter>])
         --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the string that is processed.

      <cCharacter|nCharacter>  Designates the character that is moved from
      the beginning of the <cString> to the end.  The default value is a
      space, Chr(32).

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      JustLeft() moves the characters specified in <cCharacter|nCharacter>
      from the beginning of a character string to the end.  Then the remaining
      text in the character string is left justified, without affecting the
      length.

   $NOTES$
      ■  If the <cCharacter|nCharacter> parameter is not specified,
         spaces are automatically moved.

      ■  The return value for this function can be suppressed by
         implementing CSetRef() to save room in working memory.

   $EXAMPLES$
      ■  Move the blanks:

         ? JustLeft("   123")              // "123   "

      ■  Move the "." character:

         ? JustLeft("..123"," ".)          // "123.."

   $PLATFORMS$
      DOS
   $SEEALSO$
      JustRight(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      JustRight()
   $ONELINER$
      Moves characters from the end of a string to the beginning
   $SYNTAX$
      JustRight(<cString>,[<cCharacter|nCharacter>])
         --> cString

   $ARGUMENTS$
      <cString>  [@] Designates the string that is processed.

      <cCharacter|nCharacter>  Designates the character that is moved from
      the end of the <cString> to the beginning.  The default value is a
      space, Chr(32).

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      JustRight() moves the characters specified in <cCharacter| nCharacter>
      from the end of a character string to the beginning.  Then the remaining
      text in the character string is right justified, without affecting the
      length.

   $NOTES$
      ■  If the <cCharacter|nCharacter> parameter is not specified,
         spaces are automatically moved.

      ■  The return value for this function can be suppressed by
         implementing CSetRef() to save room in working memory.

   $EXAMPLES$
      ■  Move the blanks:

         ? JustRight("123   ")           // "   123"

      ■  Move the "." character:

         ? JustRight("123..", ".")       // "..123 "

   $PLATFORMS$
      DOS
   $SEEALSO$
      JustLeft(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Like()
   $ONELINER$
      Compares character strings using wildcard characters
   $SYNTAX$
      Like(<cString1>,<cString2>) --> lEqual

   $ARGUMENTS$
      <cString1>  Designates the wildcard string for comparison.  All
      wildcards must be in this character string.

      <cString2>  Designates the string to compare to <cString1>.

   $RETURNS$
      Like() returns .T. when, after taking wildcards into account, both
      character strings are equal.

   $DESCRIPTION$
      This function allows you to compare two character strings with one
      another, where the first can contain wildcard characters.  This is
      similar to the way wildcard characters are used in conjunction with DOS
      commands but not identical.  Any single character matches a "?" in the
      first string (see examples).  The "*" within <cString1> can be placed
      anywhere and matches multiple characters.  You can also use multiple
      "*".

   $NOTES$
      ■  You can also use wildcard characters in conjunction with an
         array of other string functions by using the SetAtLike() switch, but
         only for the "?".

   $EXAMPLES$
      ■  This example shows differences from DOS:

         Dir XYZ?.DBF                     // shows XYZ.DBF and XYZ1.DBF

         ? Like("XYZ?", "XYZ")            // .F.
         ? Like("XYZ?", "XYZ1")           // .T.

      ■  This example shows other combinations:

         ? Like("*OG.*", "PROG.PRG")      // .T.
         ? Like("*OG.*", "LOG.PRG")       // .T.
         ? Like("*R*T*", "PROTO")         // .T.
         ? Like("*R*T*?", "PROTO")        // .F.
         ? Like("*R*T*?", "PROTO2")       // .T.

      ■  Use wildcards in the first parameter only:

         ? Like("*PER", "CLIPPER")        // .T.
         ? Like("CLIPPER", "*PER")        // .F.

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetAtLike()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      LToC()
   $ONELINER$
      Converts a logical value into a character
   $SYNTAX$
      LToC([<lValue>]) --> cCharacter

   $ARGUMENTS$
      <lValue>  Designates the logical value that is converted. The
      default value is .F..

   $RETURNS$
      The character returned corresponds to the logical value specified in the
      parameter.

   $DESCRIPTION$
      In contrast to the LToN() function, which converts a logical value into
      a number, LToC() returns a value for the type character string.  This
      can be particularly helpful with combined index keys.

   $EXAMPLES$
      ■  Without parameters, .F. is assumed:

         ? LToC()               // "F"

      ■  Return a letter that corresponds to the specified logical
         value:

         ? LToC(.F.)            // "F"

         ? LToC(.T.)            // "T"

      ■  Other functions can return the logical value:

         ? LToC(Deleted())      // "T" or "F"

   $PLATFORMS$
      DOS
   $SEEALSO$
      LToN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MaxLine()
   $ONELINER$
      Finds the longest line within a string
   $SYNTAX$
      MaxLine(<cString>) --> nLength

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

   $RETURNS$
      The function returns the maximum line length necessary to display the
      <cString> text without automatic line breaks.

   $DESCRIPTION$
      MaxLine() looks for the longest line within a character string.  This
      allows you to determine the required width for a window to display text
      (MEMO fields).  In this way the text can be displayed without additional
      line breaks.

   $NOTES$
      ■  With the exception of the carriage return and the line feed,
         this function treats all characters as printable with a width of 1.
         If the <cString> text contains tabs, then you must first use the
         TabExpand() function to expand the tabs to spaces.

   $EXAMPLES$
      A function, based on the maximum line length, automatically performs a
      suitable call of MemoEdit():

      FUNCTION SHOWMEMO(cMemo)

      LOCAL cMessage, nHeight, nWidth

         nHeight   :=  Min(NumLine(cMemo), MaxRow() -1)
         nWidth    :=  Min(MaxLine(cMemo), MaxCol() -1)

         IF nWidth = 0
            cMessage  :=  "The memo field is empty"
         ELSE
            cMessage  :=  ""
            @ 0, 0 TO nHeight +1, nWidth +1 DOUBLE
            MemoEdit(cMemo, 1, 1, nHeight, nWidth, .F.)
         ENDIF
         RETURN(cMessage)

   $PLATFORMS$
      DOS
   $SEEALSO$
      TabExpand(), NumLine()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumAt()
   $ONELINER$
      Counts the number of occurrences of a sequence within a string
   $SYNTAX$
      NumAt(<cSearchFor>,<cString>,[<nIgnore>]) --> nNumber

   $ARGUMENTS$
      <cSearchFor>  Designates the search string.

      <cString>  Designates the string to search.

      <nIgnore>  Designates the number of characters that are excluded
      from the search.  The default value ignores none.

   $RETURNS$
      The function returns a value that specifies how frequently the
      <cSearchFor> sequence was found in the <cString>.

   $DESCRIPTION$
      NumAt() determines how often a particular <cSearchFor> appears within
      <cString>.  When you use <nIgnore> you can lock out a number of
      characters at the beginning of the <cString> and keep them out of the
      search.

      The setting for CSetAtMupa() impacts your results.  The character string
      is searched from the left for each occurrence of the <cSearchFor>
      string.  If CSetAtMupa() is .F., then the search continues after the
      last character of the found sequence. If CSetAtMupa() is .T., then the
      search continues after the first character of the found sequence.

   $NOTES$
      ■  By implementing SetAtLike(), wildcard characters can be used
         within the search expression.

   $EXAMPLES$
      ■  Count from the first position:

         ? NumAt("ab", "abcdeabc")            // Result: 2

      ■  Count from the second position.  <nIgnore> specifies that one
         space is to be skipped:

         ? NumAt("ab", "abcdeabc", 1)         // Result: 1

      ■  This example shows the impact of CSetAtMupa() when counting
         the string "aa" within the <cString> string:

         CSetAtMupa(.F.)                      // Off
         ? NumAt("aa", "aaaab")               // Result: 2

         CSetAtMupa(.T.)                      // On
         ? NumAt("aa", "aaaab")               // Result: 3

      ■  Examples for the use of SetAtLike() can be found under the
         corresponding function description.

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetAtMupa(), SetAtLike()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumLine()
   $ONELINER$
      Determines the number of lines required for string output
   $SYNTAX$
      NumLine(<cString>,[<nLineLength>]) --> nNumber

   $ARGUMENTS$
      <cString>  Designates the character string that is processed.

      <nLineLength>  Designates the length of an output line.  The default
      value is 80 characters.

   $RETURNS$
      NumLine() returns the number of lines required for text output.

   $DESCRIPTION$
      NumLine() can determine the number of lines that are required to output
      a MEMO field.  The return value relates to a line length that is
      determined by <nLineLength>.

   $NOTES$
      ■  With the exception of the carriage return and the line feed,
         this function treats all characters as printable with a width of 1.
         If the <cString> text contains tabs, then you must first use the
         TabExpand() function to expand the tabs to spaces.

   $EXAMPLES$
      ■  A null string occupies one line:

         ? NumLine("")                                       // 1

      ■  A string one character longer also occupies one line:

         ? NumLine("-")                                      // 1

      ■  80 characters, at a line width of 80 characters (default
         value), occupy two lines:

         ? NumLine(Replicate("-", 80))                       // 2

      ■  100 characters, at a line width of 30 characters, occupy 4
         lines:

         ? NumLine(Replicate("-", 100), 30)                  // 4

      ■  A line feed is also handled correctly -- an extra line is
         required:

         ? NumLine("-", +crlf)                               // 2
         ? NumLine(Replicate("-", 100) +crlf, 30)            // 5

   $PLATFORMS$
      DOS
   $SEEALSO$
      TabExpand(), MaxLine()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumToken()
   $ONELINER$
      Determines the number of tokens in a string
   $SYNTAX$
      NumToken(<cString>,[<cDelimiter>],[<nSkipWidth>])
         --> nNumber

   $ARGUMENTS$
      <cString>  Designates the string that is passed.

      <cDelimiter>  Designates the delimiter list used by the passer.

      <nSkipWidth>  Designates after what number of delimiter characters
      or sequences to count a token.  This is helpful for counting empty
      tokens.  The default value indicates that empty tokens are not taken
      into account.

   $RETURNS$
      The number of tokens contained in the <cString> is returned.

   $DESCRIPTION$
      Use NumToken() to determine how many words (or tokens) are contained in
      the character string.  The function uses the following list of
      delimiters as a standard:

      CHR 32, 0, 9, 10, 13, 26, 32, 138, 141

      and the characters ,.;:!?/\<<>>()^#&%+-*

      The list can be replaced by your own list of delimiters, <cDelimiter>.
      Here are some examples of useful delimiters:

      Table 4-3: Recommended Delimiter Sequences
      <table>
          Description         <cDelimiter>

          Pages               Chr(12)(Form Feed)
          Sentences           ".!?"
          File Names          ":\."
          Numerical strings   ",."
          Date strings        "/."
          Time strings        ":."
         </table>

      The skip value designates the number of characters after which a token
      is counted again.  This also allows empty tokens, like blanks within a
      string, to be counted.

   $EXAMPLES$
      ■  A character string is searched using the standard delimiter
         list:

         ? NumToken("Good Morning!")      // Result: 2

      ■  Your own list of delimiters can be specified for particular
         reasons.  Since the delimiter list for the following example only
         contains the characters ".!?", the result is 3.

         ? NumToken("Yes!  That's it. Maybe not?", ".!?")

      ■  This example shows how to count empty tokens.  Parameters
         separated by commas are counted, but some of the parameters are
         skipped.  A token is counted after at least one delimiter (comma):

         String  :=  "one,two,,four"
         ? NumToken(String, ", ", 1)      // Result: 4

   $PLATFORMS$
      DOS
   $SEEALSO$
      TOKEN(), AtToken(), TokenUpper(), TokenLower()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PadLeft()
   $ONELINER$
      Pads a string on the left to a particular length
   $SYNTAX$
      PadLeft(<cString>,<nLength>,[<cCharacter|
         <nCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

      <nLength>  Designates the new length for <cString>.

      <cCharacter|nCharacter>  Designates the character with which the
      beginning of the <cString> string is filled.  The default value is a
      space, Chr(32).

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      PadLeft() allows you to pad the beginning of character strings with
      characters, in accordance with a length specification.  Spaces or any
      other characters you choose can be used.

   $NOTES$
      ■  The function works like the CA-Clipper Right() function when
         <nLength> is shorter than the length of <cString>.  If <nLength> is
         negative, PadLeft() returns a null string.

      ■  When the <cCharacter|nCharacter> parameter is not specified,
         spaces are automatically used for padding.

   $EXAMPLES$
      ■  The function works like Right():

         ? PadLeft("123456", 4)              // "3456"

      ■  Pad the left with spaces:

         ? PadLeft("123456", 8)              // "  123456"

      ■  Pad the left with the "." character:

         ? PadLeft("123456", 8, ".")         // "..123456"

   $PLATFORMS$
      DOS
   $SEEALSO$
      PadRight()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PadRight()
   $ONELINER$
      Pads a string on the right to a particular length
   $SYNTAX$
      PadRight(<cString>,<nLength>,[<cCharacter|
         nCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

      <nLength>  Designates the selected new length for <cString>.

      <cCharacter|nCharacter>  Designates the character with which the
      beginning of the <cString> string is filled.  The default value is a
      space, Chr(32).

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      PadRight() allows you to pad the end of a character string with
      characters, in accordance with a length specification.  Spaces or any
      other characters that you choose can be used.

   $NOTES$
      ■  The function works like the CA-Clipper Left() function when
         <nLength> is shorter than the length of <cString>.  If <nLength> is
         negative, PadRight() returns a null string.

      ■  When the <cCharacter|nCharacter> parameter is not specified,
         spaces are automatically used for padding.

   $EXAMPLES$
      ■  The function works like Left():

         ? PadRight("123456", 4)              // "1234"

      ■  Pad the right with spaces:

         ? PadRight("123456", 8)              // "123456  "

      ■  Pad the right with the "." character:

         ? PadRight("123456", 8, ".")         // "123456.."

   $PLATFORMS$
      DOS
   $SEEALSO$
      PadLeft()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosAlpha()
   $ONELINER$
      Determines the position of the first alphabetic character in a string
   $SYNTAX$
      PosAlpha(<cString>,[<lMode>],[<nIgnore>])
         --> nPosition

   $ARGUMENTS$
      <cString>  Designates the string that is searched.

      <lMode>  Designates how the function searches for the first
      alphabetic character in a string.  The default value (.F.) searches for
      the first alphabetic character.

      <nIgnore>  Designates the number of characters at the beginning of
      the character string that are excluded from the search.  The default
      value excludes none (0).

   $RETURNS$
      The value returned is the position of the first alphabetic character in
      <cString>.  If no alphabetic character is located, the function returns
      0.

   $DESCRIPTION$
      Starting from the left, PosAlpha() searches for the first alphabetic
      character in <cString> that corresponds to the first character that can
      be changed by the CA-Clipper Lower() or Upper() functions.  If <lMode>
      is .T., then the function searches for the first non-alphabetic
      character.  The <nIgnore> parameter can exclude a specific number of
      characters at the beginning of the <cString> from the search.

   $NOTES$
      ■  Notice that characters located when <lMode> is .T. are always
         numbers or special characters, but are never alphabetic characters.

      ■  This function works in conjunction with the NATION module
         because different languages use different characters to represent
         their alphabets.

   $EXAMPLES$
      cString  :=  "UKLM123"
      ? PosAlpha(cString)                 // Result: 1
      ? PosAlpha(cString, .T.)            // Result: 5
      ? PosAlpha(cString, .F., 2)         // Result: 3

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosLower(), PosUpper(), PosRange()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosChar()
   $ONELINER$
      Replaces an individual character at a particular position within a character string
   $SYNTAX$
      PosChar(<cString>,<cCharacter|nCharacter>,
         [<nPosition>]) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the character string within which the
      individual character <cCharacter|nCharacter> is substituted.

      <cCharacter|nCharacter>  Designates an individual character or a
      numeric ASCII value from 0 to 255.

      <nPosition>  Designates the position at which the character is
      substituted.  The default value is the last position in <cString>.

   $RETURNS$
      The string returned is the <cString> with a <cCharacter|nCharacter>
      character in the selected position.

   $DESCRIPTION$
      PosChar() allows you to replace an individual character within a string
      without having to split the string.  Since this character is only
      substituted at the designated position within <cString>, the string that
      is modified can be passed by reference.

   $NOTES$
      ■  The value returned by this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Substitute a character at position 3:

         ? PosChar("ABCDEF", "X", 3)   // "ABXDEF"

      ■  Substitute a character in the last position:

         ? PosChar("ABCDEF", "X")      // "ABCDEX"

      ■  Pass the string by reference:

         CSetRef(.T.)                  // Suppress return value
         cVar  := "ABCDEF"
         PosChar(cVar, "X")
         ? cVar                        // "ABCDEX"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosDel()
   $ONELINER$
      Deletes characters at a particular position in a string
   $SYNTAX$
      PosDel(<cString>,[<nStartPos>],[<nNumber>])
         --> cString

   $ARGUMENTS$
      <cString>  Designates the character string from which the characters
      are deleted.

      <nStartPos>  Designates from which position the deletion begins.

      <nNumber>  Designates the number of characters to delete.

   $RETURNS$
      The modified string is returned.

   $DESCRIPTION$
      This function permits the removal of <nNumber> of characters from
      <cString>, beginning from <nStartPos>.

   $NOTES$
      ■  <nStartPos> is optional.  If this parameter is not specified,
         then PosDel() begins at the end of the <cString> and deletes the
         specified number (<nNumber>) of characters.

   $EXAMPLES$
      ■  Delete two characters from a string:

         ? PosDel("Parameter", 3, 2)         // "Pameter"

      ■  Delete the last two characters:

         ? PosDel("Parameter", , 2)          // "Paramet"

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosIns(), PosRange()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosDiff()
   $ONELINER$
      Finds the first position from which two strings differ
   $SYNTAX$
      PosDiff(<cString1>,<cString2>,[<nIgnore>])
         --> nPosition

   $ARGUMENTS$
      <cString1> and <cString2>  Designate the two character strings
      that are compared.

      <nIgnore>  Designates how many characters at the beginning of the
      character strings are excluded from the search.  The default value
      excludes none (0).

   $RETURNS$
      PosDiff() returns the first position where <cString1> and <cString2>
      differ.  If both character strings are equal, then the function returns
      0.

   $DESCRIPTION$
      PosDiff() compares two strings and determines from which position the
      first difference occurs.  The <nIgnore> parameter allows you to exclude
      a particular number of characters from the beginning of both character
      strings from the search.

   $NOTES$
      ■  Character strings of different lengths can be compared with
         each other (see examples).

   $EXAMPLES$
      ■  This example compares two strings of the same length:

         cString1  :=  "X23AB$/A"
         cString2  :=  "X23A8$/A"
         ? PosDiff(cString1, cString2)           // Result: 5

      ■  Two strings of different lengths can also be compared:

         ? PosDiff("AB", "ABC")                  // Result: 3

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosEqual()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosEqual()
   $ONELINER$
      Finds the first position at which two strings are the same
   $SYNTAX$
      PosEqual(<cString1>,<cString2>,[<nCompare>],
         [<nIgnore>]) --> nPosition

   $ARGUMENTS$
      <cString1> and <cString2>  Designate the two character strings
      that are compared.

      <nCompare>  Designates the number of characters that must be the
      same.  The default value is the length of the shorter string.

      <nIgnore>  Designates the number of characters that are disregarded
      at the beginning of the search.  The default value is none.

   $RETURNS$
      PosEqual() returns the position from which the two character strings are
      the same for <nCompare> characters.  If no corresponding agreement is
      found, the function returns 0.

   $DESCRIPTION$
      PosEqual() allows you to determine at which point two strings agree.
      The length of this agreement is represented by <nCompare>.  If not
      specified, <nCompare> defaults to the length of the shorter string.

      Additionally, the <nIgnore> parameter lets you specify a particular
      number of characters that are excluded from the start of the strings
      during the comparison.

   $EXAMPLES$
      ■  In this example, there is no agreement to the end of the
         string:

         cString1   :=  "ABCDEFGHI"
         cString2   :=  "XYZDEKLMN"
         ? PosEqual(cString1, cString2)                  // Result: 0

      ■  This example shows the agreement of at least two characters:

         ? PosEqual(cString1, cString2, 2)               // Result: 4

      ■  This example shows a single character agreement and excludes
         the first four characters:

         ? PosEqual(cString1, cString2, 1, 4)            // Result: 5

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosDiff()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosIns()
   $ONELINER$
      Inserts characters at a particular position within a string
   $SYNTAX$
      PosIns(<cString>,<cInsertstring>,[<nPosition>])
         --> cString

   $ARGUMENTS$
      <cString>  Designates the character string into which characters are
      inserted.

      <cInsertstring>  Designates the new characters that are inserted
      into <cString>.

      <nPosition>  Designates the position where the new characters are
      inserted within <cString>.  The default value inserts the characters in
      front of the last character.

   $RETURNS$
      PosIns() returns the string with the inserted characters.

   $DESCRIPTION$
      You can use PosIns() to insert characters into an existing character
      string.  The <cInsertstring> characters are inserted into the <cString>
      at the location specified by <nPosition>.

   $NOTES$
      ■  The resulting character string is longer than the original, so
         this function cannot be called by reference.

   $EXAMPLES$
      ■  Insert "123" at position 2:

         ? PosIns("abcdefgh", "123", 2)   // "a123bcdefgh"

      ■  Insert "123" at position 8:

         ? PosIns("abcdefgh", "123", 8)   // "abcdefg123h"

      ■  Give an erroneous position:

         ? PosIns("abcdefgh", "123", 10)  // "abcdefgh"

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosDel(), PosRepl()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosLower()
   $ONELINER$
      Finds the position of the first lower case alphabetic character
   $SYNTAX$
      PosLower(<cString>,[<lMode>],[<nIgnore>])
         --> nPosition

   $ARGUMENTS$
      <cString>  Designates the string that is searched.

      <lMode>  Designates how the function searches for the first lower
      case alphabetic character.  The default value (.F.) searches for the
      first alphabetic character that can be changed by the CA-Clipper
      function Upper().

      <nIgnore>  Designates the number of characters at the beginning of
      the character string that are excluded from the search.  The default
      value excludes none (0).

   $RETURNS$
      The value returned corresponds to the position of the character located.
      When no matching character is found, the function returns 0.

   $DESCRIPTION$
      Starting from the beginning of the string, PosLower() searches for the
      first lower case alphabetic character in <cString>.  If <lMode> is .T.,
      the function searches for the first non-alphabetic character that would
      not be changed by Upper().  The <nIgnore> parameter excludes a specific
      number of characters at the beginning of the <cString> from the search.

   $NOTES$
      ■  Characters located when the <lMode> parameter is designated as
         .T. are not necessarily upper case, alphabetic characters.

      ■  The function works in conjunction with the NATION module
         because different languages use different characters to represent
         their alphabets.

   $EXAMPLES$
      cString  :=  "123ABCuabc"

      ? PosLower(cString)                 // Result: 7
      ? PosLower(cString, .T.)            // Result: 1
      ? PosLower(cString, .F., 7)         // Result: 8

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosAlpha(), PosUpper(), PosRange()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosRange()
   $ONELINER$
      Determines the position of the first character within a given ASCII code range
   $SYNTAX$
      PosRange(<cCharacter1>,<cCharacter2>,<cString>,
         [<lMode>],[<nIgnore>]) --> nPosition

   $ARGUMENTS$
      <cCharacter1> and <cCharacter2>  Designate the first and the
      last character of the character range.

      <cString>  Designates the string within which to search for a
      character in the <cCharacter1> to <cCharacter2> range.

      <lMode>  Designates if the return value is within the specified
      range or outside of the range.  The default value (.F.) searches for the
      first character within the range.

      <nIgnore>  Designates the number of characters at the beginning of
      the character string that are excluded from the search.  The default
      value excludes none (zero).

   $RETURNS$
      The value returned corresponds to the position of the located character.
      If no character is found, the function returns 0.

   $DESCRIPTION$
      Beginning from the left, PosRange() searches for the first character in
      the range <cCharacter1> to <cCharacter2> within <cString>.  If <lMode>
      is specified as .T., then the function searches for the first character
      that is not in the specified range.  This way you could search for
      control characters within a string by specifying <cCharacter1> = Chr(0)
      and <cCharacter2> = Chr(31).

      The <nIgnore> parameter gives you the ability to exclude a particular
      number of characters at the beginning of the <cString> from the search.

   $EXAMPLES$
      ■  Search for the first character in the character string cInput
         that is not a control character:

         cInput  :=  com_Read(1)
         ? PosRange(Chr(0), Chr(31), cInput, .T.)

      ■  Ignore the first 10 characters:

         ? PosRange(Chr(0), Chr(31), cInput, .T., 10)

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosAlpha(), PosLower(), PosUpper(), RangeRepl()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosRepl()
   $ONELINER$
      Replaces one or more characters from a certain position
   $SYNTAX$
      PosRepl(<cString>,<cReplacementstring>,
         [<nStartPos>]) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the character string within which the
      particular characters are replaced.

      <cReplacementstring>  Designates a sequence of characters that,
      starting at <nStartPos>, replace a portion of <cString>.

      <nStartPos>  Designates from which character within <cString> the
      replacement starts.

   $RETURNS$
      PosRepl() returns the modified string.

   $DESCRIPTION$
      When you use PosRepl(), you can replace a range of characters within
      <cString> with another character string <cReplacementstring>.  The new
      characters are exchanged beginning at <nStartPos>.

   $NOTES$
      ■  When the <nStartPos> parameter is not specified, the
         <cReplacementstring> overwrites the end of the string (see examples).

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Starting at position 3, replace three characters with "XXX":

         ? PosRepl("ABCDEFG", "XXX", 3)         // "ABXXXFG"

      ■  Replace the last Len(<cReplacementstring>) characters:

         ? PosRepl("ABCDEFG", "XXX")            // "ABCDXXX"

      ■  The result can be longer than the character string passed.

         ? PosRepl("ABCDEF", "123", 5)          // "ABCD123"
         ? PosRepl("ABCDEF", "123", 6)          // "ABCDE123"

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosIns(), PosDel(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PosUpper()
   $ONELINER$
      Finds the position of the first upper case, alphabetic character
   $SYNTAX$
      PosUpper(<cString>,[<lMode>],[<nIgnore>])
         --> nPosition

   $ARGUMENTS$
      <cString>  Designates the string that is searched.

      <lMode>  Designates how the function searches for the first upper
      case, alphabetic character.  The default value (.F.) searches for the
      first alphabetic character that would be changed by the CA-Clipper
      function Lower().

      <nIgnore>  Designates the number of characters at the beginning of
      the character string that are excluded from the search.  The default
      value excludes none (0).

   $RETURNS$
      The value returned corresponds to the position of the character located.
      When no matching character is found, the function returns 0.

   $DESCRIPTION$
      Starting from the beginning of the string, PosUpper() searches for the
      first upper case, alphabetic character in the <cString> that corresponds
      to the first character that would be changed by the CA-Clipper Lower()
      function.  If <lMode> is .T., the function searches for the first non-
      alphabetic character that would not be changed by Lower().  The
      <nIgnore> parameter can exclude a specific number of characters at the
      beginning of <cString>.

   $NOTES$
      ■  Characters located when the <lMode> parameter is .T. are not
         necessarily lower case, alphabetic characters.

      ■  The function works in conjunction with the NATION module
         because different languages use different characters to represent
         their alphabets.

   $EXAMPLES$
      cString  :=  "123abcUABC"

      ? PosUpper(cString)                 // Result: 7
      ? PosUpper(cString, .T.)            // Result: 1
      ? PosUpper(cString, .F., 7)         // Result: 8

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosAlpha(), PosLower(), PosRange()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RangeRem()
   $ONELINER$
      Deletes characters that are within a specified ASCII code range
   $SYNTAX$
      RangeRem(<cCharacter1>,<cCharacter2>,<cString>)
         --> cResultString

   $ARGUMENTS$
      <cCharacter1> and <cCharacter2>  Designate the first and the
      last character of the character range.

      <cString>  Designates the character string that is edited.

   $RETURNS$
      The function returns the modified character string.

   $DESCRIPTION$
      RangeRem() allows you to delete all characters that are in a particular
      ASCII range.  For example, you could delete all control characters in a
      character string.

      The designated range can run "back to front", meaning <cCharacter2> can
      have a lower value than <cCharacter1>.  In such a case the range extends
      from the larger value to 255 and also from 0 to the smaller value.

   $NOTES$
      ■  Since the length of the character string is changed, passing
         by reference will not work here as it does with RangeRepl().

   $EXAMPLES$
      ■  Delete all control characters:

         cString   :=  RangeRem(0, 31, cString)

      ■  Delete all characters that are not upper case, alpha
         characters:

         cString   :=  RangeRem(91, 64, cString)

   $PLATFORMS$
      DOS
   $SEEALSO$
      RangeRepl()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RangeRepl()
   $ONELINER$
      Replaces characters within a specified ASCII code range with a particular character
   $SYNTAX$
      RangeRepl(<cCharacter1>,<cCharacter2>,<cString>,
         <cReplaceCharacter>) --> cString

   $ARGUMENTS$
      <cCharacter1> and <cCharacter2>  Designate the first and the
      last character of the character range.

      <cString>  [@]  Designates the string that is processed.

      <cReplaceCharacter>   Designates the single character that replaces
      those characters in <cString> that are within the specified range.

   $RETURNS$
      The processed character string is returned.

   $DESCRIPTION$
      All characters that are in a particular range can be replaced by a new
      character.  For example, you could replace all control characters with
      spaces.

      The designated range can also run from "back to front", meaning that
      <cCharacter2> can have a lower value than <cCharacter1>.  In such a case
      the range extends from the larger value to 255 and from 0 to the smaller
      value.

   $NOTES$
      ■  The length of <cString> remains unaffected by this function.

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save room in working memory.

   $EXAMPLES$
      ■  Exchange all control characters in a character string for the
         character ".":

         cString  :=  "a" + Chr(5) + "b" + Chr(9)
         ? RangeRepl(Chr(0), Chr(31), cString, ".")   // "a.b."

      ■  A null string can be specified, instead of Chr(0).  The
         following example exchanges all characters with a code < "A" for the
         number "0".  Of course, the number "0" remains the number "0":

         ? RangeRepl("", Chr(65), "123400", "0")      // "000000"

      ■  All characters in the range "0" to "8" are exchanged for the
         number "9":

         ? RangeRepl("0", "8", "0212 - 78 67 43", "9")
                                                      // "9999 - 99 99 99"

      ■  With the exception of upper case letters, all characters are
         exchanged for dashes.  The optimum call is in conjunction with
         CSetRef():

         CSetRef(.T.)
         cString  :=  "A()&BC/?D"
         RangeRepl(91, 64, @cString, "-")             // "A--BC--D"

   $PLATFORMS$
      DOS
   $SEEALSO$
      PosRepl(), CharRepl(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RemAll()
   $ONELINER$
      Removes particular characters from the beginning and end of a string
   $SYNTAX$
      RemAll(<cString>,[<cCharacter|nCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

      <cCharacter|nCharacter>  Designates the character that is removed
      from the beginning and end of <cString>.  The default value is a space,
      Chr(32).

   $RETURNS$
      RemAll() returns the modified <cString>.

   $DESCRIPTION$
      RemAll() functions exactly like CA-Clipper's AllTrim(), with one
      exception.  While the CA-Clipper function can only remove spaces,
      RemAll() can remove any character you choose.  The character that is
      removed can be specified with the <cCharacter|nCharacter> parameter.

   $NOTES$
      ■  When the <cCharacter|nCharacter> parameter is not specified,
         saces are removed.

   $EXAMPLES$
      ■  Remove the spaces:

         ? RemAll("  1  2  3  ")         // "1  2  3"

      ■  Remove the character "0":

         ? RemAll("007007   ", "0")      // "7007   "

   $PLATFORMS$
      DOS
   $SEEALSO$
      RemLeft(), RemRight()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RemLeft()
   $ONELINER$
      Removes particular characters from the beginning of a string
   $SYNTAX$
      RemLeft(<cString>,[<cCharacter|nCharacter>])
         --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

      <cCharacter|nCharacter>  Designates the character that is removed
      from the beginning of the <cString>.  The default value is a space,
      Chr(32).

   $RETURNS$
      RemLeft() returns the modified <cString>.

   $DESCRIPTION$
      RemLeft() functions exactly like CA-Clipper's LTrim(), with one
      exception.  While the CA-Clipper function can only remove spaces,
      RemLeft() can remove any character you choose.  The character that is
      removed can be specified with the <cCharacter|nCharacter> parameter.

   $NOTES$
      ■  When the <cCharacter|nCharacter> parameter is not specified,
         spaces are removed.

   $EXAMPLES$
      ■  Remove the spaces:

         ? RemLeft("   123   ")            // "123   "

      ■  Remove the character ".":

         ? RemLeft("..123..", ".")         // "123.."

   $PLATFORMS$
      DOS
   $SEEALSO$
      RemAll(), RemRight()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RemRight()
   $ONELINER$
      Removes particular characters at the end of a string
   $SYNTAX$
      RemRight(<cString>,[<cCharacter|nCharacter>])
         --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

      <cCharacter|nCharacter>  Designates the character that is removed
      from the end of the <cString>.  The default value is a space, Chr(32).

   $RETURNS$
      RemRight() returns the modified <cString>.

   $DESCRIPTION$
      RemRight() functions exactly like CA-Clipper's RTrim(), with one
      exception.  While the CA-Clipper function can only remove spaces,
      RemRight() can remove any character you choose.  The character that is
      removed can be specified with the <cCharacter|nCharacter> parameter.

   $NOTES$
      ■  When the <cCharacter|nCharacter> parameter is not specified,
         spaces are removed.

   $EXAMPLES$
      ■  Remove the spaces:

         ? RemRight("   abc   ")         // "   abc"

      ■  Remove the character ".":

         ? RemRight("..abc..", ".")      // "..abc"

   $PLATFORMS$
      DOS
   $SEEALSO$
      RemAll(), RemLeft()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ReplAll()
   $ONELINER$
      Exchanges particular characters at the beginning and end of a string
   $SYNTAX$
      ReplAll(<cString>,<cReplacecharacter|
         nReplacecharacter>,[<cSearchCharacter|
         nSearchCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the string that is processed.

      <cReplacecharacter|nReplacecharacter>  Designates the character that
      replaces the character in <cSearchCharacter|nSearchCharacter> at the
      beginning and end of <cString>.

      <cSearchCharacter|nSearchCharacter>  Designates the character at the
      beginning and end of <cString> that is replaced by <cReplacecharacter|
      nReplacecharacter>.  The default value designates a space, Chr(32).

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      ReplAll() can be used to exchange all leading and trailing spaces in a
      character string for any other character.  Notice that the first non-
      replaceable character in either direction causes ReplAll() to stop
      replacing characters on that side.

   $NOTES$
      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Replace spaces with dashes.  Replace the spaces only on the
         side where the character was found:

         ? ReplAll("abcd  ", "-")           // "abcd--"

      ■  Replace zeros with spaces:

         ? ReplAll("001234", " ", "0")      // "  1234"

      ■  Replace the blanks with dashes on both sides:

         ? ReplAll("   d  ", "-")           // "---d--"

      ■  Replace only continuous sequences of characters at the
         beginning and the end of the character string:

         ? ReplAll(" d d  ", "-")           // "-d d--"

   $PLATFORMS$
      DOS
   $SEEALSO$
      ReplLeft(), ReplRight(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ReplLeft()
   $ONELINER$
      Exchanges particular characters at the beginning of a string
   $SYNTAX$
      ReplLeft(<cString>,<cReplacecharacter|
         nReplacecharacter>,[<cSearchCharacter|
         nSearchCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the string that is processed.

      <cReplacecharacter|nReplacecharacter>  Designates the character that
      replaces the character in <cSearchCharacter|nSearchCharacter> at the
      beginning of the <cString>.

      <cSearchCharacter|nSearchCharacter>  Designates the character at the
      beginning of <cString> that is replaced by <cReplacecharacter|
      nReplacecharacter>.  The default value is a space, Chr(32).

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      ReplLeft() can be used to exchange all leading characters in a string
      for any other selected character.

   $NOTES$
      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Replace the leading spaces with zeros:

         ? ReplLeft("  1234", "0")              // "001234"

      ■  Replace the leading zeros with spaces:

         ? ReplLeft("001234", " ", "0")         // "  1234"

      ■  Replace only the leading spaces:

         ? ReplLeft("  1    ", "0")             // "001   "

   $PLATFORMS$
      DOS
   $SEEALSO$
      ReplAll(), ReplRight(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ReplRight()
   $ONELINER$
      Exchanges particular characters at the end of a string
   $SYNTAX$
      ReplRight(<cString>,<cReplacecharacter|
         nReplacecharacter>[<cSearchCharacter|
         nSearchCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the string that is processed.

      <cReplacecharacter|nReplacecharacter>  Designates the character that
      replaces the character in <cSearchCharacter|nSearchCharacter> at the end
      of the <cString>.

      <cSearchCharacter|nSearchCharacter>  Designates the character at the
      end of <cString> that is replaced by <cReplacecharacter|
      nReplacecharacter>.  The default value is a space, Chr(32).

   $RETURNS$
      The processed <cString> is returned.

   $DESCRIPTION$
      ReplRight() can be used to exchange all trailing characters in a string
      for any character you choose.

   $NOTES$
      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Replace the trailing spaces with dashes:

         ? ReplRight("abcd  ", "-")        // "abcd--"

      ■  Replace the trailing dashes with spaces:

         ? ReplRight("abcd--", " ", "-")   // "abcd  "

      ■  Replace only the trailing spaces:

         ? ReplRight("   1  ", "-")        // "   1--"

   $PLATFORMS$
      DOS
   $SEEALSO$
      ReplLeft(), ReplAll(), CSetRef(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RestToken()
   $ONELINER$
      Recreates an incremental tokenizer environment
   $SYNTAX$
      RestToken(<cTokenEnvironment>) --> cEmptyString

   $ARGUMENTS$
      <cTokenEnvironment>  Designates a character string returned by the
      SaveToken() function.

   $RETURNS$
      RestToken() always returns an empty string.

   $DESCRIPTION$
      The internal environment for the incremental tokenizer can be restored
      using RestToken().  RestToken() does the opposite of the SaveToken()
      function.

   $NOTES$
      ■  <nTokenEnvironment> must originate from the current program
         run; for example, it cannot have been restored from a (.mem) file.

   $EXAMPLES$
      ■  Here is an incremental tokenizer.  Text is broken into
         individual lines, and each line is broken into words:

         TokenInit(@cTextString, Chr(13) + Chr(10), 2)
         cLine   :=  TokenNext()

         DO WHILE .NOT. TokenEnd()
            cLine  :=  TokenNext(cTextString)
            Word(cLine)
         ENDDO

      ■  The function then breaks the lines into words:

         FUNCTION Word(cLine)

            cOldEnv  := SaveToken()
            TokenInit(@cLine, " .,-:;")

            DO WHILE .NOT. TokenEnd()
               cWord  :=  TokenNext(cLine)
               ? cWord
            ENDDO
            RestToken(cOldEnv)
            RETURN("")

   $PLATFORMS$
      DOS
   $SEEALSO$
      SaveToken(), TokenInit(), TokenNext()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SaveToken()
   $ONELINER$
      Saves the incremental tokenizer environment to a variable
   $SYNTAX$
      SaveToken() --> cTokenEnvironment

   $RETURNS$
      The character string returned contains the internal environment for the
      incremental tokenizer.

   $DESCRIPTION$
      By saving and later restoring the internal tokenizer environment, an
      interlocking implementation of the incremental tokenizer is made simple.
      The complete, previously initialized string is saved, as are the
      internal pointers and the corresponding file areas.  This string serves
      as a return value for SaveToken(), regardless of the later restoration
      of the tokenizer environment using RestToken().

   $NOTES$
      ■  The returned value is only valid for the currently running
         program because it is concerned with internal pointers.

   $EXAMPLES$
      ■  Here is an incremental tokenizer.  Text is broken into
         individual lines, and each line is broken into words:

         TokenInit(@cTextString, Chr(13) + Chr(10), 2)

         DO WHILE .NOT. TokenEnd()
            cLine   :=  TokenNext(cTextString)
            Word(cLine)
         ENDDO

      ■  The function then breaks the lines into words:

         FUNCTION Word(cLine)
               cOldEnv  := SaveToken()
               TokenInit(@cLine, " .,-:;")
               cWord  := TokenNext()

               DO WHILE .NOT. TokenEnd()
                  cWord := TokenNext(cLine)
                  ? cWord
               ENDDO
               RestToken(cOldEnv)

               RETURN("")

   $PLATFORMS$
      DOS
   $SEEALSO$
      RestToken(), TokenInit(), TokenNext()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetAtLike()
   $ONELINER$
      Provides an additional search mode for all AT functions
   $SYNTAX$
      SetAtLike([<nNewMode>,[<cCharacter>]]) --> nOldMode

   $ARGUMENTS$
      <nNewMode>  Designates which mode the AT functions and StrDiff()
      should use during searches.  At this time, the 0 and 1 modes are
      permitted.  The default value is 0.

      <cCharacter>  Designates optional wildcard characters only.  The
      default value is "?".

      ()  When called without parameters, the function returns the current
      mode.

   $RETURNS$
      When a parameter is passed, the function returns the previous mode.  If
      no parameter is passed, the function returns the current mode.

   $DESCRIPTION$
      Generally speaking, all AT functions like AtNum(), AfterAtNum(), and the
      function StrDiff(), operate to find an exact match during the execution
      of the search sequence.  When you use SetAtLike(1), an additional mode
      can be selected which permits the use of wildcard characters.  For every
      position containing a wildcard character within the search expression,
      any character can occur in the character string that is searched.  The
      first character of the search expression cannot be a wildcard, and the
      entire expression cannot consist of wildcards.  These restrictions
      simultaneously avoid unwanted recursions with AtRepl().

      The customary "?" has been used as the default wildcard character.
      However, it can be replaced by using the optional <cCharacter>
      parameter.  Any character you choose can be set as a wildcard character,
      increasing the flexibility of this group of functions.

   $NOTES$
      ■  The DOS supported "*" wildcard character is not available for
         this function.

      ■  The <nNewMode> parameter was selected to be a numeric value to
         allow future implementation of additional modes.

   $EXAMPLES$
      ■  Set the SetAtLike(1) wildcard mode to on:

         SetAtLike(1)

      ■  Determine the beginning position at the start of the last
         search expression:

         cTextsequence  := "ABCDEABC123AXCK"
         ? AtNum("ABC", cTextsequence)                 // 6
         ? AtNum("A?C", cTextsequence)                 // 12

      ■  Determine if the search expression occurs with the text
         sequence:

         cTextsequence  := "ABCDEABC123AXCK"
         ? NumAt("ABC", cTextsequence)                 // 2
         ? NumAt("A?C", cTextsequence)                 // 3

      ■  Determine the portion of the text sequence behind the last
         occurrence in the search expression:

         cTextsequence  := "ABCDEABC123AXCK"
         ? AfterAtNum("ABC", cTextsequence)            // 123AXCK
         ? AfterAtNum("A?C", cTextsequence)            // K

      ■  Determine the portion of the text sequence before the last
         occurrence in the search expression:

         cTextsequence  := "ABCDEABC123AXCK"
         ? BEFOREATNUM("ABC", cTextsequence)           // ABCDE
         ? BEFOREATNUM("A?C", cTextsequence)           // ABCDEABC123

      ■  Determine the portion of the text sequence from the last
         occurrence aligned at position 15:

         cTextsequence  := "ABCDEABC123AXCK"
         ? AtAdjust("ABC", cTextsequence, 15)          // ABCDE   ABC123AXCK
         ? AtAdjust("A?C", cTextsequence, 15)          // ABCDEABC123   AXCK

      ■  AtRepl() poses an unusual situation.  If a search expression
         containing wildcard characters (like the one in the following
         example) is exchanged for a sequence where you only find other
         characters at the wildcard positions, a recursion occurs internally
         if CSetAtMupa() is on:

         CSetAtMupa(.T.)
         cTextsequence  := "ABCDEABC123AXCK"
         ? AtRepl("D?", cTextsequence, "DX")           // ABCDXXXXXXXXXXXX

      ■  Wildcard characters reduce the valence with the StrDiff()
         function:

         ? StrDiff("ABC", "AXC")                       // Valence 3
         ? StrDiff("A?C", "AXC")                       // Valence 0

   $PLATFORMS$
      DOS
   $SEEALSO$
      AtAdjust(), AtNum(), AfterAtNum(), BeforAtNum()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      StrDiff()
   $ONELINER$
      Finds similarity between two strings (Levenshtein Distance)
   $SYNTAX$
      StrDiff(<cString1,<cString2>,[<nReplace>],
         [<nRemove>],[<nInsert>]) --> nDifferenceValue

   $ARGUMENTS$
      <cString1>  Designates the first character string for the
      comparison.  The replace, insert, and delete operations are carried out
      in this string.  The maximum length for this string is 254 characters.

      <cString2>  Designates the second character string for the
      comparison.

      <nReplace>  Designates the number of valences (between 0 and 255)
      that are allocated for the replacement of a character.  The default
      value is 3.

      <nRemove>  Designates the number of valences (between 0 and 255)
      that are allocated for the removal of a character.  The default value is
      6.

      <nInsert>  Designates the number of valences (between 0 and 255)
      that are allocated for the insertion of a character.  The default value
      is 1.

   $RETURNS$
      StrDiff() returns a value corresponding to the difference between the
      two character strings.  The value can between 0 and 65535.

   $DESCRIPTION$
      Two different character strings can be made equal by deleting,
      inserting, or replacing characters within the first string.  StrDiff()
      attempts this in any combination until agreement has been reached.
      Since specific valences are allocated for each of the three individual
      operations, the end result is a total of valences from which the degree
      of similarity can be determined.  With several paths to your end goal,
      the one to use is always the one that results in the smallest valence.
      In this way you can determine which stings of a group of character
      strings are the most similar.

   $NOTES$
      ■  The maximum length of the combined string is determined as
         follows:

         2 * (Len(par1) + 1) * (Len(par2) + 1) <= 65530

      ■  If both strings are the same length, each can be a maximum of
         180 bytes long.  The result:

         2 * 181 * 181  65522

      ■  Implementing the SetAtLike() function allows you to use
         wildcard characters within the search sequence.

   $EXAMPLES$
      ■  Here are some examples of StrDiff():

         ? StrDiff("ABC", "ADC")          // 3 - Replace 1 character
         ? StrDiff("ABC", "AEC")          // 3 - Replace 1 character
         ? StrDiff("CBA", "ABC")          // 6 - Replace 2 characters
         ? StrDiff("ABC", "AXBC")         // 1 - Insert 1 character
         ? StrDiff("AXBC", "ABC")         // 6 - Delete 1 character

      ■  Examples for the use of SetAtLike() can be found under the
         corresponding function description.

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetAtLike()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      StrSwap()
   $ONELINER$
      Interchanges two strings
   $SYNTAX$
      StrSwap(<cString1>,<cString2>) --> cString

   $ARGUMENTS$
      <cString1>  [@] and <cString2>  [@]  Designate the two strings
      that are interchanged.  At least one of the character strings must be
      passed by reference.

   $RETURNS$
      StrSwap() always returns a null string.  This function only affects
      strings that have been passed by reference.

   $DESCRIPTION$
      StrSwap() interchanges the strings <cString1> and <cString2>.  The
      exchange continues until all the characters in the shorter character
      string have been moved.  The function terminates when the last character
      of the shortest string is exchanged.

   $NOTES$
      ■  The character strings are changed directly.  Therefore, at
         least one of the strings must have been passed by reference to get a
         result.

   $EXAMPLES$
      ■  In this example, two strings are passed by reference:

         cStr1  :=  "1234567890"
         cStr2  :=  "ABCDEFGHIJKLM"
         ? StrSwap(@cStr1, @cStr2)      // Return value: ""

      ■  The two strings subsequently contain these characters:

         ? cStr1                        // "ABCDEFGHIJ"
         ? cStr2                        // "1234567890KLM"

      ■  In this example, only one of the strings is passed by
         reference:

         cStr1  :=  "1234567890"
         cStr2  :=  "ABCDEFGHIJKLM"
         ? StrSwap(cStr1, @cStr2)       // Return value: ""

      ■  Both strings subsequently contain the characters of the string
         passed by reference:

         ? cStr1                        // "1234567890"
         ? cStr2                        // "1234567890KLM"

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TabExpand()
   $ONELINER$
      Converts tabs to spaces
   $SYNTAX$
      TabExpand(<cString>,[<nTabWidth>],
         [<cCharacter|nCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  Designates the string that is processed.

      <nTabWidth>  Designates the tab width.  The default value is 8.

      <cCharacter|nCharacter>  Designates the characters that are used
      when expanding the tabs.  The default value is a space, Chr(32).

   $RETURNS$
      The modified <cString> is returned.

   $DESCRIPTION$
      The TabExpand() function replaces all tab characters (Chr(9)) in
      <cString> with the corresponding number of spaces or <cCharacter|
      nCharacter>.  The <nTabWidth> parameter can be used to set varying tab
      widths.

   $NOTES$
      ■  In the absence of the <nTabWidth> parameter, TabExpand() has a
         default tab width of 8.

      ■  The carriage return and line feed, where the high bit is set,
         are taken into consideration.

      ■  SETTABS() does not affect this function.

   $EXAMPLES$
      ■  TabExpand() only fills to the next tab position:

         ? TabExpand("-" +Chr(9) +"!")                  // "-       !"
         ? TabExpand("----" +Chr(9) +"!")               // "----    !"

      ■  You can fill with any character you like:

         ? TabExpand("-" +Chr(9) +"!", "+")             // "-+++++++!"

      ■  The tab width can be selected:

         ? TabExpand("-" +Chr(9) +"!", 4)               // "-   !"
         ? TabExpand("----" +Chr(9) +"!", 8)            // "----    !"
         ? TabExpand("----" +Chr(9) +"!", 8, "+")       // "----++++!"

   $PLATFORMS$
      DOS
   $SEEALSO$
      TabPack()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TabPack()
   $ONELINER$
      Converts spaces in tabs
   $SYNTAX$
      TabPack(<cString>,[<nTabWidth>],
         [<cCharacter|nCharacter>]) --> cString

   $ARGUMENTS$
      <cString>  Designates a character string that is packed with tab
      characters.

      <nTabWidth>  Designates the tab width.  The default value is 8.

      <cCharacter|nCharacter>  Designates which characters are replaced by
      a tab.  The default value is a space, Chr(32).

   $RETURNS$
      TabPack() returns the modified character string.

   $DESCRIPTION$
      This function does not simply exchange a simple sequence of the same
      characters for a tab; instead, it takes into account the true tab
      positions.  If a space (or the <cCharacter|nCharacter>) is found at a
      tab position, and immediately preceding it there is at least one
      identical character, the function replaces this sequence (maximum
      <nTabWidth>) with a Chr(9).  With tab characters, text can be packed by
      individual tab widths.  As with every good text editor, there is no
      replacement with a tab within single or double leading characters.

   $NOTES$
      ■  For the beginning of a line, the function takes into account
         the "normal" carriage return (Chr(13)/Chr(10)) as well as the high
         bit return (Chr(141)) used by MemoEdit().  Previously existing tab
         characters are also taken into account.

      ■  If another tab already exists, this tab can be removed with
         TabExpand().  The new tab can then be inserted using TabPack().

   $EXAMPLES$
      We have avoided replacing spaces with tabs in the following examples to
      keep the example legible.  Tab width is 8 (default).  "*" is exchanged
      for tab characters.

      ? TabPack("AAAAAAA*", "*")           // "AAAAAAA*"
      ? TabPack("AAAAA***", "*")           // "AAAAA" + Chr(9)

      ? TabPack("AAAAA*****", "*")         // "AAAAA" + Chr(9) + "**"
      crlf   :=  Chr(13) + Chr(10)
      cText  :=  "ABCD+" + crlf + "++---+++++"
      ? TabPack(cText, 4, "+")             // "ABCD+" + crlf +
                                           // "++---" + Chr(9) + "++"

   $PLATFORMS$
      DOS
   $SEEALSO$
      TabExpand()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TOKEN()
   $ONELINER$
      Selects the nth token from a string
   $SYNTAX$
      TOKEN(<cString>,[<cDelimiter>],[<nNumber>],
         [<nSkipWidth>]) --> cToken

   $ARGUMENTS$
      <cString>  Designates the string that is searched.

      <cDelimiter>  Designates the delimiter list used by the token.

      <nNumber>  Designates which token in the <cString> is copied.

      <nSkipWidth>  Designates the number of delimiter characters or
      sequences that count as delimiters for a token, even an empty token.
      The default value indicates that empty tokens are not taken into
      account.

   $RETURNS$
      TOKEN() returns the token for which the number has been specified or
      returns the last token in the <cString>.

   $DESCRIPTION$
      The TOKEN() function allows you to break down date and time strings,
      sentences, file names and paths, etc..  When you specify a value for
      <nNumber>, the token with this number is returned.  If you do not
      specify a value for <nNumber> the function returns the last token in the
      <cString>.  The function uses the following list of delimiters as a
      standard:

      CHR 32, 0, 9, 10, 13, 26, 32, 138, 141

      and the characters ,.;:!?/\<<>>()^#&%+-*

      The list can be replaced by your own list of delimiters, <cDelimiter>.
      Here are some examples of useful delimiters:

      Table 4-4: Recommended Delimiter Sequences
      <table>
          Description         <cDelimiter>

          Pages               Chr(12)(Form Feed)
          Sentences           ".!?"
          File Names          ":\."
          Numerical strings   ",."
          Date strings        "/."
          Time strings        ":."
         </table>

      The skip value designates the number of characters after which a token
      is counted again.  This also allows empty tokens within a string, like
      blanks, to be counted.

   $NOTES$
      ■  When you use the skip width with NumToken() or TOKEN(), or if
         you use both functions, this value for the skip width must be equal
         in both functions.

   $EXAMPLES$
      ■  Select the last token in the character string:

         ? TOKEN("Clipper")                     // "Clipper"
         ? TOKEN(" ,   Clipper . ")             // "Clipper"
         ? TOKEN("Clipper COMPILER!")           // "COMPILER"

      ■  Select the first token in a character string:

         ? TOKEN("Clipper", 1)                  // "Clipper"
         ? TOKEN("Clipper COMPILER!", 1)        // "Clipper"

      ■  Select the third token:

         ? TOKEN("This is a test.", 3)          // "a"

      ■  In this example only four tokens are present:

         ? TOKEN("This is a test.", 5)          // ""

      ■  This example shows how to count empty tokens.  Parameters
         separated by commas are counted, but some of the parameters are
         skipped.  Therefore, a token is counted after one delimiter (comma).
         A parameter is skipped where two delimiters (commas) appear without a
         parameter:

         cString  :=  "one,two,,four"
         nCount   :=  NumToken(cString, ",", 1)   // Result: 4
         FOR nI = 1 TO nCount
         ? TOKEN(cString, ",", nI, 1)
         NEXT nI

      ■  If the string contains different delimiters in varying
         combinations, then preparation with the aid of another function is
         always important (to enhance readability, periods have been used
         instead of spaces):

         cString  :=  "one, two,,four,...,six,.,eight"
         cString  := CharRem(".", cString)
         ? TOKEN(cString, ",", 6, 1)              // "six"

   $PLATFORMS$
      DOS
   $SEEALSO$
      TokenSep(), NumToken(), AtToken(), TokenUpper()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TokenAt()
   $ONELINER$
      Determines the most recent TokenNext() position within a string
   $SYNTAX$
      TokenAt(<lLastTokenPos>) --> nPosition

   $ARGUMENTS$
      <lLastTokenPos>  When designated as .T., this parameter returns the
      delimiter position after the last token found.

   $RETURNS$
      TokenAt() returns the beginning position of the token most recently
      returned using TokenNext().  If TokenInit() and TokenNext() have not
      been called prior to calling TokenAt(), the function returns 0.

   $DESCRIPTION$
      TokenAt() returns the starting position of the token most recently
      extracted by TokenNext().  If TokenAt() is used in conjunction with
      SubStr(), the delimiters before the token in an incremental tokenizer
      are available.  To determine the delimiter position before the last
      token, set TokenAt() to -1.  To determine the delimiter position after
      the last token, set TOKENAT to .T..

      Please notice that the character string initialized by TokenInit() no
      longer contains the original delimiters.  If you need the original
      delimiters, you should make a copy before you call TokenInit().

   $EXAMPLES$
      This example shows five tokens and their starting positions:

      cString  :=  "This is a search, 234"
      cCopy    :=  String
      TokenInit(@cString)
      ? TokenNext(), TokenAt()                  // "This", 1
      ? TokenNext(), TokenAt()                  // "is", 6
      ? TokenNext(), TokenAt()                  // "a", 9
      ? TokenNext(), TokenAt()                  // "search", 11
      ? TokenNext(), TokenAt()                  // "234", 18
      ? SubStr(cCOPY, TokenAt() -1, 1           // Delimiter : ","

   $PLATFORMS$
      DOS
   $SEEALSO$
      TokenInit(), TokenNext()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TokenEnd()
   $ONELINER$
      Determines if more tokens are available in TokenNext()
   $SYNTAX$
      TokenEnd() --> lEndToken

   $RETURNS$
      TokenEnd() returns .T. after the last token has been queried with
      TokenNext().

   $DESCRIPTION$
      Reviewing the return value of TokenNext(), as the final condition for
      tokenizing, is not always definitive.  The end of one cycle is shown
      here as a null string, which is returned just like an "empty" token
      (empty line).

      By contrast, TokenEnd() always returns definite information if there are
      more tokens to be returned by TokenNext().  This makes TokenEnd() ideal
      for use as a loop condition.

   $EXAMPLES$
      Break up text into individual lines.  The text is initialized so that
      two consecutive (3. Parameter) CR/LF sequences return a null string:

      TokenInit(TextString, Chr(13) + Chr(10), 2)

      DO WHILE .NOT. TokenEnd()
         Line  :=  TokenNext(TextString)

         ? "Line - " + Line
      ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      TokenInit(), TokenNext()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TokenInit()
   $ONELINER$
      Initializes a string for TokenNext()
   $SYNTAX$
      TokenInit([<cString>,[<cDelimiter>],
         [<nSkipDistance>]]) --> lStatus

   $ARGUMENTS$
      <cString>  [@]  Designates a character string for which tokenizing
      is initialized.  This must be passed by reference!

      <cDelimiter>  Designates a list (character string) of individual
      delimiters for tokenizing.

      <nSkipDistance>  Designates the number of delimiting
      characters/sequences after which a value, or a null string (if
      necessary), is returned.  The default value indicates that these
      characters/sequences are not counted.

      ()  When called with no parameters, TokenNext() is set to begin at the
      start of the string.

   $RETURNS$
      The function returns .F. when the string variable cannot be initialized.
      For example, the function returns .F. if the string variable was not
      passed by reference.

   $DESCRIPTION$
      When used in conjunction with the TokenNext() function, an extremely
      versatile incremental tokenizer is available to you.  Specific
      separation processes can be implemented much more quickly than with the
      group of functions around TOKEN().  The speed increase is achieved in
      two ways.

      TokenInit() exchanges all delimiting characters for the first one in the
      delimiter list.  This means the entire delimiter list does not have to
      be searched every time.  The second advantage is that TokenNext() does
      not always begin its search for the token that is extracted at the
      beginning of the string (see the function description for TokenNext()).
      However, in contrast to TOKEN(), TokenNext() is unable to extract a
      specific token.

      You can also use the third parameter, a skip distance for the delimiter
      characters.  This allows recognition of empty lines within a text.  In
      this case, an empty line would be displayed by a CrLfCrLf sequence.
      Since TokenInit() takes all designated delimiting characters and
      exchanges them for something uniform, this sequence is changed to
      CrCrCrCr.  A skip distance of 2 means that the two delimiters (in this
      case, Cr)) return a token each time.  Since nothing precedes this
      example, TokenNext() returns a null string.

      The function uses the following list of delimiters as standard:

      CHR 32, 0, 9, 10, 12, 26, 32, 138, 141

      and the characters ,.;:!?/\<<>>()^#&%+-*

      This list can be replaced by your own delimiter list, <cDelimiter>.
      Here are some examples of meaningful delimiting characters:

      Table 4-5: Recommended Delimiting Sequences
      <table>
          Description         <cDelimiter>

          Pages               Chr(12)(Form Feed)
          Sentence            ".!?"
          File Name           ":\."
          Numeric strings     ",."
          Date strings        "/."
          Time strings        ":."
         </table>

   $NOTES$
      ■  When using a skip value, you must use the TokenEnd() function
         as a loop condition.

      ■  When TokenInit() exchanges all delimiting characters for a new
         one, the first delimiter on the list is always used.  This ensures
         that no character contained in the token becomes a delimiter.

      ■  When you use the TokenInit() or TokenNext(), you cannot use
         the TokenSep() function.  The required information can be determined
         using TokenAt() in conjunction with the original string (status
         before TokenInit()).

            To determine the delimiter position before the last token, set
            TokenAt() to -1.  To determine the delimiter position after the
            last token, set TOKENAT to .T..

   $EXAMPLES$
      ■  Break a string into words.  First the string must be
         initialized:

         cDelim   :=  "!?.,-"
         cString   :=  "A.B-C,D!E??"

         TokenInit(@cString, cDelim)         // "A!B!C!D!E!!"


         Do While .NOT. TokenEnd()
            cWord  :=  TokenNext(cString)
            ? cWord
         ENDDO

      ■  Break text into lines.  Take blank lines into account using a
         skip distance of 2:

         nCounter  :=  0

         TokenInit(cTextString, Chr(13) + Chr(10), 2)

         DO WHILE .NOT. TokenEnd()
            nLine  :=  TokenNext(cTextString)
            ++ nCounter
         ENDDO

         ? nCounter

   $PLATFORMS$
      DOS
   $SEEALSO$
      SaveToken(), RestToken(), TokenNext(), TokenEnd()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TokenLower()
   $ONELINER$
      Converts the initial alphabetic character of a token into lower case
   $SYNTAX$
      TokenLower(<cString>,[<cDelimiter>],[<nNumber>])
         --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the string that is searched for tokens
      (words).

      <cDelimiter>  Designates the delimiter list used by the token.

      <nNumber>  Designates the token in which the initial alphabetic
      character is converted into a lower case, alphabetic character.  The
      default value designates that all tokens are converted.

   $RETURNS$
      The processed character string is returned.

   $DESCRIPTION$
      TokenLower() converts the initial alphbetic character of the tokens in
      the <cString> into a lower case, alphabetic character.  If you specify a
      value for <nNumber>, only this number of tokens is processed.  If you do
      not specify a value for <nNumber>, all tokens in the <cString> are
      processed.  The function uses the following list of delimiters by
      default:

      CHR 32, 0, 9, 10, 13, 26, 32, 138, 141

      and the characters ,.;:!?/\<<>>()^#&%+-*

      The list can be replaced by your own list of delimiters, <cDelimiter>.
      Here are some examples of useful delimiters:

      Table 4-6: Recommended Delimiter Sequences
      <table>
          Description         <cDelimiter>

          Pages               Chr(12)(Form Feed)
          Sentences           ".!?"
          File Names          ":\."
          Numerical strings   ",."
          Date strings        "/."
          Time strings        ":."
         </table>

   $NOTES$
      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Convert the initial letter of all tokens into lower case
         letters:

         ? TokenLower("good Morning")               // "good morning"

      ■  This example shows that there are no detrimental effects if
         you specify a token number that does not exist:

         ? TokenLower("good Morning",, 5)           // "good morning"

      ■  Process the first two tokens using your own delimiter:

         ? TokenLower("/AB/AB/AB", "/", 2)          // "/aB/aB/AB"

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumToken(), TOKEN(), AtToken(), TokenUpper(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TokenNext()
   $ONELINER$
      Provides an incremental tokenizer
   $SYNTAX$
      TokenNext(<idTokenInitVar>) --> cToken

   $ARGUMENTS$
      <idTokenInitVar>  Designates the name of the character string
      previously initialized using TokenInit().  This is the only way to
      access this string once it has been stored by the Virtual Memory Manager
      (VMM).

   $RETURNS$
      TokenNext() returns the next token from the string variable designated
      by TokenInit().  If there are no more tokens, a null string is returned.

   $DESCRIPTION$
      In conjunction with TokenInit(), this function provides a speed
      optimized variation of the normal TOKEN() function.  The increase in
      speed is achieved in two ways.

      TokenInit() exchanges all delimiting characters for the first delimiter
      in the list.  This means the entire delimiter list does not have to be
      searched every time.  The second advantage is that TokenNext() does not
      always begin its search for the token that is extracted at the beginning
      of the string.

      The TokenAt() function allows you to determine the position of
      TokenNext().

      Although the address of the string that is processed and the internal
      counter have already been determined or initialized by TokenInit(),
      CA-Clipper Tools still needs the variable name.  The function does work
      without this parameter, but only as long as the initialized character
      sequence has not been stored to VMM.  You should enter the variable name
      in each case because there is no explicit control over this!  If there
      is no access to the variable, a runtime error occurs.

   $NOTES$
      ■  When you use TokenInit() or TokenNext(), you cannot use the
         TokenSep() function.  The required information can be determined
         using TokenAt() in conjunction with the original string (status
         before TokenInit()).

      ■  To determine the delimiter position before the last token, set
         TokenAt() to -1.  To determine the delimiter position after the last
         token, set TOKENAT to .T..

   $EXAMPLES$
      Break down a string:

      cDelim   :=  "!?.,-"
      cString   :=  "A.B-C,D!E??"

      TokenInit(@cString, cDelim)      // "A!B!C!D!E!!"

      DO WHILE .NOT. TokenEnd()
         cWord  :=  TokenNext(cString)
         ? cWord
      ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      RestToken(), SaveToken(), TokenInit(), TokenAt()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TokenSep()
   $ONELINER$
      Provides the separator before or after the token most recently retrieved by TOKEN()
   $SYNTAX$
      TokenSep([<lMode>]) --> cDelimiter

   $ARGUMENTS$
      <lMode>  Designates which delimiter is returned.  When this
      parameter is specified as .T., the function returns the delimiter after
      the most recently retrieved token.  The default value (.F.) specifies
      that the delimiter before the token most recently retrieved is returned.

   $RETURNS$
      The return string is the delimiter found directly before the token most
      recently retrieved.  If there is no delimiting character present at the
      beginning or end of a character string, the function returns a null
      string.

   $DESCRIPTION$
      When mathematical expressions are broken down, the delimiting characters
      are of great interest.  TokenSep() is always concerned with the most
      recently retrieved token determined by the TOKEN() function.  Using the
      <lMode> parameter, you can specify whether the delimiter returned is the
      one before or after the token most recently retrieved.

   $NOTES$
      ■  The TokenSep() function cannot be used in conjunction with
         TokenInit() or TokenNext().  Delimiters can be determined using
         TokenAt() in conjunction with the original string (status of
         TokenInit()).

      ■  To find the delimiter position before the last token, set
         TokenAt() to -1.  To find the delimiter position after the last
         token, set TOKENAT to .T..

   $EXAMPLES$
      ■  In this example, there are delimiters before and after the
         last token:

         ? TOKEN("Hello, World!")            // Last token: "World"
         ? TokenSep()                        // Leading separator: ","
         ? TokenSep(.T.)                     // Trailing separator: "!"

      ■  This example shows how to force a token to include the
         delimiter immediately before it (the wrong setting):

         ? TokenSep() + TOKEN("32+45*70", "+-*/", 2)    // "45"

      ■  TOKEN() must be executed prior to TokenSep().  Notice the
         additional parenthesis:

         ? TokenSep() + (TOKEN("32+45*70", "+-*/",2)    // "+45"

   $PLATFORMS$
      DOS
   $SEEALSO$
      TOKEN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TokenUpper()
   $ONELINER$
      Converts the initial letter of a token into upper case
   $SYNTAX$
      TokenUpper(<cString>,[<cDelimiter>],[<nNumber>])
         --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the string that is searched for tokens
      (words).

      <cDelimiter>  Designates the delimiter list used by the token.

      <nNumber>  Designates the number of tokens in which the initial
      letter is converted into upper case.  The default value converts all
      tokens.

   $RETURNS$
      The processed character string is returned.

   $DESCRIPTION$
      The TokenUpper() function converts the initial letter of the tokens in
      the <cString> into an upper case letter.  If you specify a value for
      <nNumber>, only this number of tokens is processed.  If you do not
      specify a value for <nNumber>, all tokens in <cString> are processed.
      The function uses the following list of delimiters by default:

      CHR 32, 0, 9, 10, 13, 26, 32, 138, 141

      and the characters ,.;:!?/\<<>>()^#&%+-*

      The list can be replaced by your own list of delimiters, <cDelimiter>.
      Here are some examples of useful delimiters:

      Table 4-7:  String Manipulations
      <table>
          Description         <cDelimiter>

          Pages               Chr(12)(Form Feed)
          Sentences           ".!?"
          File Names          ":\."
          Numerical strings   ",."
          Date strings        "/."
          Time strings        ":."
         </table>

   $NOTES$
      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Convert the initial letter of all tokens into upper case
         letters:

         ? TokenUpper("Good morning")            //"Good Morning"

      ■  There are no detrimental effects if a larger number of tokens
         is specified than are available:

         ?TokenUpper("Good morning",, 5)         //"Good Morning"

      ■  Process the first two tokens using your own delimiter:

         ?TokenUpper("/ab/ab/ab", "/", 2)        //"Ab/Ab/ab"

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumToken(), TOKEN(), AtToken(), TokenLower(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ValPos()
   $ONELINER$
      Determines the numerical value of the character at a particular position
   $SYNTAX$
      ValPos(<cString>,[<nPosition>]) --> nAsciiValue

   $ARGUMENTS$
      <cString>  Designates any string.

      <nPosition>  Designates which character to convert into numeric data
      format.  The default value processes the last character.

   $RETURNS$
      ValPos() returns the numeric value of the character at <nPosition>.

   $DESCRIPTION$
      ValPos() converts a particular character in a string to its numerical
      equivalent.  You do not have to nest functions if you use ValPos().

   $NOTES$
      ■  This function works a bit differently than the CA-Clipper
         Val() function.  Val() terminates the conversion when a non-numeric
         character appears.  ValPos() only processes a single character.

      ■  If <nPosition> is past the end of <cString>, or the character
         selected through <nPosition> is not a number, ValPos() returns 0.

   $EXAMPLES$
      Determine the value of the character at position 3:

      cString  :=  "AX4B"
      ? ValPos(cString, 3)      // Result: 4

   $PLATFORMS$
      DOS
   $SEEALSO$
      AscPos()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WordOne()
   $ONELINER$
      Reduces the multiple appearances of particular double characters to one
   $SYNTAX$
      WordOne([<cDoubleCharacter>],<cString>) --> cString

   $ARGUMENTS$
      <cDoubleCharacter>  Designates which 2-byte sequences are only to
      appear once together in <cString>.  The default value is for all 2-byte
      sequences.

      <cString>  Designates a string that has only specific 2-byte
      sequences that appear together after manipulation.

   $RETURNS$
      WordOne() returns the modified character string.

   $DESCRIPTION$
      A unique operation is carried out on a string that is constructed out of
      2-byte sequences ("words").  The multiple sequence appearances must lie
      immediately beside one another, which allows a CharSort() with an
      element length of 2 to be executed.

      These sequences can be integers that have been generated using the
      CA-Clipper I2Bin() function and have been deposited in a string.  In
      conjunction with other string functions like WordOnly(), WordOne() is an
      extremely effective system for working with these kinds of files.

   $NOTES$
      ■  The term "word" is not used here in the textual sense, but
         rather as it is used in assembler programming.  A "word" consists of
         units of 16 bits, or more precisely, 2 bytes.

   $EXAMPLES$
      ■  This is a simple example with characters that can be
         displayed.  The "AB" lie one after the other but not the "12":

         ? WordOne("12ABAB12")             // "12AB12"

      ■  The function always runs through the string in ordered pairs:

         ? WordOne("12", "1212ABAB")       // "12ABAB"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharOne()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WordOnly()
   $ONELINER$
      Finds the common denominator between two strings on the basis of double characters
   $SYNTAX$
      WordOnly(<cDoubleCharacter>,<cString>) --> cString

   $ARGUMENTS$
      <cDoubleCharacter>  Designates the 2-byte sequences that are not
      removed from <cString>.

      <cString>  Designates a character string from which 2-byte sequences
      that do not appear in <cDoubleCharacter> are removed.

   $RETURNS$
      WordOnly() returns the modified string.

   $DESCRIPTION$
      This function deletes all 2-byte sequences in <cString> that do not
      appear in <cDoubleCharacter>.  This function is very useful in
      applications where 16-bit integer values have been saved to strings
      using the CA-Clipper I2Bin() function.

   $NOTES$
      ■  The function always processes strings in ordered pairs.

   $EXAMPLES$
      ■  This example shows a simple common denominator.  The second
         string contains only the 2-byte sequences that are also contained in
         the first string:

         ? WordOnly("AABBCCDD", "XXAAYYBBZZ")            // "AABB"

      ■  Both strings are always processed in ordered pairs:

         ? WordOnly("AABBCCDD", "XAAYYBBZZ")             // "BB"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharOnly()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WordRepl()
   $ONELINER$
      Replaces particular double characters with others
   $SYNTAX$
      WordRepl(<cSearchDoubleCharacterstring>,<cString>,
         <cReplaceDoubleCharacterstring>,[<lMode>])
         --> cString

   $ARGUMENTS$
      <cSearchDoubleCharacterstring>  Designates multiple 2-byte character
      strings which are replaced by corresponding character strings from
      <cReplaceDoubleCharacterstring> within <cString>.

      <cString>  [@]  Designates the character string within which the 2-
      byte length sequences are exchanged.

      <cReplaceDoubleCharacterstring>  Designates multiple 2-byte
      character strings which replace corresponding character strings from
      <cSearchDoubleCharacterstring> within <cString>.

      <lMode>  Designates whether the character string <cString> is run
      through in single steps (.T.) or in ordered pairs (.F.).  The default
      value (.F.) designates ordered pairs.

   $RETURNS$
      The modified character string is returned.

   $DESCRIPTION$
      With this function, 2-byte sequences in a string can be exchanged for
      another sequence of the same length.  By using WordRepl() and its analog
      function CharRepl(), you can develop a very fast algorithm for SoundEx()
      functions.  Strings read from screen memory or generated by the
      CA-Clipper I2Bin() function can be easily processed.

      The <cString> can be processed in a number of different ways.  It is
      here that the <lMode> parameter plays an important role, similar to the
      CSetAtMupa() functions.

      There are different modes of execution for the function:

      ■  Depending on the <lMode> parameter, the string is processed in
         single steps or ordered pairs.

      ■  CSetAtMupa() is successful only when <lMode> is designated
         as .T..  If CSetAtMupa() is .T., then WordRepl() continues with the
         second character exchanged in a sequence.  If CSetAtMupa() is not
         .T., WordRepl() continues with the character behind the second
         character.

   $NOTES$
      ■  The term "word" is not used here in the textual sense, but
         rather as it is used in assembler programming.  A "word" consists of
         units of 16 bits, or more precisely, 2 bytes.  The
         <cReplaceDoubleCharacterstring> parameter can be shorter than
         <cSearchDoubleCharacterstring>.

      ■  The function exchanges sequences in
         <cSearchDoubleCharacterstring> that do not have corresponding
         sequences in <cReplaceDoubleCharacterstring> with the last sequence
         in <cReplaceDoubleCharacterstring>.

      ■  The return value of the function can be suppressed by
         implementing CSetRef() to save space in working memory.

   $EXAMPLES$
      ■  Exchange "XX" for "CC":

         ? WordRepl("CC", "AABBCCDDEE", "XX")         // "AABBXXDDEE"

      ■  Here is an example of use with CSetAtMupa() and <lMode>:

         CSetAtMupa(.F.)                              // Default
         ? WordRepl("aa", "laaaa", "ba")              // "labaa"
         ? WordRepl("aa", "laaaa", "ba", .T.)         // "lbaba"

      ■  CSetAtMupa() only affects the function call when <lMode> is
         .T.:

         CSetAtMupa(.T.)                              // Multi-pass mode on
         ? WordRepl("aa", "laaaa", "ba")              // "labaa"
         ? WordRepl("aa", "laaaa", "ba", .T.)         // "lbbba"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetAtMupa(), CharRepl(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WordSwap()
   $ONELINER$
      Exchanges double characters that lie beside each other in a string
   $SYNTAX$
      WordSwap(<cString>,[<lMode>]) --> cString

   $ARGUMENTS$
      <cString>  [@]  Designates the character string within which the 2-
      byte sequences are exchanged.

      <lMode>  Designates whether the adjoining bytes are exchanged (.T.)
      or not (.F.).  The default value (.F.) designates that the adjoining
      bytes are not exchanged.

   $RETURNS$
      WordSwap() returns the modified character string.

   $DESCRIPTION$
      With WordSwap(), 2-byte sequences within a character string are
      exchanged for each other.  In this respect the function works exactly
      like CharSwap(), except that 16-bit groups are being exchanged.

      The function is used on strings that contain 32-bit integers created by
      the CA-Clipper L2Bin().  The exchange serves as a preparation for a sort
      of these integers using CharSort().  In order to achieve a correct sort,
      you must exchange two adjacent bytes (low/high ordering of 16-bit
      integers), in addition to exchanging the 16-bit groups.

   $NOTES$
      ■  When <lMode> is .T., adjoining bytes are only exchanged after
         being exchanged as two 2-byte groups.

      ■  The return value of this function can be suppressed by
         implementing CSetRef() to save working memory space.

   $EXAMPLES$
      ■  Exchange characters:

         ? WordSwap("1234567890")          // "3412785690"

      ■  Also exchange the bytes:

         ? WordSwap("1234567890, .T.)      // "4321876590"

      ■  Working with L2Bin():

         ? L2Bin(1)               // 00000001 00000000 00000000 00000000
         ? L2Bin(65536)           // 00000010 00000000 00000001 00000000
         ? L2Bin(65536) > L2Bin(1)                                 // .F.
         ? WordSwap(L2Bin(65536), .T.) > WordSwap(L2Bin(1), .T.)   // .T.

   $PLATFORMS$
      DOS
   $SEEALSO$
      CharSwap(), CharSort(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WordToChar()
   $ONELINER$
      Exchanges double characters for individual ones
   $SYNTAX$
      WordToChar(<cDoubleCharacterList>,<cString>,
         <cCharacterlist>) --> cString

   $ARGUMENTS$
      <cDoubleCharacterList>  Designates multiple 2-byte sequences which
      are exchanged for corresponding individual characters from the
      <cCharacterlist>.

      <cString>  Designates the character string within which 2-byte
      sequences are exchanged for individual characters.

      <cCharacterlist>  Designates a sequence of individual characters
      which correspond to 2-byte sequences in <cDoubleCharacterList> for
      replacement within <cString>.

   $RETURNS$
      WordToChar() returns the modified character string.

   $DESCRIPTION$
      When you use SOUNDEX algorithms, sequences of two characters must often
      be exchanged for a single other character.  WordToChar() makes this
      process extremely simple and quick.

      The function processes the <cString> in 1-byte steps.  The behavior
      after exchanging a sequence for a character is determined by
      CSetAtMupa().  If CSETATMUPA is .F., the search for more sequences
      continues after the exchanged characters.  If CSETATMUPA is .T., the
      search for more sequences continues and includes the exchanged
      characters.

   $NOTES$
      ■  The term "word" is not used here in the textual sense, but
         rather as it is used in assembler programming.  A "word" consists of
         units of 16 bits, or more precisely, 2 bytes.

      ■  <cCharacterlist> can be shorter than <cDoubleCharacterList>.
         When this occurs, the function exchanges the sequences in
         <cDoubleCharacterList> that do not have corresponding sequences in
         <cCharacterlist> for the last sequence in <cDoubleCharacterList>.

   $EXAMPLES$
      ■  This example shows a simple replacement:

         ? WordToChar("aa", "Xaaaa", "a")      // "Xaa"

      ■  This example shows WordToChar() in conjunction with
         CSetAtMupa():

         CSetAtMupa(.F.)                       // Multi pass off
         ? WordToChar("aa", "Xaaaa", "a")      // "Xaa"
         CSetAtMupa(.T.)                       // Multi pass on
         ? WordToChar("aa", "Xaaaa", "a")      // "Xa"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetAtMupa(), WordRepl(), CharRepl()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Number / Bit Manipulation
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      <b>Number and Bit Manipulation</b>

       This module discusses  number and bit manipulation.  Specifically, the
       numeric section deals with conversions between two different number
       systems, and the creation of random numbers.

       The bit manipulation section covers such required binary operations as
       AND, OR, XOR, and NOT, and how to test, set and clear bits.  The
       NumLow() and NumHigh() functions are important for CA-Clipper Tools
       functions that take two 8-bit values and return them as combined 16-bit
       numbers.  An example is the GETCURSOR() function from the Extended
       Drivers module.

       Many of the functions in this module have a <value> parameter type.  In
       this case, a number can be in the range of 0 to 65535 (or 4 294 967 295)
       and/or a hexadecimal string in the range of "0000" to "FFFF" (or
       "FFFFFFFF").
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      BitToC()
   $ONELINER$
      Converts position-dependent bits into characters
   $SYNTAX$
      BitToC(<nInteger>,<cBitpattern>,[<lMode>])
          --> cCharacterstring

   $ARGUMENTS$
      <nInteger>  Designates a number in the range of 0 to 65535, which
      corresponds to a bit pattern.

      <cBitpattern>  Designates a character string with a maximum of 16
      characters.  Each character corresponds to a bit in <nInteger>, where
      the last character corresponds to the lowest-value bit.

      <lMode>  When this optional parameter is designated as .T., 0 bits
      change to blanks.  The default is no change.

   $RETURNS$
      The returned string contains the corresponding characters passed by the
      bit pattern.

   $DESCRIPTION$
      The BitToC() function changes the bits of a number into a sequence of
      corresponding characters.  This facilitates work with such bit-coded
      information as file attributes.  Depending on the <lMode> logical
      parameter (the l in lMode symbolizes logical), 0 bits either displays no
      character (.F.) or a blank (.T.).

   $NOTES$
      ■  If <lMode> is designated as .T., the string length that
         results always corresponds to <cBitpattern>.

   $EXAMPLES$
      ■  Change file attributes:

      ■  The number 2 corresponds to a binary "00000010":

         ? BitToC(2, "ADVSHR")            // "H" as the next to
                                          // last character

      ■  The number 5 corresponds to a binary "00000101":

         ? BitToC(5, "ADVSHR")            // "SR"

      ■  The number 5, with the 0 bit displayed as a blank:

         ? BitToC(5, "ADVSHR", .T.)       // "   S R"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CToBit(), CToN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Celsius()
   $ONELINER$
      Converts a Fahrenheit temperature value into Celsius
   $SYNTAX$
      Celsius(<nFahrenheit>) --> nCelsius

   $ARGUMENTS$
      <nFahrenheit>  Designates a temperature in Fahrenheit.

   $RETURNS$
      Celsius() returns the converted temperature in degrees Celsius.

   $DESCRIPTION$
      This function converts Fahrenheit temperature values directly into
      Celsius values.

   $EXAMPLES$
      Convert to Celsius:

      CODEX = Celsius(33.8)   // Result:  1
      Celsius(338.0)          // Result:  170
      Celsius(3380.0)         // Result:  1860
      Celsius(-33.8)          // Result:  -36.555555...

   $PLATFORMS$
      DOS
   $SEEALSO$
      Fahrenheit()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ClearBit()
   $ONELINER$
      Clears one or more bits within a number to zero
   $SYNTAX$
      ClearBit(<nLONG|cHexLONG>,<nBitPos1>,
         [...<nBitPos32>]) -->  nNewValue

   $ARGUMENTS$
      <nLONG|cHexLONG>  Designates either a decimal number or hexadecimal
      character string.

      <nBitPos32>  Designates the bit numbers to delete.

   $RETURNS$
      ClearBit() returns a value in which the designated bits are cleared.

   $DESCRIPTION$
      ClearBit() resets particular bits within a field to change something
      like a serial port register.  In contrast to NumAnd(), the bit numbers
      are given and do not need to be converted beforehand.  The value 1
      represents the bit with the lowest value, and the value 32, the bit with
      the highest value.

   $NOTES$
      ■  An invalid parameter returns a result of -1.

   $EXAMPLES$
      Bits 3, 4, and 6 are cleared in a bit pattern:

      nBitPattern  := 255
      nBitPattern  := ClearBit(nBitPattern, 3, 4, 6)   // Result:  211

   $PLATFORMS$
      DOS
   $SEEALSO$
      IsBit(), SetBit(), NumAnd(), NumNot(), NumOr(), NumXor()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CToBit()
   $ONELINER$
      Converts a character string into a bit pattern
   $SYNTAX$
      CToBit(<cCharacterstring>,<cBitpattern>) --> nWORD

   $ARGUMENTS$
      <cCharacterstring>  Designates a character sequence.  When this
      sequence occurs in the second character string, each corresponding bit
      is set to 1.

      <cBitpattern>  Designates a sequence, with a maximum of 16
      characters, from which the bit position is assigned.

   $RETURNS$
      CToBit() returns a number in the range of 0 to 65535 that corresponds to
      the created bit pattern.

   $DESCRIPTION$
      The CToBit() function delivers a bit pattern that corresponds to a
      string of individual characters.  When used in conjunction with its
      sister function BitToC(), it facilitates work with such bit-coded
      information as file attributes.

   $NOTES$
      ■  Characters in <cCharacterstring> that are not found in
         <cBitpattern> are ignored.

   $EXAMPLES$
      ■  The second bit in the resulting value is set, since the letter
         "H" appears in the next-to-last position in "ADVSHR":

         ? CToBit("H", "ADVSHR")          // Result:  00000010

      ■  Two characters also in ADVSHR, appear at the first and final
         positions in this 6-character string:

         ? CToBit("RA", "ADVSHR")         // Result:  00100001

      ■  <cBitpattern> ignores previously unavailable characters:

         ? CToBit("XRYA", "ADVSHR")       // Result:  00100001

   $PLATFORMS$
      DOS
   $SEEALSO$
      BitToC(), NToC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CToF()
   $ONELINER$
      Converts a special 8-byte string into a floating point number
   $SYNTAX$
      CToF(<cFloatingPointNumber>) --> nFloatingPointNumber

   $ARGUMENTS$
      <cFloatingPointNumber>  Designates an 8-byte character string that
      contains a CA-Clipper number in the 64-bit floating point format.

   $RETURNS$
      CToF() returns the number that corresponds in the passed string.

   $DESCRIPTION$
      Character strings created with FToC() or XToC() are changed into
      CA-Clipper numbers.  Note that when you use XToC(), character strings or
      portions of character strings, can be switched back, if they have been
      displayed as CA-Clipper floating point numbers.

   $EXAMPLES$
      ■  Change a number and then change it back:

         CToF(FToC(1234.55))        // Result:  1234.55

      ■  This also works for XToC():

         ? CToF(XToC(1234.55))      // Result:  1234.55

   $PLATFORMS$
      DOS
   $SEEALSO$
      FToC(), XToC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CToN()
   $ONELINER$
      Converts a numeric string into a different base
   $SYNTAX$
      CToN(<cNumericstring>,[<nBase>],[<lMode>])
          --> nInteger

   $ARGUMENTS$
      <cNumericstring> Designates a numeric string to convert into a
      number in base <nBase>.

      <nBase>  Designates the number base to use in the conversion.  Can
      be in the range of 2 to 36.  The default is the decimal system, base 10.

      <lMode>  When designated as .T., allows a negative result.  The
      default allows only positive results.

   $RETURNS$
      CToN() returns the converted number that corresponds to the string.  The
      values lie in the range of 0 and 65535 or, if <lMode> is .T., in the
      range of -32768 and +32767.

   $DESCRIPTION$
      CToN() offers a number of ways to covert a number string into numeric
      data format.  Almost any number can be converted, as long as the base
      <nBase>  for the number system lies between 2 and 36.

   $NOTES$
      ■  The <cNumericstring> string is automatically TRIMmed left and
         right.

      ■  If you have invalid parameters or combinations, the function
         returns a value of 0.

   $EXAMPLES$
      ■  Convert to base 10:

         ? CToN("60000")                    // Result:  60000

      ■  Convert to base 2:

         ? CToN("11", 2)                    // Result:  3

         ? CToN("1110101001100000", 2)      // Result:  60000

      ■  Convert to base 16:

         CToN("A", 16)                      // Result:  10

         ? CToN("ABCD", 16)                 // Result:  43981

         ? CToN("FFFF", 16, .T.)            // Result:  -1

      ■  Convert to base 36:

         ? CToN("XXP", 36)                  // Result:  43981

   $PLATFORMS$
      DOS
   $SEEALSO$
      NToC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Exponent()
   $ONELINER$
      Determines the exponent of a floating point number (base 2)
   $SYNTAX$
      Exponent(<nFloatingPointNumber>) --> nExponent

   $ARGUMENTS$
      <nFloatingPointNumber>  Designates any decimal number.

   $RETURNS$
      Exponent() returns the exponent of the <nFloatingPointNumber> number in
      base 2.

   $DESCRIPTION$
      CA-Clipper stores all numbers in a floating point format (called
      "double" in C).  Exponent() only returns exponents in this format, and
      they are always expressed in base 2.

   $NOTES$
      ■  The expression Exponent(0) returns a value of 0.  However, the
         expression 20 returns a value of 1.  In this case, the mantissa must
         also equal 0 (see Mantissa()).

   $EXAMPLES$
      ■  The following calculation produces the original number:
         ^2 Exponent(nValue) * Mantissa(nValue)= nValue

         ? Exponent(0)                     // Result:  0
         ? Exponent(Infinity())            // Result:  1023
         ? Exponent(100)                   // Result:  6

      ■  The sign for nValue will not be considered:

         ? Exponent(-100)                  // Result:  6
         ? Exponent(-1.01)                 // Result:  0
         ? Exponent(-2.01)                 // Result:  1

      ■  Values in the range of -1 < nValue < +1, yield negative
         exponents regardless of the sign:

         ? Exponent(0.01)                  // Result:  -7
         ? Exponent(-0.01)                 // Result:  -7

   $PLATFORMS$
      DOS
   $SEEALSO$
      Mantissa()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Fahrenheit()
   $ONELINER$
      Converts a temperature value from Celsius into Fahrenheit
   $SYNTAX$
      Fahrenheit(<nCelsius>) --> nFahrenheit

   $ARGUMENTS$
      <nCelsius> Designates a temperature in Celsius.

   $RETURNS$
      Fahrenheit() returns the converted temperature in degrees Fahrenheit.

   $DESCRIPTION$
      This function converts Celsius temperatures into Fahrenheit equivalents.

   $EXAMPLES$
      Convert the following Celsius temperatures to Fahrenheit:

      Fahrenheit(12.5)            // Result:  54.5
      Fahrenheit(125.0)           // Result:  257
      Fahrenheit(1250.0)          // Result:  2282
      Fahrenheit(-155.0)          // Result:  -247

   $PLATFORMS$
      DOS
   $SEEALSO$
      Celsius()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FToC()
   $ONELINER$
      Converts a floating point number into a special 8-byte string
   $SYNTAX$
      FToC(<nFloatingPointNumber>) --> cFloatingPointNumber

   $ARGUMENTS$
      <nFloatingPointNumber>  Designate any CA-Clipper number.

   $RETURNS$
      FToC() returns an 8-byte character string.

   $DESCRIPTION$
      CA-Clipper internal numbers are displayed as 64-bit floating point
      numbers.  FToC() returns these 64 bits as an 8-byte string.  In this
      way, numbers can be locked and/or saved more compactly.

   $NOTES$
      ■  The XToC() function converts floating point numbers in the
         same way.

   $EXAMPLES$
      It is not useful to display the return value on the screen:

      NumberString  :=  FToC(274711.335)      // 8 byte string

   $PLATFORMS$
      DOS
   $SEEALSO$
      CToF(), XToC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Infinity()
   $ONELINER$
      Creates the largest number possible (21023)
   $SYNTAX$
      Infinity() --> nLargestNumber

   $RETURNS$
      Infinity() returns the largest number possible.

   $DESCRIPTION$
      When you divide by zero, use the Infinity() value as a result (i.e., for
      comparisons).

   $NOTES$
      ■  The number value is approximately (1.999 * 21023).

   $EXAMPLES$
      Display the largest number possible in CA-Clipper:

      ? Infinity()

   $PLATFORMS$
      DOS
   $SEEALSO$
      Exponent(), Mantissa()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IntNeg()
   $ONELINER$
      Converts an unsigned integer into a signed integer
   $SYNTAX$
      IntNeg(<nUnsigned|cHexUnsigned>,[<l32Bit>)
          --> nSigned

   $ARGUMENTS$
      <nUnsigned|cHexUnsigned>  Designates either a numeric value or
      hexadecimal digit string to convert into a 16-bit or 32-bit signed
      integer.

      <32Bit>  If this optional parameter is designated as .T., the
      function processes the designated value as a 32-bit unsigned integer.
      The default value is a 16-bit unsigned integer (.F.).

   $RETURNS$
      IntNeg() returns a signed 16-bit or 32-bit integer.

   $DESCRIPTION$
      This function converts unsigned integers into signed integers.

      All 16-bit or 32-bit integers are accepted, depending on whether there
      is a second parameter and the logical value is assigned.  For the 16-bit
      variant, all values for <nUnsigned|cHexUnsigned> that are less than or
      equal to +32767 (hex=7FFF), are positive.  Values in the range of +32768
      (hex=8000) to +65535 (hex=FFFF), have a negative result.  When you work
      with 32-bit values, the positive range goes to 2147483647 (inclusive).
      All values beyond that are negative.

   $NOTES$
      ■  The function returns a value of 0 for invalid, too large, or
         negative parameters.

   $EXAMPLES$
      ■  Show valid parameters:

         ? IntNeg(0)                   // Result:  0
         ? IntNeg(-1)                  // Result:  0
         ? IntNeg(30000)               // Result:  30000
         ? IntNeg(32767)               // Result:  32767
         ? IntNeg(32768)               // Result: -32768
         ? IntNeg(32769)               // Result: -32767
         ? IntNeg(60000)               // Result: -5536
         ? IntNeg(65535)               // Result: -1
         ? IntNeg("FFFF")              // Result: -1
         ? IntNeg("D0000000", .T.)     // Result: -805306368
         ? IntNeg("FFFFFFFF", .T.)     // Result: -1

      ■  Show incorrect instructions or instructions that are too
         large:

         ? IntNeg("GGGG")              // Result:  0
         ? IntNeg(90000)               // Result:  0
         ? IntNeg("FFFFFFFFF")         // Result:  0

   $PLATFORMS$
      DOS
   $SEEALSO$
      IntPos(), NumAnd(), NumOr(), NumXor()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IntPos()
   $ONELINER$
      Converts a signed integer into an unsigned integer
   $SYNTAX$
      IntPos(<nSigned|cHexSigned>,[<l32Bit>])
          --> nUnsigned

   $ARGUMENTS$
      <nUnsigned|cHexUnsigned>  Designates either a numeric value or
      hexadecimal digit string to convert into a 16-bit or 32-bit unsigned
      integer.

      <l32Bit>  If this optional parameter is designated as .T., the
      function processes the designated value as a 32-bit signed integer.  The
      default value is a 16-bit signed integer (.F.).

   $RETURNS$
      IntPos() returns an unsigned 16-bit or 32-bit integer.

   $DESCRIPTION$
      This function converts signed 16-bit or 32-bit integers into the
      corresponding unsigned number.  Based on the optional parameter and the
      logical value it is assigned, you can work with 16-bit or 32-bit values.

      For the 16-bit variant, all values in the 0 to 32767 range are
      unchanged.  However, all negative values from -1 to -32768 are changed.
      When the optional parameter is designated as .T., the range of values
      stretches from -2147483648 to +2147483647.

   $NOTES$
      ■  This function returns a 0 result for invalid paramerters.

   $EXAMPLES$
      ■  Show simple conversions:

         ? IntPos(-1)               // 65535
         ? IntPos(-2)               // 65534
         ? IntPos(30000)            // 30000
         ? IntPos(60000)            // 60000

      Warning!  When working with 16-bit values IntPos(0) = IntPos(65536):

         ? IntPos(0)                // 0
         ? IntPos(65536)            // 0

      ■  Show values larger than 65536 in 16-bit mode.  For example,
         the difference between 90000 and 65536 is 24464:

         ? IntPos(90000)            // 24464

      ■  However, in 32-bit mode:

         ? IntPos(90000, .T.)       // 90000
         ? IntPos(-1, .T.)          // 4294967295
                                    // (largest 32-bit number)
         ? IntPos(-60000, .T.)      // 4294907296
         ? IntPos(-90000, .T.)      // 4294877296

   $PLATFORMS$
      DOS
   $SEEALSO$
      IntNeg(), NumAnd(), NumOr(), NumXor()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsBit()
   $ONELINER$
      Tests the bits in a number
   $SYNTAX$
      IsBit(<nLONG|cHexLONG>,[<nBitPos>]) --> lSet

   $ARGUMENTS$
      <nLONG|cHexLONG> Designates either a decimal number or hexadecimal
      digit string.

      <nBitPos>  Designates the bit number to test.  The value can lie in
      the range of 1 to 32.  The default is the least-significant bit.

   $RETURNS$
      When the designated bit is set, the function returns a result of .T..

   $DESCRIPTION$
      IsBit() tests a particular bit within a numeric field, without having to
      mask it or do a comparison.

   $EXAMPLES$
      Tests the BREAK bit in the line status register of the COM1 serial
      interface:

      IF IsBit(com_LSR(1), 5)
         ? "BREAK condition detected!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumAnd(), NumNot(), NumOr(), NumXor(), SetBit()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      LToN()
   $ONELINER$
      Converts a logical value into a numeric value
   $SYNTAX$
      LToN([<lValue>]) --> nLogicalValue

   $ARGUMENTS$
      <lValue>  Designates the logical expression to convert.  The default
      value is .F..

   $RETURNS$
      If you designate a .T., LToN() returns a 1; with .F., it returns a 0.

   $DESCRIPTION$
      LToN() converts a logical value into a numeric value.  This allows
      indexing on a logical field.

   $NOTES$
      ■  The function treats a missing parameter as .F..

   $EXAMPLES$
      Determines the number of days in a year:

      ? "The year has " + Str(365 + LToN(IsLeap()), 3) + "  days."

   $PLATFORMS$
      DOS
   $SEEALSO$
      CToN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Mantissa()
   $ONELINER$
      Determines the mantissa of a floating point number (base2)
   $SYNTAX$
      Mantissa(<nFloatingPointNumber>) --> nMantissa

   $ARGUMENTS$
      <nFloatingPointNumber>  Designates any decimal number.

   $RETURNS$
      Mantissa() returns the mantissa of the <nFloatingPointNumber> number.

   $DESCRIPTION$
      This function supplements Exponent() to return the mantissa of the
      <nFloatingPointNumber> number.

   $NOTES$
      ■  The mantissa value can be 0 or in the range of 1 to 2.

      ■  The following calculation reproduces the original value:

        Mantissa(<nFloatingPointNumber>)* 2^Exponent(<FloatingPointNumber =
         <nFloatingPointNumber>)

   $EXAMPLES$
      Display the mantissa for the following values:

      ? Mantissa(0)            // Result:  0.00
      ? Mantissa(100)          // Result:  1.56
      ? Mantissa(INFINITY)     // Result:  2.00
      ? Mantissa(0.01)         // Result:  1.28
      ? Mantissa(-100)         // Result: -1.56
      ? Mantissa(-0.01)        // Result: -1.28
      ? Mantissa(-1.01)        // Result: -1.01
      ? Mantissa(-2.01)        // Result: -1.01

   $PLATFORMS$
      DOS
   $SEEALSO$
      Exponent()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NToC()
   $ONELINER$
      Converts the numbers in a digit string into a different number base
   $SYNTAX$
      NToC(<nLONG|cHexLONG>,[<nBase>],[<nLength>],
         [<cPad>]) --> cCharacterstring

   $ARGUMENTS$
      <nLONG|cHexLONG>  Corresponds to a decimal number or hexadecimal
      character string to convert.

      <nBase>  Designates the number system base, from 2 to 36
      (inclusive), to use in the result.  The default is the decimal system,
      base 10.

      <nLength>  Designates the length of the string that results.  The
      maximum length is 255.  The default is the length required for the
      conversion.

      <cPad>  Designates a pad character to pad the string result on the
      left.  The default value is a space.

   $RETURNS$
      NToC() returns a character string that contains the conversion result of
      <nLONG|cHexLONG> into the <nBase> number system.

   $DESCRIPTION$
      NToC() converts a decimal number or hexadecimal string into a number
      string.  The result is a number in base <nBase> or, if <nBase> is not
      specified, in base 10.  Use <nLength> to determine the length of the
      result string.  However, if <nLength> is longer than the length
      necessary for the result, the result string is padded on the left with
      spaces or with a character selected with <cPad>.

   $NOTES$
      ■  If incompatible parameter combinations are specified, NToC()
         returns one or more asterisks (*) as a result.

   $EXAMPLES$
      ■  Convert to base 10:

         ? NTOC (60000)                //"60000"
         ? NTOC (60000, 10, 7)         //"    60000"

      ■  Convert to base 2:

         ? NToC(60000, 2)              // "1110101001100000"
         ? NToC("FFFF", 2)             // "1111111111111111"
         ? NToC("30", 2, 8, "0")       // "00110000"

      ■  Convert to base 16:

         ? NToC(43981, 16)             // "ABCD"

      ■  Convert to base 36:

         ? NToC(43981, 36, 4)          // "XXP"

      ■  Invalid parameters (overflow):

         ? NToC("GGGG", 2)             // "*"
         ? NToC(60000, 10, 3)          // "***"
         ? NToC(60000, 1, 4)           // "****"

   $PLATFORMS$
      DOS
   $SEEALSO$
      CToN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumAnd()
   $ONELINER$
      Performs a 16-bit "AND" of a list of numbers
   $SYNTAX$
      NumAnd(<nWORD1|cHexWORD1>,<nWORD2|cHexWORD2>,
         [...<nWORDn|<cHexWORDn>]) --> nWORD-AND

   $ARGUMENTS$
      <nWORD1|cHexWORD1>, <nWORD2|cHexWORD2>, ...<nWORDn|cHexWORDn>
      Designates either decimal or hexadecimal number strings.

   $RETURNS$
      NumAnd() joins all designated parameters with the logical "AND" and
      returns the result.

   $DESCRIPTION$
      This function makes it simple to test several bits in a number
      simultaneously.  If bits are connected in an AND configuration, you can
      mask out specific bits and the unneeded bits are reset to 0.  All the
      numbers specified as parameters are then connected with AND.

   $NOTES$
      ■  An invalid parameter returns a result of -1.

   $EXAMPLES$
      Test an interface register:

      The register contains:         00011101
      The constant in binary:        00000111
                                     ________
      The result: (5)                00000101
      nStatus  := com_MSR()
      IF NumAnd(nStatus, 7) = 5
         ? "Bit 1 and Bit 2 are set!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumNot(), NumOr(), NumXor(), SetBit(), IsBit()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumCount()
   $ONELINER$
      Uses the internal CA-Clipper Tools counter
   $SYNTAX$
      NumCount([<nIncrement|nStartValue>,[<lMode>]])
          --> nNewCounterValue

   $ARGUMENTS$
      <nIncrement|nStartValue>  Designates the incremental value for the
      internal counter or a new starting value.

      <lMode>  Designates whether <nIncrement|nStartValue> is a new
      starting value (.T.) or an increment (.F.).  The default is increment
      (.F.).

      () Without parameters, the current counter value is returned.

   $RETURNS$
      When called without parameters, this function returns the current
      counter value; otherwise, it always returns the new counter value.

   $DESCRIPTION$
      Always increment count variables and retain the current status when you
      program counting events.  Use NumCount() to simplify this process.  When
      you call NumCount(), the internal counter is increased and the new
      counter status is returned to the calling program.  The count variable
      is then queried and actualized in one step.

   $EXAMPLES$
      Data is not output with line numbers, but with a running counter:

      NumCount(0, .T.)      // Set 0 as a starting value..
      LIST OFF NumCount(1), CUST FOR REBATE

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumHigh()
   $ONELINER$
      Returns the higher value byte in a 16-bit number
   $SYNTAX$
      NumHigh(<nWORD|cHexWORD>) --> nByte

   $ARGUMENTS$
      <nWORD|cHexWORD>  Designates either a decimal number or hexadecimal
      digit string.

   $RETURNS$
      The higher value byte of the <nWORD|cHexWORD> 16-bit number is returned.

   $DESCRIPTION$
      NumHigh() breaks down a 16-bit number into its two bytes and returns the
      higher byte as a result.  Use this for such functions as SCANKEY() or
      GETCURSOR(), because NumHigh() separates the two bytes of the keyboard
      scan code.

   $NOTES$
      ■  An invalid parameter returns a value of -1.

   $EXAMPLES$
      Break down the combined return value of GETCURSOR():

      ? "Starting line for the cursor is:", NumHigh(GETCURSOR())

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumLow()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumLow()
   $ONELINER$
      Returns the lower value byte in a 16-bit number
   $SYNTAX$
      NumLow(<nWORD|cHexWORD>) --> nByte

   $ARGUMENTS$
      <nWORD|cHexWORD>  Designates either a decimal number or hexadecimal
      digit string.

   $RETURNS$
      The lower value byte in the <nWORD|cHexWORD> 16 bit number is returned.

   $DESCRIPTION$
      NumLow() breaks down a 16-bit number into its two bytes and returns the
      higher byte as a result.  Use NumLow() with such functions as SCANKEY()
      or GETCURSOR(), so you can separate the two bytes of the keyboard scan
      code.

   $NOTES$
      ■  An invalid parameter returns a value of -1.

   $EXAMPLES$
      Breaks down the combined return value of GETCURSOR():

      ? "Last line for the cursor is:", NumLow(GETCURSOR())

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumHigh()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumMirr()
   $ONELINER$
      Mirrors 8-bit or 16-bit values
   $SYNTAX$
      NumMirr(<nNumber|cNumber>,[<l8/16bit>])
          --> nResult

   $ARGUMENTS$
      < nNumber/cNumber>  Designates a numeric value in the range of 0 to
      65535, or a hexadecimal string within which 8 or 16 bits are mirrored.

      <l8/16bit>  Designates whether 16 bits (.F.) or 8 bits (.T.) are
      mirrored.  The default value is .F..

   $RETURNS$
      NumMirr() returns a value by which the bit opposite the first parameter
      is mirrored.  If there is an invalid parameter, a value of -1 is
      returned.

   $DESCRIPTION$
      Use this function in the accompanying font editor to mirror characters
      with bit patterns.  Bits with values in 0 to 65535 range are mirrored.
      When you mirror bit 16, bit 1 interchanges with bit 16, bit 2 with bit
      15, etc..  You can also designate the first parameter as a hexadecimal
      string in "0ABE" form and the result is always numeric.

   $EXAMPLES$
      ■  Initialize the number to mirror:

         nVar  :=  128 + 64 + 8 + 2                // 00000000 11001010

      ■  Mirror bit 16:

         ? NToC(NumMirr(nVar), 2, 16, "0")         // 01010011 00000000

      ■  Only mirror bit 8:

         ? NToC(NumMirr(nVar, .T.), 2, 16, "0")    // 00000000 01010011

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumAnd(), NumHigh(), NumLow(), NumNot(), NumOr()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumNot()
   $ONELINER$
      Performs a 16-bit "NOT" of a number
   $SYNTAX$
      NumNot(<nWORD|cHexWORD>) --> nNegatedWORD

   $ARGUMENTS$
      <nWORD|cHexWORD>  Designates either a decimal number or hexadecimal
      digit string.

   $RETURNS$
      NumNot() returns the negated binary value of the <.nWORD|cHexWORD>
      parameter.  The 0 bits become 1, and 1 bits become 0.

   $DESCRIPTION$
      This function is especially useful with file attributes, error codes,
      and when you manipulate bit fields.

   $NOTES$
      ■  The function returns the 1's complement of a number.

      ■  An invalid parameter returns a result of -1.

   $EXAMPLES$
      Show the 1's complement of a number:

      The number:         00000101  00000000
      The complement:     11111010  11111111
      ? NumNot(5)         // Result: 65530

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumAnd(), NumOr(), NumXor(), SetBit(), IsBit()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumOr()
   $ONELINER$
      Performs a 16-bit "OR" of a list of numbers
   $SYNTAX$
      NumOr(<nWORD1|cHexWORD1>,<nWORD2|cHexWORD2>,
         [<nWORDncHexWORDn>]) --> nWORD-OR

   $ARGUMENTS$
      <nWORD1|cHexWORD1>...<nWORDn|cHexWORDn>  Designates either decimal
      numbers or hexadecimal digit strings.

   $RETURNS$
      The returned value corresponds to all the values designated as
      parameters joined with a logical OR.

   $DESCRIPTION$
      NumOr() allows you to target and set a single bit or multiple bits.  For
      example, use this to set a file attribute.

   $NOTES$
      ■  An invalid parameter returns a result of -1.

   $EXAMPLES$
      Set bit 5 in the MCR interface register of port 1, without changing any
      other bits:

      The register contains:      00000011
      The constant in binary:     00010000
                                  ________
      The result: (19)            00010011
      com_MCR(1, NumOr(com_MCR(1), 16))

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumAnd(), NumNot(), NumXor(), SetBit(), IsBit()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumRol()
   $ONELINER$
      Performs a 16-bit left rotation of a number
   $SYNTAX$
      NumRol(<nWORD1|cHexWORD1>,<nWORD2|cHexWORD2>,
         [<lLowByte>]) --> nWORDLeft-Rotated

   $ARGUMENTS$
      <nWORD1|cHexWORD1>  Designates a numeric or hexadecimal value in the
      range of 0 to 65535.

      <nWORD2|cHexWORD2>  Designates a number of rotations in the range of
      1 to 15 (1 to 7); as either numeric or hexadecimal.

      <lLowByte>  If this optional parameter is designated as .T., then
      the low byte of the specified WORD is rotated.  The default is a 16-bit
      rotation (.F.).

   $RETURNS$
      NumRol() returns the rotation result.

   $DESCRIPTION$
      This function rotates bits to the left in a number between 0 and 65535
      (16-bit value).  When the high bit rotates it is not just moved out to
      the left, it is also moved in on the right.  Use the optional logical
      parameter to determine if all 16 or only the low value 8 bits are to
      rotate.

   $NOTES$
      ■  If a value of > 15(7) is designated for <nWORD1|cHexWORD1>,
         the actual number of rotations for the remainder corresponds to a
         value divided by 16(8).

      ■  A right rotation is also possible.  One rotation to the right
         corresponds to 15(or 7) rotations to the left, etc..

   $EXAMPLES$
      ■  Rotate the 1 value three times to the left:

         00000000 00000001  00000000 00001000
         ? NToC(1, 2, 16, "0"), NToC(NumRol(1, 3), 2, 16, "0")
                                          // Display as binary

      ■  Value of 60000 -- only rotate the low 8-bit value:

         11101010 01100000  11101010 10000001
         NumRol(60000, 2, .T.)

      ■  Construct a rotation two places to the right:

         00000000 00000100  00000000 00000001
         ? NumRol(4, 14)

      ■  In parameter 2 > 15, there is only one rotation:

         ? NumRol(1, 33)                  // Result:  2

   $PLATFORMS$
      DOS
   $SEEALSO$
      NToC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumXor()
   $ONELINER$
      Performs a 16-bit "XOR" of two numbers
   $SYNTAX$
      NumXor(<nWORD1|cHexWORD1>,<nWORD2|cHexWORD2>)
          --> nWORD-XOR

   $ARGUMENTS$
      <nWORD1|cHexWORD1> and <nWORD2|cHexWORD2>  Designates as either
      decimal numbers or hexadecimal digit strings.

   $RETURNS$
      The returned value corresponds to all the values designated as
      parameters joined with a logical exclusive OR.

   $DESCRIPTION$
      Only those bits that are different in the 2-bit fields and that you want
      to link together, are set to 1 in the result value.  Use NumXor() to
      encode smaller numbers.

   $NOTES$
      ■  An invalid parameter returns a result of -1.

   $EXAMPLES$
      ■  Link two numbers with NumXor():

         Value 1 in binary:      00000011
         Value 2 in binary:      00000101
                                 ________
         The result: (6)         00000110
         ? NumXor(3, 5)                  // Result:  6

      ■  Encode and decode numbers:

         ? NumXor(NumXor(nNumber, 9), 9)

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumAnd(), NumNot(), NumOr(), SetBit(), IsBit()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Rand()
   $ONELINER$
      Generates random numbers
   $SYNTAX$
      Rand([<nStartValue>]) --> nRandomValue

   $ARGUMENTS$
      <nStartValue>  Designates a beginning value for the random number
      generator.

   $RETURNS$
      Rand() returns a random number between 0 and 1.

   $DESCRIPTION$
      In contrast to Random(), this function works with a seed algorithm.
      Multiple calls always returns the same random number sequence when it
      has the same start value.  When you first call Random() without a
      parameter, it starts as if 100001 is specified as a parameter.
      Subsequent random numbers can then be influenced by the < nStartValue>.
      If this value is less than or equal to 0, the clock time is brought into
      the process.

      If you call the function with 100001 as a parameter, it allows you to
      restart the generator.  Then, if you call the function several times
      without parameter, it returns the "standard sequence" of numbers.

   $EXAMPLES$
      ■  Call after program start:

         ? Str(Rand(), 18, 15)            // 0.831051100158447
         ? Str(Rand(), 18, 15)            // 0.557946857971956

      ■  If the parameter equals 0, the clock time is incorporated.
         Even if the clock has not yet advanced, subsequent values are still
         different:

         ? Str(Rand(), 18, 15)            // Time dependent
         ? Str(Rand(), 18, 15)            // Subsequent time
                                          // dependent value

      ■  Use a number greater than 0:

         ? Str(Rand(23), 18, 15)          // 0.121169930053736
         ? Str(Rand(23), 18, 15)          // 0.121169930053736

      ■  Show a "new start":

         ? Str(Rand(100001), 18, 15)      // 0.831051100158447
         ? Str(Rand(), 18, 15)            // 0.557946857971956

   $PLATFORMS$
      DOS
   $SEEALSO$
      Random()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Random()
   $ONELINER$
      Generates random numbers
   $SYNTAX$
      Random([<lMode>]) --> nRandomWORD

   $ARGUMENTS$
      <lMode>  Designates whether or not to return negative numbers.  The
      default creates only positive numbers.

   $RETURNS$
      Random() returns a random number in the range of 0 to 65535 or when
      <lMode> is designated as .T., in the range of -32768 to +32767.

   $DESCRIPTION$
      Random() produces random numbers to create a random distribution of test
      data for DEMO programs or any other application.

   $NOTES$
      ■  If the <lMode> parameter is not specified, only positive
         numbers are returned.  When < lMode> is set to .T., the function
         returns the same number of positive and negative numbers.

   $EXAMPLES$
      ■  Create a random number between 0 and 65535:

         ? Random()

      ■  Create a random number between 0 and 1:

         ? Random()/65535

      ■  Create a random whole number between 1 and 16:

         ? Random()%16 +1

      ■  Create a random number between -32768 and +32767:

         ? Random(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      Rand()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetBit()
   $ONELINER$
      Sets one or more bits in a number
   $SYNTAX$
      SetBit(<nLONG|cHexLONG>,<nBitPos1>,
         [<nBitPos32>]) --> nNewValue

   $ARGUMENTS$
      <nLONG|cHexLONG>  Designates either a decimal number or hexadecimal
      number string.

      <nBitPos1> ...  <nBitPos32>  Designates which bit numbers to
      set.

   $RETURNS$
      SetBit() sets the designated bits and returns the result.

   $DESCRIPTION$
      For example, SetBit() allows you to set one or more bits to change a
      serial interface register.  This is in contrast to NumOr(), where the
      bit numbers can be set and do not need to be previously converted.  The
      value 1 represents the bit with the lowest value; 32 is the bit with the
      highest value.

   $NOTES$
      ■  An invalid parameter returns a result of -1.

   $EXAMPLES$
      Set bits 1, 2, and 5 in a numeric field:

      nBitfield  :=  0
      nBitfield  :=  SetBit(nBitfield, 1, 2, 5)   // Result:  19

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumAnd(), NumNot(), NumOr(), NumXor(), IsBit()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Video Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      <b>Working With Video Functions</b>

       This module discusses video functions that are either directly or
       indirectly concerned with the screen.  Included are all functions that
       deal with such screen adapters as CGA, EGA and Hercules.  Different
       modes on various adapters are supported, such as a 40-column CGA, a 43-
       line EGA, or a 50-line VGA.

      <b>DSETWINDOW()</b>

       Many of the functions in this chapter depend on setting the DSETWINDOW()
       switch.  This switch determines if the screen output of external
       programs, as well as DOS, are redirected to a window.
       CA-Clipper Tools output functions are also valid as external.  If the
       default setting in DSETWINDOW() is .T. or on, this rerouting is carried
       out.  Some functions will then return inaccurate, or at the very least,
       different results.  Examples of this are ISANSI() or NUMCOL()

      <b>Attribute</b>

       Many of the functions in this module work with color attributes
       designated as parameters.  These arguments are carried out in three
       different ways:

       A numeric value, which corresponds to a combined color attribute
       (e.g., 7).

       A string in the "NN/NN" form, with two specified numeric values (e.g.,
       "7/0").

       A string in the "CC/CC" form, with two specified attributes are
       designated in the form CA-Clipper requires (e.g., "W/N").

       With many functions, the attribute returns a combined numeric value.
       Attributes for the foreground and background are tied together this way.

       Color attributes are constructed as follows:

       Bit                8 7 6 5        4 3 2 1
       Attribute          * R G B        + R G B
             _ _ _ _ _ _  /   _ _ _ _ _ _

             Background   /   Foreground

       Each attribute consists of four bits, which represent a value in the
       range of 0 to 15.  Therefore, there are a total of 16*16, or 256,
       different values from 0 to 255.  These numeric values can be changed
       into the "nn/nn" format, that can be used under CA-Clipper with the
       NTOCOLOR function.  However, it is possible to directly influence this
       combined attribute value.  The following examples show this and relate
       back to the chapter on number and bit manipulation:

       NumOr( nattr, 128)    // Flashing on
       NumAnd(nattr, 127)    // Flashing off
       NumXor(nattr, 128)    // Change flashing
       NumOr(nattr,  8)      // High intensity on
       NumAnd(nattr, 247)    // High intensity off
       NumXor(nattr,  8)     // Switch high intensity

      <b>Special Parameter Type</b>

       With many functions, a parameter may be of the <mIcCharacter|nCharacter>
       type (e.g., an individual character).  This can occur in two different
       ways:

       Numerically, as the ASCII code of the desired character (e.g., 7).

       Alphanumeric as the character (e.g., ":").

       Because of this, you must not use the Chr() function to change special
       characters.

      <b>CLEARA and CLEARB</b>

       Some of the CA-Clipper Tools functions use a standard attribute and
       character to  delete lines or screen areas.  This attribute is described
       as CLEARA; the character as CLEARB.  You can query both CLEARA and
       CLEARB with the corresponding functions.  At the same time, certain
       preset values are in effect for CLEARA and CLEARB.  The attribute "W/N"
       is the standard preset for CLEARA, while Chr(255) is the character used
       for CLEARB.  If you use this character for CLEARB, it fills the
       background with the corresponding color for every deletion on every
       screen adapter.

       Use the following functions to set standard values for CLEARA and
       CLEARB:

          GetClearA()
          SetClearA()
          GetClearB()
          SetClearB()

       If you use the SETCLEARx() functions in conjunction with the
       corresponding parameters (<Attribute> or <Character>), the currently
       existing default value is replaced by a parameter.

      <b>Clipper Functions and Commands Which Delete</b>

       If you use the CA-Clipper Extended Drivers, Chr(255) is used instead of
       a space for all CA-Clipper functions and commands that delete the screen
       in one way or another (see CLEARB).  A Chr(255) is helpful on many
       screen adapters, since in contrast to a space, you can assign it a
       color.  Then, the screen will not appear so fuzzy.

       More precisely, the functions and commands concerned always use the
       delete character set by SetClearB(), which uses Chr(255) as the default
       setting.  If you want to use a space to clear in CA-Clipper or
       CA-Clipper Tools, insert a SetClearB(32) into the program.

       Re-implement a space for clear:

          SetClearB(32)
          CLEAR         // The affected Clipper command

      <b>Video Modes</b>

       Occasionally, there is some confusion about video modes.  You will not
       be able to work in EGA mode just because your computer has an EGA
       adapter built into it.  By the same token, you will not get either EGA
       or VGA modes, if you do not work with graphics.

      <b>EGA43 / VGA50 / VGA28, etc.</b>

       In this section, the concern is not to just get a mode "hardwired"' into
       a card, but for CA-Clipper Tools it is to generate corresponding fonts
       and other settings.  For these reasons, the GETMODE() and GETSCRMODE()
       functions generate their own values that are greater than 255.

       For example, changes to the screen mode concerned with line count can be
       combined with a 40-column mode:

       CGA40()
       EGA43()          // 43 lines and 40 columns

      <b>Video Functions and Windows</b>

       You cannot implement functions that change the base address for screen
       memory while windows are open.  This includes all mode changes, as well
       as SETPAGE and SETSCRSTR.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharPix()
   $ONELINER$
      Returns the number of pixel lines per character
   $SYNTAX$
      CharPix() --> nPixelline

   $RETURNS$
      CharPix() returns a value that corresponds to the number of pixel lines
      per character.

   $DESCRIPTION$
      Different screen adapters build characters from a different numbers of
      pixel lines.  Based on the installed mode, the number of pixel lines for
      a particular type of screen adapter may also vary.

      Use CharPix() to determine the number of pixel lines available in the
      currently installed mode.  This information is useful when used in
      conjunction with SetCursor().

   $EXAMPLES$
      Display the number of pixel lines:

      ? CharPix()         // VGA, no mode change - 16

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetCursor(), SetFont(), FONTLOAD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CharWin()
   $ONELINER$
      Exchanges particular characters in a screen area.
   $SYNTAX$
      CharWin([<nTopline>,<nLeftcolumn>,<nBottomline>,
         <nRightcolumn>, [<cNewcharacter|nNewcharacter>],
         [<cOldcharacter|nOldcharacter>]]) --> cNull

   $ARGUMENTS$
      <nTopline>  Designates the line for the top-left corner of the area.

      <nLeftcolumn>  Designates the column for the top-left corner the
      area.

      <nBottomline>  Designates the line for the bottom-right corner of
      the area.

      <nRightcolumn>  Designates  the column for the bottom-right corner
      of the area.

      <cNewcharacter|nNewcharacter>  Designates the new character for the
      screen area.  Specify the parameter as a numeric in the range of 0 to
      255 or as a character string.  The default value is the CLEARB.

      <cOldcharacter|nOldcharacter>  Designates which character to
      exchange.  Specify the parameter as a numeric in the range of  0 to 255
      or as a character string.  The default is to exchange all characters.

      ()  When no parameter is designated, the function replaces all
      characters in the screen area with CLEARB.

   $RETURNS$
      The function always returns a null string.

   $DESCRIPTION$
      Within a screen area, CharWin() replaces all characters or just a
      particular character with a new one.  If <cNewcharacter|nNewcharacter>
      is not designated, the function uses the character set with SetClearB(),
      where the preset value is Chr(255).  The upper-left and lower-right
      corner rows and columns are given for the borders of the area.  If these
      arguments are missing, then the entire screen area is exchanged.

   $EXAMPLES$
      ■  Exchange all characters for CLEARB:

         SetClearB("X")       // Exchanges within CharWin() entire screen

      ■  Exchange all "A" for "B":

         CharWin(10, 10, 20, 70, "B", "A")    // Always returns a ("") null
                                              // string

      ■  Numeric characters can also be designated:

         CharWin(10, 10, 20, 70, 66, 65)      // A = 65, B = 66

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetClearB(), ColorWin(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ClearEol()
   $ONELINER$
      Clears from the cursor position to the end of line
   $SYNTAX$
      ClearEol([<nRow>], [<nColumn>], [<cAttr|nAttr>],
         [<cCharacter|nCharacter>]) --> cNull

   $ARGUMENTS$
      <nRow>  Designates the line to be erased.  The default is the cursor
      line.

      <nColumn >  Designates the column where the erasure is to begin.
      The default is the cursor column.

      <cAttrn|nAttr>  Designates the attribute used to clear.  The
      default is CLEARA.

      <cCharacter|nCharacter>  Designates the character used to clear.
      The default is CLEARB.

   $RETURNS$
      ClearEol() always returns a null string.

   $DESCRIPTION$
      Use ClearEol() to clear a specific line from a given position to the end
      of that line.  If arguments are not specified, then the current <nRow>
      cursor line and <nColumn> cursor column are used as the starting
      location.  The clear always goes to the end of the line specified with
      the CLEARA attribute and CLEARB character, or with the <Attr|nAttr>
      attribute and <cCharacter|nCharacter> character.

      ClearEol() has some advantages over the CA-Clipper  @ Row, Column
      commands:

      1. It lets you take the returned value of the character string type and
         combine it with string outputs (e.g., LIST...ClearEol()).

      2. The cursor position is not affected.

      3. The arguments are optional.  If they are not specified, the function
         clears from the current cursor position with the CLEARA attribute and
         CLEARB character.

   $NOTES$
      ■  You can specify the <cAttr|nAttr> attribute and the
         <cCharacter|nCharacter> character in a number of ways.  Please refer
         to the chapter introduction.

      ■  Default attribute and character can be set with SetClearA()
         and SetClearB().

      ■  If no arguments are specified for line or column, then the
         function will automatically orients itself to the current cursor
         position.

   $EXAMPLES$
      ■  Clear from the cursor position to the end of the line with the
         CLEARB character and CLEARA attribute:

         ClearEol()

      ■  Do the same for line 23 from the current cursor position:

         ClearEol(23)

      ■  Do the same as before, but begin the erasure at column 55:

         ClearEol(23, 55)

      ■  The attributes can be specified in different ways.  In the
         following three examples, the clear character is set with
         SetClearB():

         ClearEol(23, 55, 4)         // red on black
         ClearEol(23, 55, "4/7")     // red on white
         ClearEol(23, 55, "B/W")     // blue on white

      ■  Clear with special attribute and character:

         ClearEol(23, 55, "3/1", ":")
         ClearEol(23, 55, "B/W", "+")

   $PLATFORMS$
      DOS
   $SEEALSO$
      ClEol(), SetClearA(), SetClearB(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ClearSlow()
   $ONELINER$
      Deletes a screen area from the outside in with a delay
   $SYNTAX$
      ClearSlow(<nDelay>, [<nTopline>], [<nLeftcolumn>],
         [<nBottomline>], [<nRightcolumn>],
         [<cCharacter|nCharacter>]) --> cNull

   $ARGUMENTS$
      <nDelay>  Designates the time delay in milliseconds for the
      individual steps in the delete procedure.  The value is in the range of
      1 to 65535.

      <nTopline>  Designates the line for the top-left corner of the area.
      The default value is the topmost line.

      <nLeftcolumn>  Designates the column for the top-left corner of the
      area.  The default value is the leftmost column.

      <nBottomline>  Designates the line for the bottom-right corner of
      the area.  The default value is the bottommost line.

      <nRightcolumn>  Designates the column for the bottom-right corner of
      the area.  The default value is the rightmost column.

      <cCharacter|nCharacter>  Designates the character to use to clear
      the screen.  The character can be numeric in the range of 0 to 255 or a
      character string.  The default is the character set using SetClearB().

   $RETURNS$
      The function always returns a null string.

   $DESCRIPTION$
      ClearSlow() clears a screen area from the outside in, step by step, with
      time delays.  You can designate the delay in milliseconds.  If the
      parameters for the area coordinates are left out, the function clears
      the entire screen.  In this case, the delete character set through
      SetClearB() is used.  The preset value is Chr(255).  CA-Clipper Tools
      uses this character because, in contrast to Chr(32), it accepts a color
      attribute on all screen adapters.

   $NOTES$
      ■  If no screen coordinates are designated, the entire screen is
         cleared.

   $EXAMPLES$
      ■  Use Chr(255) to clear the entire screen with a 50-millisecond
         delay:

         ClearSlow(50)                       // Always returns ""

      ■  Clear an area with spaces and use a 10-millisecond delay:

         ClearSlow(10, 4, 4, 20, 76, 32)     // Delete character 32 (Blank)

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetClearB(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ClearWin()
   $ONELINER$
      Clears a screen area
   $SYNTAX$
      ClearWin([<nTopLine>], [<nLeftCol>], [<nBottomLine>],
         [<nRightCol>], [<cAttr|nAttr>],
         [<cCharacter|nCharacter>]) --> cNull

   $ARGUMENTS$
      <nTopLine>  Designates the topmost line where clearing is to begin.
      The default value is the cursor line.

      <nLeftCol>  Designates the leftmost column from which clearing is to
      begin.  The default value is the cursor column.

      <nBottomLine>  Designates the bottommost line to clear.  The default
      is the last screen line or window line.

      <nRightCol>  Designates the rightmost column to clear.  The default
      is the right screen border or window border.

      <cAttr|nAttr>  Designates the attribute to use to clear.  The
      default is the standard attribute CLEARA.

      <cCharacter|nCharacter>  Designates the character to use to clear.
      The default is the standard character CLEARB.

   $RETURNS$
      ClearWin() always returns a null string.

   $DESCRIPTION$
      ClearWin() clears a specified screen area.  This area extends from
       < nTopLine>  to <nBottomLine> and from <nLeftCol> to <nRightCol>.
      Without these parameters, the line and column that correspond to the
      current cursor position for <nTopLine> and <nLeftCol>, and the
      bottommost line and rightmost column are used for <nBottomLine> and
      <nRightCol>.

      You can clear with the standard attribute and character (CLEARA and
      CLEARB), or with the <cAttr|nAttr> attribute and the
      <cCharacter|nCharacter> character.

   $NOTES$
      ■  The <cAttr|nAttr> attribute and <cCharacter|nCharacter>
         character are specified in different ways.  Please refer to the
         Introduction of this chapter for more details

      ■  The standard attribute and character are set with SetClearA()
         and SetClearB().

      ■  If no parameters are specified for the line or column, the
         function automatically orients itself to the current cursor position.

   $EXAMPLES$
      ■  Clear from the cursor position to the end of the line with the
         CLEARB character and CLEARA attribute:

         ClearWin()

      ■  Do the same for line 23 from the current cursor position:

         ClearWin(23)

      ■  Clear a window between line 23, column 15 and line 24, column
         70:

         ClearWin(23, 15, 24, 70)

      ■  You can specify the attributes in different ways.  In the
         following three examples, the CLEARB() clear character is used.

         ClearWin(23, 15, 24, 70, 4)            // red on black<
         ClearWin(23, 15, 24, 70, "4/7")        // red on white
         ClearWin(23, 15, 24, 70, "B/W")        // blue on white

      ■  Clear when specifying attribute and character:

         ClearWin(23, 15, 24, 70, "B/W", "+")   // blue on white

   $PLATFORMS$
      DOS
   $SEEALSO$
      ClWin(), SetClearA(), SetClearB(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ClEol()
   $ONELINER$
      Clears characters and attributes to the end of a line
   $SYNTAX$
      ClEol([<nRow>], [<nColumn>]) --> cNull

   $ARGUMENTS$
      <nRow>  Designates the line to clear.  The default is the cursor
      line.

      <nColumn>  Designates the column from which to clear.  The default
      is the cursor column.

   $RETURNS$
      ClEol() always returns a null string.

   $DESCRIPTION$
      Implement the ClEol() function when you need to clear to black and
      cannot use the standard attribute and character.  This function is
      especially useful with a monochrome video card.  A significant advantage
      of ClEol() over ClearEol(), is the omission of the
      <cAttr|nAttr> and <cCharacter|nCharacter> parameters, which increase the
      speed of ClEol().  The function is faster because it does not note the
      CLEARA and CLEARB settings.

      ClEol() has some advantages over the CA-Clipper @ Row, Column commands:

      1. The function allows you to take the returned value of the character
         string type and combine it with string outputs (e.g.,
         LIST...ClEol()).

      2. The cursor position is not affected.

      3. The parameters are optional.  If they are not specified, the function
         clears from the current cursor position with the CLEARA attribute and
         the CLEARB character.

   $NOTES$
      ■  If no parameters are specified for line or column, the
         function automatically orients itself to the current cursor position.

   $EXAMPLES$
      ■  Clear from the current cursor position to the end of the line:

         ClEol()

      ■  Clear line 23, starting from the cursor column position to the
         end of the line:

         ClEol(23)

      ■  Clear line 23 from column 15 to the end of the line.

         ClEol(23, 15)

   $PLATFORMS$
      DOS
   $SEEALSO$
      ClearEol(), ClearWin(), ClWin(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ClWin()
   $ONELINER$
      Clears character and attribute from a screen area
   $SYNTAX$
      ClWin([<nTopLine>], [<nLeftCol>], [<nBottomLine>],
         [<nRightColumn>]) --> cNull

   $ARGUMENTS$
      <nTopLine>  Designates the topmost line where clearing should begin.
      The default is the cursor line.

      <nLeftCol>  Designates the leftmost column where erasure should
      begin.  The default is the cursor column.

      <nBottomLine>  Designates the bottommost line to clear.  The default
      is the last screen line or window line.

      <nRightColumn>  Designates the rightmost column to clear.  The
      default is the right screen border or window border.

   $RETURNS$
      ClWin() always returns a null string.

   $DESCRIPTION$
      Implement ClWin() when you need to clear to black without the use of the
      standard attribute and character.  This function is helpful when you use
      a monochrome video card.  A significant advantage of ClWin() over
      ClearWin(), is the omission of the <cAttr|nAtt> and
      <cCharacter|nCharacter> parameters, because it increases the speed of
      ClWin().  The function is faster because it does not note the CLEARA and
      CLEARB settings.

      ClWin() has some advantages over the Clipper @ Row, Column commands:

      1. This function takes the returned value of the character string type
         and combines it with string outputs  (e.g., LIST...ClWin()).

      2. The cursor position is not affected.

      3. The parameters are optional.  If they are not specified, the function
         clears from the current cursor position.

   $NOTES$
      ■  If no parameters are specified for the line or column, the
         function automatically orients itself to the current cursor position.

   $EXAMPLES$
      ■  Clear from the cursor position to the end of the screen area:

         ClWin()

      ■  Do the same from the current cursor position in line 23:

         ClWin(23)

      ■  Clear from line 23, column 15, to the end of line 24:

         ClWin(23, 15, 24)

      ■  Clear a window between line 23, column 15, and line 24, column
         70:

         ClWin(23, 15, 24, 70)

   $PLATFORMS$
      DOS
   $SEEALSO$
      ClearEol(), ClearWin(), ClEol(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ColorRepl()
   $ONELINER$
      Exchanges particular screen attributes
   $SYNTAX$
      ColorRepl([<cNewAttr|nNewAttr>],
         [<cOldAttr|nOldAttr>]) --> cNull

   $ARGUMENTS$
      <cNewAttr|nNewAttr>  Designates the new attribute.  The default is
      CLEARA.

      <cOldAttr|InOldAttr>  Designates the old attribute to exchange.  The
      default is all existing attributes.

   $RETURNS$
      ColorRepl() always returns a null string.

   $DESCRIPTION$
      ColorRepl() simplifies screen handling.  This function exchanges all
      occurrences of the <cOldAttr|nOldAttr> attribute for the
      <cNewAttr|nNewAttr> attribute.

      For example, after a READ, you could take the colors in all input
      fields, (assuming they have a common attribute), and change them.  This
      designates these fields as no longer active.

   $NOTES$
      ■  If the <cOldAttr|nOldAttr>parameter is not specified, then all
         screen attributes (without exception) are exchanged for
         <cNewAttr|nNewAttr>.  If <cNewAttr|nNewAttr> is also missing, then
         <cOldAttr|nOldAttr> is exchanged for the CLEARA standard attribute.

   $EXAMPLES$
      ■  Exchange the attribute 7 (white on black) for 0 (black on
         black= invisible):

         ColorRepl(0, 7)

      ■  Replace all attributes for attribute 116 (red on white):

         ColorRepl(116)

      ■  Exchange the attribute "7/0" (white on black) for 116 (red on
         white):

         ColorRepl(116, "7/0")

      ■  Exchange all attributes for the CLEARA standard attribute:

         ColorRepl()

      ■  Change the display from white on black to black on white.  You
         can specify different parameters:

         ColorRepl("0/7", "7/0")
         ColorRepl(112, 7)

      ■  Mixed formats are also possible:

         ColorRepl("0/7", 7)

   $PLATFORMS$
      DOS
   $SEEALSO$
      ColorWin(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ColorToN()
   $ONELINER$
      Converts NN/NN or CC/CC color values into numeric values
   $SYNTAX$
      ColorToN(<cAttr>) --> nAttr

   $ARGUMENTS$
      <cAttr>  Designates the alphanumeric color attribute that is
      converted in NN/NN or CC/CC form.

   $RETURNS$
      ColorToN() returns a number that corresponds to the combined numeric
      color attribute.

   $DESCRIPTION$
      COLOR TO (N)umeric
      The function changes an alphanumeric color attribute from NN/NN or CC/CC
      into a combined numeric attribute.  These combined attribute values are
      useful with the CA-Clipper Tools functions StrScreen(), ScreenMix(),
      ScreenAttr(), and the CA-Clipper commands SAVE/RESTORE SCREEN.

      ColorToN() makes it easy to create numeric attributes for the
      CA-Clipper Tools functions.

   $NOTES$
      ■  If you specify an invalid attribute string, ColorToN() returns
         the numeric attribute 0, meaning black on black (invisible).

   $EXAMPLES$
      ■  Show the "normal" display (white on black); all alphanumeric
         forms yield 7:

         ? ColorToN("07")
         ? ColorToN("07/00")
         ? ColorToN("W/N")

      ■  Display red on white; all alphanumeric forms yield the numeric
         attribute 116:

         ? ColorToN("04/07")
         ? ColorToN("R/W")

      ■  If the foreground color is missing,  0 is assumed.  Here it
         corresponds to an inverse video display:

         ? ColorToN("/7")

      ■  High intensity (+) and flashing (*) are also recognized:

         ? ColorToN("BR+")
         ? ColorToN("BR+*")
         ? ColorToN("G/BR+*")
         ? ColorToN("+G*/BR")

      ■  An invalid parameter returns 0:

         ? ColorToN()

      ■  Parameters of the <cAttr|nAttr> type are allowed.  A numeric
         attribute remains numeric.

         ? ColorToN(112)         // Result:  112

   $PLATFORMS$
      DOS
   $SEEALSO$
      NToColor(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ColorWin()
   $ONELINER$
      Exchanges particular attributes in a screen area
   $SYNTAX$
      ColorWin([<nTopLine>], [<nLeftCol>],
         [<nBottomLine>], [<nRightCol>],
         [<cNewAttr|nNewAttr>], [<cOldAttr|nOldAttr>])
          --> cNull

   $ARGUMENTS$
      <nTopLine>  Designates the topmost line to begin processing.  The
      default is the cursor line.

      <nLeftCol>  Designates the leftmost column to begin processing.  The
      default is the cursor column.

      <nBottomLine>  Designates the bottommost line that is processed.
      The default is the last screen line or window line.

      <nRightCol>  Designates the rightmost column to clear.  The default
      is the right screen border or window border.

      <cNewAttr|nNewAttr>  Designates the new attribute to replace the old
      one.  The default is the standard attribute CLEARA.

      <cOldAttr|nOldAttr>  Designates the old character to exchange.  The
      default is "exchange all attributes".

   $RETURNS$
      ColorWin() always returns a null string.

   $DESCRIPTION$
      ColorWin() exchanges all occurrences of <cOldAttr|nOldAttr>for the
      <cNewAttr|nNewAttr> attribute, within a particular screen or window
      area.  The function operates in a similar way to ColorRepl(), except
      with ColorWin() you can define the screen area to work on.

      The parameters <nTopLine> and <nLeftCol> define the row and column for
      the top-left corner; <nBottomLine> and <nRightCol> define the row and
      column for the bottom-right column.

   $NOTES$
      ■  If <cOldAttr|nOldAttr> is not specified, all attributes are
         exchanged for <cNewAttr|nNewAttr>; if <cNewAttr|nNewAttr> is not
         specified, the attributes are exchanged for CLEARA.

   $EXAMPLES$
      ■  Exchange attribute 7 (white on black) for 0 (black on black =
         invisible) from the current cursor position to the end of the screen
         area:

         ColorWin(0, 7)

      ■  Exchange all attributes in the area from line 23, column 15 to
         line 24, column 70 for the standard attribute CLEARA:

         ColorWin(23, 15, 24, 70)

      ■  Replace all attributes for attribute 116 (red on white) in the
         region from line 23, column 15 to line 24, column 70:

         ColorWin(23, 15, 24, 70, 116)

      ■  Change the white on black display to black on white.  You can
         specify different parameters:

         ColorWin(23, 15, 24, 70, "0/7", "7/0")

      ■  Mixed formats are also possible:

         ColorWin(23, 15, 24, 70, "0/7", 7)

   $PLATFORMS$
      DOS
   $SEEALSO$
      ColorRepl(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      EGAPALETTE()
   $ONELINER$
      Changes EGA palette colors
   $SYNTAX$
      EGAPALETTE([<cColor1|nColor1>, [<nPalette>])
          --> lValid

      or

      EGAPALETTE([<cColor1|nColor1>, [<cColor2>]])
          --> lValid

   $ARGUMENTS$
      <cColor1|nColor1>  Designates the color to change as a CA-Clipper
      color code or a numeric in the 0 to 15 range.  If only this color is
      given, the accompanying palette is reset to its default value.

      <nPalette>  Designates which color palette the color
      <cColor1|nColor1> is assigned to.  May be in the range of 0 to 63.

      <cColor1|nColor1>, <cColor2>  If a color is also designated as a
      second parameter, then that color's palette is designated as
      <cColor1|nColor1>.

      () When no parameters are designated, all color palettes are reset to
      their default values.

   $RETURNS$
      EGAPALETTE() returns .T. when the selected setting is successfully
      implemented.

   $DESCRIPTION$
      EGAPALETTE() allocates one of the 16 colors available to another color
      palette.  Since the function changes the screen adapter, everything on
      the screen designated with <cColor1|nColor1> also changes.

      Instead of a palette value, you can designate a second color.  Its
      palette setting is allocated to the one designated in <cColor1|nColor1>,
      so that two of the 16 colors are identical.

      If only the <cColor1|nColor1> parameter is given, then the accompanying
      palette is reset to its default value.  When calling the function
      without parameters, all palettes are reset.

   $NOTES$
      ■  You can also implement EGAPALETTE() in VGA mode, although
         VGAPalette() provides more flexibility.

      ■  FONTRESET() resets all color palettes.

   $EXAMPLES$
      ■  Redefine the color blue to dark blue:

         SET COLOR TO B            // Set blue
         ? "Nantucket"             // Appears in blue
         EGAPALETTE("B", 8)        // Affects everything blue.

      ■  Reset the palette for the color blue:

         EGAPALETTE("B")
         Reset all palettes
         EGAPALETTE()

   $PLATFORMS$
      DOS
   $SEEALSO$
      VGAPalette(), FONTRESET()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Enhanced()
   $ONELINER$
      Selects the enhanced color value for SET COLOR TO output
   $SYNTAX$
      Enhanced() --> cNull

   $RETURNS$
      Enhanced() always returns a null string

   $DESCRIPTION$
      Use Enhanced() to specify the color attribute designated as enhanced
      (second color value), with SET COLOR TO as the active attribute for CA-
      Clipper @...SAY and ? output.  Use Standard() to switch back to the
      default attribute.

   $EXAMPLES$
      Output with enhanced attribute:

      ? "........"
      ? "........"

      Enhanced()
         ? "Different Attribute!"
      Standard()
      ? "........"
      ? "........"

   $PLATFORMS$
      DOS
   $SEEALSO$
      Standard(), Unselected()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileScreen()
   $ONELINER$
      Reads screen content from a file
   $SYNTAX$
      FileScreen(<cFileName>, [<nOffset>]) --> nByte

   $ARGUMENTS$
      <cFileName>  Designates the name and path of the screen file.

      <nOffset>  Designates from which part of the file offset the screen
      is to be read.  The default is the beginning of file.

   $RETURNS$
      FileScreen() returns the number of bytes read.

   $DESCRIPTION$
      FILESCREEEN() is the opposite of ScreenFile().  Use FileScreen() to read
      and display a screen stored with ScreenFile().  Use the <nOffSet>
      parameter to indicate an offset from which the file is to be read.
      Since the number of bytes written with ScreenFile() is known, you can
      compute the location within the file of the beginning of the new screen.
      This allows you to save multiple screens in a single file.

   $NOTES$
      ■  The file read with FileScreen() can also contain end of file
         markers.  The read procedure does not end prematurely as a result,
         since the function always reads 4000 bytes.

   $EXAMPLES$
      ■  Read a screen from the beginning of a file:

         FileScreen("screen.tst")

      ■  Read the second screen.  Since the offset is specified as
         4000, the first screen is skipped:

         FileScreen("screen.tst", 4000)

      ■  Drive and path are permitted:

         FileScreen("\screen.tst")
         FileScreen("a:screen.tst")

      ■  Wildcards are not permitted:

         FileScreen("screen.*")         // Result:  0

   $PLATFORMS$
      DOS
   $SEEALSO$
      ScreenFile()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FONTLOAD()
   $ONELINER$
      Loads EGA/VGA fonts from another file
   $SYNTAX$
      FONTLOAD(<cFileName>, <nFontArea>, [<nOffset>],
         [<nCounter>]) --> nErrorCode

      or

      FONTLOAD (<cFileName>, <nFontArea>,
         [<lOtherPixelHeight>])--> nErrorCode

   $ARGUMENTS$
      <cFileName>  Designates the name and path of the font file.

      <nFontArea>  Designates the number of the specified font area.  For
      EGA, the values 1 to 4 are allowed, or whatever values MAXFONT()
      permits.  For VGA, the values 1 to 8 are allowed, or whatever MAXFONT()
      permits.

      <nOffset>  Designates from what character position the screen
      adapter font table is overwritten.  The default value is 0.

      <nCounter>  Designates how many characters to load from the new
      font.  The default value is 256.

      <lOtherPixelHeight>  Designates .T. to allow the function to modify
      the pixel height.  This leads to a mode change and character count.
      Please note that you must designate both <nOffset> and <nCounter> to
      implement this parameter.

   $RETURNS$
      The function returns an error code which corresponds to the explanation
      below:

      Table 6-1: Values returned for FONTLOAD()
      <table>
          Error Code   Explanation

           0           Font loaded successfully
          -2           Impossible in current video mode
          -3           Font file not found
          -4           The <lOtherPixelHeight> mode is not possible (the Extended
                       Drivers are not linked in)
         </table>

   $DESCRIPTION$
      FONTLOAD() allows you to load the font definitions from a file into the
      font area of an EGA or VGA card.  Use FONTSELECT() to determine which
      fonts serve as normal and high density for output.

      You may already have some of these fonts on the CA-Clipper Tools disk,
      and others can be created with the accompanying font editor.

      *Technical Background*

      The EGA and VGA cards permit you to modify a portion or all 256
      characters of the character generator with software.  To do this, a
      previously created pixel pattern for the character is loaded in the
      corresponding position in a font area on the screen card.  Normally, an
      EGA card has a maximum of four font areas and a VGA has eight, within
      which you can redefine all 256 characters.  Use MAXFONT() to determine
      the exact count of font areas.

      Building fonts into a program requires unnecessary memory space.
      Constructing fonts as a string within a program is also awkward.  With
      the GETFONT() and SetFont() functions, you can load a font from a screen
      card into a string variable, or from such a variable, into a font area
      on the card.  However, FONTLOAD() only allows you to load a font from a
      file into a particular area of the screen card.  In both cases, use
      ONTSELECT() to activate the loaded font.

      On the CA-Clipper Tools sample disk, you will find a font editor to
      construct new fonts in CA-Clipper source code.

      *Variable Pixel Height*

      In principle, EGA and VGA screen adapters provide the opportunity to
      display fonts with 2 to 32 pixels per character (1 pixel/character only,
      when there are 200 scan lines).  ROM fonts are only available for pixel
      heights of 8, 14 and 16, which accounts for the great expansion of the
      EGA 25-/43-line modes and VGA 25-/28-/50-line modes.  You must construct
      individual fonts for all other pixel heights.  The CA-Clipper font
      editor can make this easy.

      When FONTLOAD() loads a font, it also computes the pixel height from the
      font data length.  Since a font file always contains all 256 character
      definitions, there is a formula:

         Pixel height = Len(Font-Data)/256

      The <lOtherPixelHeight> parameter determines whether the fonts that do
      not match the pixel height just set are accepted.  This must be
      explicitly indicated, since the line count and screen mode will change.
      For this reason, you must always link in the CTUS.LIB Extended Drivers
      (see Table 6-1, returned value -4).

   $NOTES$
      ■  You cannot use FONTRESET() when a font is loaded for which
         there is no associated ROM font (all pixel heights except 8, 14, 16).
         Prior to a FONTRESET(), switch back to a permissible mode.

      ■  All previously successful FONTSELECT() settings are discarded
         again during FONTLOAD().

      ■  If an EGA card does not span the entire memory range, then you
         can reduce a maximum of four available font areas.  MAXFONT()
         determines the number of available fonts.

   $EXAMPLES$
      ■  Load all 256 characters of an EGA font in area 2:

         ? FONTLOAD("\FONTS\OLDENG.014", 2)              // 0 OK<
         FONTSELECT(2)

      ■  Exchange the fonts for the upper 128 characters in area 3:

         ? FONTLOAD("\FONTS\OLDENG.EGA", 3, 128, 128)    // 0 OK
         FONTSELECT(3)                                   // Select

      ■  Load a 24-pixel font in the last font area:

         ? FONTLOAD("\FONTS\PC.024", MAXFONT(), .T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      FONTSELECT(), FONTRESET(), GETFONT(), SetFont()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FONTRESET()
   $ONELINER$
      Resets all font and palette changes to the ROM defaults
   $SYNTAX$
      FONTRESET() --> lReset

   $RETURNS$
      FONTRESET() returns .T. when all font and palette settings are reset.

   $DESCRIPTION$
      This function resets all the settings implemented with FONTLOAD(),
      SetFont(), and FONTSELECT().  Settings implemented with EGAPALETTE() or
      VGAPalette() are also reset.  In addition, the border color set with SET
      COLOR TO is reset.

      Table 6-2: Settings affected by FONTRESET()
      <table>
          Settings                    Functions concerned

          All font information        FONTLOAD(), FONTSELECT, SetFont()
          All palette information.    EGAPALETTE(), VGAPalette()
          Border attribute            CA-Clipper:  SET COLOR TO
         </table>

   $NOTES$
      ■  No ROM fonts exist for screen modes that are not based on 8,
         14 or 16 pixels.  You cannot implement FONTRESET() in this situation.

   $EXAMPLES$
      Reset all changes to fonts and palettes:

      ? FONTRESET()         // .T., if ok

   $PLATFORMS$
      DOS
   $SEEALSO$
      FONTLOAD(), FONTSELECT(), EGAPALETTE(), VGAPalette()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FONTROTATE()
   $ONELINER$
      Rotates and mirrors images within a font string
   $SYNTAX$
      FONTROTATE(<cFontstring>,<nTurnDirection>
         [<nPixelHeight>],[<nStart>]) --> cNewFontString

   $ARGUMENTS$
      <cFontstring>[@]  Designates the font in character string form,
      within which the characters are rotated or mirrored.

      <nTurnDirection>  Designates the rotation axis or rotation direction
      in numeric form with a value from 1 to 3 (see Description).

      <nPixelHeight>  Designates the accompanying pixel height and number
      of bytes that represent an individual character within a font string.
      This is only necessary for modes 1 and 3.

      <nStart>  (This is for only for mode 1.)  Designates from which
      pixel line (from which byte), the 8 bytes are rotated.  Based on
      <nPixelHeight>, the bytes before and after this range are deleted (set
      to 0).  The first byte of the character corresponds to the 0 value.

   $RETURNS$
      If CSetRef() is not implemented, FONTROTATE() returns an amended font
      string.

   $DESCRIPTION$
      FONTROTATE() rotates the characters within a font string in different
      directions.  Rotation direction affects the number of characters that
      can rotate.

      *Constructing Fonts*

      If a font is transferred to a string with GETFONT() and the same number
      of bytes are used for an individual character each time, as specified by
      the current font height from CharPix().  For example, if a 14-pixel font
      is installed, then the font string contains 256 groups of 14 bytes.
      Each of these bytes represents a horizontal pixel line.  Since the
      characters are always 8 pixels wide, one bit always represents this
      pixel.

      *Direction of Rotation 1*

      If a font uses GETFONT() to transfer a string, then a comparable number
      of bytes are used each time for an individual character, as specified by
      the current font height in CharPix().  Since only an
      8-pixel width is ever available, only 8 bytes are rotated for each
      character every time.  To determine these bytes, you must designate the
      pixel height <nPixelheight> and the start of the 8-byte area
       <nStart> .  All bytes above and below the rotation are cleared (set to
      0). The rotation point is determined by the computation <nStart> + 4.

      *Direction of Rotation 2*

      In this mode, the characters are rotated 180 degrees on the vertical
      axis (the Y-axis), and thereby mirrored.  The <nPixelheight> and
      <nStart> parameters are unnecessary, since only the bits in each byte
      are mirrored.

      *Direction of Rotation 3*

      In this mode, the characters are rotated 180 degrees on the horizontal
      axis (X-axis), and thereby mirrored in the other direction.  You must
      specify the <nPixelheight> parameter.  The <nStart> parameter is not
      needed, since the character is affected through its entire height.

      *Combinations*

      Since modes 1 to 3 support all three rotation directions, multiple
      function calls allow you to combine the rotation operations and create
      rotated and mirrored characters.

   $NOTES$
      ■  The entire string is always worked on.  If you only want to
         change a region of characters on the screen, it can be done easily
         and is regulated by the SetFont() optional parameter, when you write
         the font back to the screen adapter.

      ■  If the parameter is passed by reference, use CSetRef() to
         suppress the return value and increase the speed.

   $EXAMPLES$
      In the following example, the screen is first filled with characters and
      then rotated.  This is particularly useful in the VGA 50-line mode,
      since it has an 8 x 8 pixel matrix and none of the characters are cut
      off.

      All parameters for FONTROTATE() are designated in such a generalized
      manner that you can use them for other pixel relationships.

      CSetRef(.T.)                   // Optimize by reference method
      nMODE  := GETSCRMODE()         // Save old mode
      VGA50()
      FOR I := 0 TO MaxRow()         // Build screen
         @ I, 0 SAY Center("ABCDEFGHIJKLMNOPQRSTUVWXYZ- 1234567890")
      NEXT I
      nPixel  :=  CharPix()          // Determine font pixel count
      cFont   :=  GETFONT()          // Load font to variable
      nKey      :=  0
      DO WHILE Key <<>> 27
         Millisec(100)               // Time delay
         FONTROTATE(@cFont, 1, nPixel, (nPixel-8)/2)
         SetFont(cFont)
         nKey  :=  Inkey()
      ENDDO
      SETSCRMODE(nMODE)              // Reset to original mode
      RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetFont(), CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FONTSELECT()
   $ONELINER$
      Determines font areas for normal- and high-intensity output
   $SYNTAX$
      FONTSELECT(<nFontArea>, [<nIntensiveFontArea>])
          --> nErrorCode

   $ARGUMENTS$
      <nFontArea>  Designates which font area the normal output mode
      should use.

      <nIntensiveFontArea>  Designates which font area the higher-
      intensity output mode should use.  The default is <nFontArea>.

   $RETURNS$
      FONTSELECT() returns an error code with the following meaning:

      Table 6-3: Error code definitions
      <table>
          Code    Definition

           0      Font loaded successfully
          -1      Invalid font area specified
          -2      Impossible in current video mode
         </table>

   $DESCRIPTION$
      This function selects the font areas for both normal output and higher-
      intensity output.  Use SET COLOR TO with "+", to bring up to 512
      different characters to the screen at the same time.  The second font is
      displayed at a higher intensity.  If this is not what you want, you can
      change the display (not the attribute itself) with
      EGAPALETTE()/VGAPalette().  The system is preset for both output modes
      and corresponds to a call of FONTSELECT(1, 1).

   $NOTES$
      ■  After you change the video mode with SETSCRMODE(), the fonts
         must be re-selected.

   $EXAMPLES$
      ■  Show font area 1 with normal output and area 4 with high
         intensity:

         ? FONTSELECT(1, 4)      // 0  OK
         SET COLOR TO W
         ? "Nantucket"           // Output over font 1
         SET COLOR TO W+         // Output over font 4

      ■  Show font area 2 for both output modes:

         ? FONTSELECT(2)

   $PLATFORMS$
      DOS
   $SEEALSO$
      FONTLOAD(), FONTRESET(), SETSCRMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetClearA()
   $ONELINER$
      Queries the current attribute for the clearing functions
   $SYNTAX$
      GetClearA() --> nClearAttribute

   $RETURNS$
      GetClearA() returns the value of the current standard attribute.

   $DESCRIPTION$
      GET CLEAR (A)ttribute
      This function determines the standard attribute for some CA-Clipper
      Tools functions with screen output.  In this discussion, the attribute
      is referred to as CLEARA and the character as CLEARB.  GetClearA()
      queries the current standard attribute.

   $NOTES$
      ■  The standard attribute is 7 (white on black), if no other
         attribute is set with SetClearA().

   $EXAMPLES$
      Display the current standard attribute:

      GetClearA()         // e.g. 7

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetClearA(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetClearB()
   $ONELINER$
      Queries the default character for the clearing functions
   $SYNTAX$
      GetClearB() --> nClearCharacter

   $RETURNS$
      GetClearB() returns the value of the current standard character CLEARB.

   $DESCRIPTION$
      GET CLEAR (B)yte
      This function determines the standard character for some CA-Clipper
      Tools functions with screen output.  In this discussion, the attribute
      is referred to as CLEARA and the character as CLEARB.  GetClearB()
      queries the current standard character set as CLEARB.

   $NOTES$
      ■  The standard character is Chr(255) when no other character is
         set with SetClearB().

   $EXAMPLES$
      Display the current standard character:

      ? GetClearB()         // e.g. 255

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetClearB(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETFONT()
   $ONELINER$
      Queries the current font
   $SYNTAX$
      GETFONT([<nFontArea>]) --> cFontString

   $ARGUMENTS$
      <nFontArea>  Designates out of which font area within the screen
      adapter, the font is loaded into a string.  Values from 1 to MAXFONT()
      are permitted.

   $RETURNS$
      GETFONT() returns a font from the selected area in string form.

   $DESCRIPTION$
      GETFONT() transfers a font table from an available font area on the
      screen card into a string.  This allows you to store loaded fonts.

   $NOTES$
      ■  If an invalid value is specified for <nFontArea>, the function
         returns a null string.

   $EXAMPLES$
      ■  Save font 1 ...

         cVar  := GETFONT(1)

      ■  ...and reset again:

         ? SetFont(cVar, 1)      // 0, if OK

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetFont(), FONTLOAD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETSCRSTR()
   $ONELINER$
      Queries screen output that was redirected by SETSCRSTR()
   $SYNTAX$
      GETSCRSTR() --> cHiddenCharacterstring

   $RETURNS$
      GETSCRSTR() returns the content of the internal memory area determined
      by SETSCRSTR().

   $DESCRIPTION$
      GETSCRSTR() returns the contents of the internal memory area (determined
      by SETSCRSTR(.T.)) for hidden screen output .  This return value has a
      length that always corresponds to SCREENSIZE(.T.).  You can pass it to a
      variable and after the mode is switched off, transfer it to the CA-
      Clipper RestScreen() function.  The variable must be passed before the
      redirected output mode is shut off with SETSCRSTR(.F.).  Otherwise, the
      internal memory area is deallocated and GETSCRSTR() returns a null
      string.

   $NOTES$
      ■  Since the entire screen output is always redirected
         (independent of its actual size), you should always call RestScreen()
         with the maximum coordinates of 0, 0, MaxRow(), and MaxCol()

   $EXAMPLES$
      ■  Show hidden output, switched back to the physical screen, if
         the need should arise:

         WSelect(0)
         ? SETSCRSTR(.T.)            // .T., when mode on
         @ 10, 10 SAY "XXXXXXX"      // Normal screen output
            *...
         @ 15, 10 SAY "YYYYYYY"

      ■  Always call the GETSCRSTR() function before SETSCRSTR(.F.)

         cVar  :=  GETSCRSTR()
         ? SETSCRSTR(.F.)            // .F. when mode off
         RestScreen(0, 0, MaxRow(), MaxCol(), cVar)

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETSCRSTR(), MaxRow(), MaxCol()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETVGAPAL()
   $ONELINER$
      Determines the palette settings on a VGA card
   $SYNTAX$
      GETVGAPAL(<nColor|cColor>,<cRGB>)
          --> nPaletteValue

   $ARGUMENTS$
      <nColor>|<cColor>  Designates a color represented by a number in the
      range of 0 to 15, or a color code that corresponds to the one in SET
      COLOR TO.

      <cRGB>  May designate as R, G, or B to determine the corresponding
      palette value.

   $RETURNS$
      GETVGAPAL() returns the red, green, or blue palette value for the
      designated color.  When invalid paramerters are specified, a value of -1
      is returned.

   $DESCRIPTION$
      On a VGA adapter, each color is a combination of the three values for
      red, green and blue.  Each value can be in the range of 0 to 63, to
      permit you to install different color palettes.

      GETVGAPAL() queries the R, G, and B values for all 16 colors.  The
      individual color can be a number in the range of 0 to 15, or represented
      as a color code corresponding to the CA-Clipper SET COLOR TO.

   $NOTES$
      ■  This function is implemented in the enclosed Colorpal.prg
         program.

   $EXAMPLES$
      Determines the palette value of red in the color cyan:

      GETVGAPAL("BG", "R")

   $PLATFORMS$
      DOS
   $SEEALSO$
      VGAPalette()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      InvertAttr()
   $ONELINER$
      Inverts the foreground and background of an attribute
   $SYNTAX$
      InvertAttr(<cAttr|nAttr>) --> nInvertAttr

   $ARGUMENTS$
      <cAttr|nAttr>  Designates the attribute to process.

   $RETURNS$
      InvertAttr() returns the value of the inverted attribute.

   $DESCRIPTION$
      InvertAttr() returns a value that corresponds to the opposite of an
      individual screen attribute.  This is same as if you were to exchange
      the foreground color for the background.  For example, red characters on
      a white background, become white characters on a red background.

      This new attribute can be used in conjunction with such functions as
      ScreenAttr(), ColorWin(), and ColorRepl().

   $NOTES$
      ■  The flashing and high-intensity attributes are not affected.

      ■  The result is always numeric, regardless of the parameter's
         data type.

   $EXAMPLES$
      ■  Invert the attributes at the current cursor position.  In
         doing so, the attribute is not set:

         ? INVERATTR(ScreenAttr())

      ■  You can represent the attribute in a number of different ways.
         The returned value is always numeric:

         8                           // Result:  30

      ■  An invalid attribute:

         ? InvertAttr("xx/yy")       // Result:  0

   $PLATFORMS$
      DOS
   $SEEALSO$
      ScreenAttr(), NToColor()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      InvertWin()
   $ONELINER$
      Inverts all attributes in an area of the screen
   $SYNTAX$
      InvertWin([<nTopLine>], [<nLeftColumn>],
         [<nBottomLine>], [<nRightColumn>]) --> cNull

   $ARGUMENTS$
      <nTopLine>  Designates the topmost line for the top-left corner of
      the area.  The default is the cursor position.

      <nLeftColumn>  Designates the leftmost column for the top-left
      corner of the area.  The default is the cursor position.

      <nBottomLine>  Designates the bottommost line for the bottom-right
      corner of the area.  The default is the end of the screen area.

      <nRightColumn>  Designates the rightmost column for the bottom-right
      corner of the area.  The default is the end of the screen area.

   $RETURNS$
      The function always returns a null string.

   $DESCRIPTION$
      This function permits you to invert all attributes within a screen area.
      Background attributes are exchanged for those in the foreground.

   $EXAMPLES$
      ■  Invert the attributes in an area:

         InvertWin(10, 10, 20, 70)      // Always returns a null string

      ■  Invert to end of screen:

         InvertWin(10, 10)

   $PLATFORMS$
      DOS
   $SEEALSO$
      InvertAttr()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsCGA()
   $ONELINER$
      Tests for presence of a CGA card or if one can be emulated
   $SYNTAX$
      IsCGA([<lMode>]) --> lCGA

   $ARGUMENTS$
      <lMode>  When designated as .T., tests to see if a CGA card is
      available.  The default value of .F. tests to see if a CGA adapter can
      be emulated.

   $RETURNS$
      Depending on the <lMode> parameter, IsCGA() returns .T. when a CGA card
      is available, or if a CGA adapter can be emulated.

   $DESCRIPTION$
      You can determine two things with this function.  When designated as .F.
      or when called without a parameter, IsCGA() tests it see if a CGA
      adapter can be emulated.  This can be the case with an EGA or VGA card.
      When designated as .T., the function determines if a CGA card is
      available.

   $NOTES$
      ■  Use GETMODE() to determine which mode is active.

   $EXAMPLES$
      Can CGA be emulated?

      IF IsCGA()
      *...
      ENDIF
      CGA-Card?
      IF IsCGA(.T.)
      *...
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      VideoType(), GETMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsEGA()
   $ONELINER$
      Determines if an EGA card is present or can be emulated
   $SYNTAX$
      IsEGA([<lMode>]) --> lEGA

      Important!  Contains <lMode>, an additional optional parameter over
      and above the original CA-Clipper Tools.

   $ARGUMENTS$
      <lMode>  When designated as .T., determines if an EGA card is
      present.  The default value of .F. tests to see if an EGA adapter can be
      emulated.

   $RETURNS$
      In conjunction with the <lMode> parameter, IsEGA() returns .T. when an
      EGA card is present or an EGA adapter can be emulated.

   $DESCRIPTION$
      This function determines two things.  When <lMode>  is designated as .F.
      or the function is called without a parameter, IsEGA() determines if an
      EGA adapter can be emulated.  This could be the case with a VGA card.
      When <lMode> is .T.,  it determines if an EGA card present.

   $NOTES$
      ■  Use GETMODE() to determine the active mode.

   $EXAMPLES$
      Can EGA be emulated?

      If IsEGA()
         * ...
      ENDIF
      EGA card?
      IF IsEGA(.T.)
         * ...
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      VideoType(), GETMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsHercules()
   $ONELINER$
      Determines if a HERCULES card is present or can be emulated
   $SYNTAX$
      IsHercules([<lMode>]) --> lHERCULES

      Important!  Contains <lMode>, an additional optional parameter over
      and above the original CA-Clipper Tools.

   $ARGUMENTS$
      <lMode>  When designated as .T., determines if a HERCULES card is
      present.  The default value .F. tests to see if a Herculess adapter can
      be emulated.

   $RETURNS$
      In conjunction with the <lMode> parameter, IsHercules() returns a .T.
      when a HERCULES card is present or a HERCULES adapter can be emulated.

   $DESCRIPTION$
      This function determines two things.  When <lMode>  is designated as
      .F., or the function is called without parameter, IsHercules()
      determines if a HERCULES adapter can be emulated.  This could be the
      case with a VGA or EGA card.  When <lMode> is .T., it determines if
      there is a HERCULES card present.

   $NOTES$
      ■  GETMODE() determines the active mode.

      Warning!  Although our function implies it, not all EGA and VGA
      cards can emulate HERCULES.  In most cases, a HERCULES emulation on a
      VGA card is possible , but it cannot be determined with absolute
      certainty.  As long as the text is output under CA-Clipper, working with
      IsMono() should be sufficient

   $EXAMPLES$
      Can HERCULES be emulated?

      If IsHercules()
         * ...
      ENDIF
      HERCULES card?
      IF IsHercules(.T.)
         * ...
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      VideoType(), GETMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsMCGA()
   $ONELINER$
      Determines if an MCGA card is present or can be emulated
   $SYNTAX$
      IsMCGA([<lMode>]) --> lMCGA

   $ARGUMENTS$
      <lMode>  When designated as .T. tests to see if an MCGA card is
      actually available.  The default value of .F. tests to see if a
      monochrome adapter can be emulated.

   $RETURNS$
      Depending on the <lMode> parameter, the function returns .T. when a MCGA
      card is available or if an MCGA adapter can be emulated.

   $DESCRIPTION$
      You can determine two things with this function. When designated as .F.
      or when called without a parameter, IsMCGA() tests to see if a
      monochrome adapter can be emulated.  This can happen with a HERCULES,
      EGA, or VGA card.  When designated as .T., the function determines if a
      Monochrome card is available.

   $NOTES$
      ■  GETMODE() determines the active mode.

   $EXAMPLES$
      Can MCGA be emulated?

      IF IsMCGA()
      *...
      ENDIF
      MCGA-Card?
      IF IsMCGA(.T.)
      *...
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      VideoType(), GETMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsMono()
   $ONELINER$
      Determines if a monochrome card is present or can be emulated
   $SYNTAX$
      IsMono([<lMode>]) --> lMonochrome

   $ARGUMENTS$
      <lMode>   When designated as .T., tests to  see if a monochrome card
      is available.  The default value of .F. tests to see if a monochrome
      card can be emulated.

   $RETURNS$
      Depending on the <lMode> parameter, IsMono() returns .T. when a
      monochrome card is available, or if a monochrome adapter can be
      emulated.

   $DESCRIPTION$
      This function determines two things.  When designated as .F. or when
      called without a parameter, IsMono() tests to see if a monochrome
      adapter can be emulated.  This can be the case with a HERCULES, EGA, or
      VGA card.  When designated as .T., the function determines if a
      monochrome card is available.

   $NOTES$
      ■  GETMODE() determines the active mode.

   $EXAMPLES$
      ■  Can monochrome be emulated?

         IF IsMono()
            *...
         ENDIF

      ■  Monochrome adapter?

         IF IsMono(.T.)
            *...
         ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      VideoType(), GETMODE(), MONOCHROME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsPGA()
   $ONELINER$
      Determines if a PGA card is present or can be emulated
   $SYNTAX$
      IsPGA([<lMode>]) --> lPGA

   $ARGUMENTS$
      <lMode>  When designated as .T., tests to see if a PGA card is
      available.  The default value of .F. tests to see if a PGA adapter can
      be emulated.

   $RETURNS$
      Depending upon the <lMode> parameter, IsPGA() returns .T. when a PGA
      card is available or if a PGA adapter can be emulated.

   $DESCRIPTION$
      This function can determine two things.  When designated as. F. or when
      called without a parameter, IsPGA() tests to see if a PGA adapter can be
      emulated.  This can be the case with an EGA or VGA card.  When
      designated as .T., the function determines if a PGA card is actually
      available.

   $NOTES$
      ■  Use GETMODE() to determine the active mode.

   $EXAMPLES$
      ■  Can PGA be emulated?

         IF IsPGA()
            *...
         ENDIF

      ■  PGA card?

         IF IsPGA(.T.)
            *...
         ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      VideoType(), GETMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsVGA()
   $ONELINER$
      Determines if a VGA card is present
   $SYNTAX$
      IsVGA() --> lVGA

   $RETURNS$
      IsVGA() returns .T. when a VGA card is available.

   $DESCRIPTION$
      The function tests to see if the screen card is a VGA adapter.  Use
      GETMODE() to determine the active mode.

   $EXAMPLES$
      Is VGA adapter available?

      IF IsVGA()<R>
         *...
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      VideoType(), GETMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MAXFONT()
   $ONELINER$
      Determines the number of available fonts
   $SYNTAX$
      MAXFONT() --> nFontCount

   $RETURNS$
      MAXFONT() returns the number of fonts you can load simultaneously within
      the screen card in use.

   $DESCRIPTION$
      Depending upon the screen adapter and its available memory, a various
      number of screen fonts can be loaded simultaneously.  MAXFONT() returns
      the maximum number of loadable fonts and is very helpful when used in
      conjunction with FONTLOAD() or SetFont().

   $NOTES$
      ■  As a rule, EGA adapters support four different font areas and
         VGA adapters support eight.

   $EXAMPLES$
      ■  Load a font in the highest font area available...

         FONTLOAD("ITALIC.016", MAXFONT())

      ■  ...and then select that font:

         FONTSELECT(MAXFONT())

   $PLATFORMS$
      DOS
   $SEEALSO$
      FONTLOAD(), SetFont(), FONTSELECT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MONISWITCH()
   $ONELINER$
      Switches between monochrome and color screen
   $SYNTAX$
      MONISWITCH() --> lSwitched

   $RETURNS$
      When the switching is successful, MONISWITCH() returns .T.; otherwise,
      it returns false .F..

   $DESCRIPTION$
      Today's IBM standard PC permit the simultaneous use of a monochrome card
      and CGA, EGA, or VGA color adapters because their screen memory base
      addresses do not conflict with each other.

      You could also use MONISWITCH() to switch back and forth between screens
      from within a CA-Clipper application.  IsColor() determines which screen
      is currently in use.

      CA-Clipper Tools does not just offer the simple capability to switch
      between two screens.  Two totally independent video systems are used
      internally and all of the accompanying settings that go with them are
      saved when you switch.  In addition, there are two window systems that
      can display up to 256 windows per screen at one time.

   $NOTES$
      ■  When you first switch, the selected screen is both initialized
         and cleared at the same time.  All subsequent switches retain all
         screen information.

   $EXAMPLES$
      ■  The "*" is switched from monochrome and output on the color
         screen in a loop:

         FOR I = 1 TO 79
            ?? "*"
            MONISWITCH()
         NEXT I

      ■  Since an uneven loop counter was used in the example on the
         previous page, the adapter used when you started will not be selected
         after execution.  Use IsColor() to determine the selected adapter:

         ? IsColor()                     // .T., when color screen selected

      ■  The following example shows how the current value for two
         screen adapters is determined.  With the double exchange, the current
         selection is retained:

         ? MONISWITCH(MONISWITCH())      // When .T., 2 screen adapters

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NToColor()
   $ONELINER$
      Converts a numeric value into a color value in the NN/NN or CC/CC form
   $SYNTAX$
      NToColor(<nAttr>, [<lColorCode>]) --> cAttr

   $ARGUMENTS$
      <nAttr>   Designates the value for the combined numeric color
      attributes.

      <lColorCode>  If designated as .F. or if the parameter is omitted,
      NToColor() returns a string with a numeric color code.  When designated
      as .T., NToColor() returns a string with the CA-Clipper alpha color
      coding.

   $RETURNS$
      NToColor() returns the designated color attribute in the NN/NN or CC/CC
      form.

   $DESCRIPTION$
      NToColor() converts a color attribute returned from another function in
      numeric form, into the alphanumeric data format.  Use this attribute in
      conjunction with the CA-Clipper SET COLOR TO command.

   $NOTES$
      ■  NToColor() returns a null string if the specified attributes
         are invalid or unavailable attributes.  Acceptable values are in the
         range of 0 and 255.

      ■  You cannot specify color attributes in letter format (e.g.,
         "B/W") .

   $EXAMPLES$
      ■  Normal display (white on black):

         ? NToColor(7)                 // 07/00
         ? NToColor(7, .T.)            // W/N

      ■  Display red on white.  The numeric form 116 yields "04/07":

         ? NToColor(116)               // 04/07
         ? NToColor(116)               // R/W

      ■  An invalid parameter returns a null string:

         ? NToColor(380)               // ""
         ? NToColor(-1)                // ""

   $PLATFORMS$
      DOS
   $SEEALSO$
      ColorToN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NUMCOL()
   $ONELINER$
      Restores the number of available screen columns
   $SYNTAX$
      NUMCOL() --> nColumn

   $RETURNS$
      NUMCOL() returns the number of columns available on the screen or in the
      current window, under CA-Clipper.

   $DESCRIPTION$
      Use NUMCOL() to establish screen width to determine the line break for
      output.

      NUMCOL() receives its return value from the BIOS and then, in
      conjunction with DSETWINDOW(), returns the number of columns on the
      physical screen or for a window.

   $EXAMPLES$
      Column count for the open window:

      WOpen(10, 10, 20, 70)     // Open window
      SETWINDOW(.T.)            // Default
      ? NUMCOL()                // 61 columns
      DSETWINDOW(.F.)           // Do not reroute external output?
      NUMCOL()                  // 80 columns

   $PLATFORMS$
      DOS
   $SEEALSO$
      MaxCol(), MaxRow(), CGA40(), SETMAXCOL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RestCursor()
   $ONELINER$
      Restores a saved cursor position and form
   $SYNTAX$
      RestCursor(<nCursorSetting>) --> cNull

   $ARGUMENTS$
      <nCursorSetting>  Designates a value previously returned by the
      SaveCursor() function.

   $RETURNS$
      RestCursor() always returns a null string.

   $DESCRIPTION$
      With SaveCursor(), you can save three pieces of screen information. If
      those return values are saved, then you can reset Row(), Col(), and
      CSetCurs() later with RestCursor().

   $EXAMPLES$
      Save and restore:

      nVar  :=  SaveCursor()
      DO OUTPUT
      RestCursor(nVar)

   $PLATFORMS$
      DOS
   $SEEALSO$
      SaveCursor()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SaveCursor()
   $ONELINER$
      Saves current cursor position and form
   $SYNTAX$
      SaveCursor() --> nCursorSetting

   $RETURNS$
      SaveCursor() returns a numeric value that corresponds to the setting for
      Row(), Col(), SetCursor(), and CSetCurs().

   $DESCRIPTION$
      SaveCursor() saves three pieces of screen information at one time.
      SaveCursor() returns a combined numeric value that you can save and
      restore later with RestCursor().

   $EXAMPLES$
      Save and restore the cursor:

      nVar  :=  SaveCursor()
      DO OUTPUT
      RestCursor(nVar)

   $PLATFORMS$
      DOS
   $SEEALSO$
      RestCursor()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SayDown()
   $ONELINER$
      Displays screen output downward and vertically
   $SYNTAX$
      SayDown(<cCharacterstring>, [<nDelay>], [<nLine>],
         [<nColumn>]) --> cNull

   $ARGUMENTS$
      <cCharacterstring>  Designates vertical output for the string.

      <nDelay>  Designates that the time delay is set in milliseconds.
      The default value is 4.

      <nLine>  Designates from which line to begin the output.  The
      default is the cursor line.

      <nColumn>  Designates from which column to begin the output.  The
      default is the cursor column.

   $RETURNS$
      SayDown() always returns a null string.

   $DESCRIPTION$
      SayDown() allows you to have a particular affect on a string output.
      The output is done vertically, downward from the current or selected
      cursor position, and can have a time delay between individual
      characters.  When the last line of the screen is reached, the function
      outputs one more character and then terminates.  The SET COLOR TO
      setting is used as an attribute.  The current cursor position is not
      changed with this function.

   $NOTES$
      ■  Control characters such as with @...SAY commands in CA-
         Clipper, are not interpreted.

   $EXAMPLES$
      Show vertical output from line 10, column 10, with a 100-millisecond
      time delay between characters:

      SayDown("Clipper", 100, 10, 10)
      Line 10: C
               L
               I
               P
               P
               E
               R

   $PLATFORMS$
      DOS
   $SEEALSO$
      SaySpread(), SayMoveIn()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SayMoveIn()
   $ONELINER$
      Displays screen output with a "move in" effect
   $SYNTAX$
      SayMoveIn(<cCharacterstring>, [<nDelay>],
         [<nLine>], [<nColumn>], [<lDirection>])
          --> cNull

   $ARGUMENTS$
      <cCharacterstring>  Designates the string to be output with the
      "move in" effect.

      <nDelay>  Designates a time delay in milliseconds.  The default
      value
      is 4.

      <nLine>  Designates the line where the result is output.  The
      default is the cursor line.

      <nColumn>  Designates the column where the result is output.  The
      default is the cursor column.

      <lDirection>  Designates the direction that the characters are moved
      onto the screen.  If you omit this parameter or designate it as .F., the
      movement is from the left.  If you designate it as .T., the movement is
      from the right onto the screen.  The default is movement from the left
      (.F.).

   $RETURNS$
      The function always returns a null string.

   $DESCRIPTION$
      SAY MOVE IN
      This function has a particular effect on string screen output.  From a
      certain position characters are individually moved in from the left or
      right of the screen.  After this output, the cursor position is at the
      end of the string.

   $NOTES$
      ■  Control characters, as with @...SAY commands in CA-Clipper are
         not interpreted.

   $EXAMPLES$
      Show special affect output beginning at line 10, column 10 with a
      100-millisecond time delay.  The string is moved in from the left:

      SayMoveIn("Clipper", 100, 10, 10)
      Column 10:
            r
            er
            per
            pper
            ipper
            lipper
            Clipper            // Result on line 10 !

   $PLATFORMS$
      DOS
   $SEEALSO$
      SaySpread(), SayDown(), SaveCursor()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SayScreen()
   $ONELINER$
      Output to the screen without changing the attribute
   $SYNTAX$
      SayScreen(<cCharacterstring>, [<nRow>],
         [<nColumn>]) --> cNull

   $ARGUMENTS$
      <cCharacterstring>  Designates the character string to output.

      <nRow>  Designates the first line for the output.  The default is
      the cursor line.

      <nColumn>  Designates the first column for the output.  The default
      is the cursor column.

   $RETURNS$
      SayScreen() always returns a null string.

   $DESCRIPTION$
      SayScreen() produces an screen output and retains all existing
      attributes.  This means that only the characters are overwritten, while
      the accompanying attributes remain unchanged.

   $NOTES$
      ■  The current cursor position is not changed with the output.

   $EXAMPLES$
      ■  Show the output text at the current cursor position:

         SayScreen("  Test SCREEN  ")

      ■  Show output text at the current column position on line 24:

         SayScreen("  Test SCREEN  ", 24)

      ■  Show output text at column 70, line 24:

         SayScreen("  Test SCREEN  ", 24, 70)

      All examples in this function return a null string.

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SaySpread()
   $ONELINER$
      Displays screen output with "spread" effect
   $SYNTAX$
      SaySpread(<cCharacterstring>, [<nDelay>],
         [<nLine>], [<nColumn>]) --> cNull

   $ARGUMENTS$
      <cCharacterstring>  Designates the string to output with the spread
      effect.

      <nDelay>  Designates a time delay in milliseconds.  The default
      value
      is 4.

      <nLine>  Designates the line from which the output begins.  The
      default is the cursor line.

      <nColumn>  Designates the column from which the output begins.  The
      default is the cursor column.

   $RETURNS$
      SaySpread() always returns a null string.

   $DESCRIPTION$
      SaySpread() has a particular effect on a string output to screen.  From
      a center point, which corresponds to the center of the screen, window or
      <nColumn>, characters are displayed outward (they have a type of spread
      effect).  The SET COLOR TO attribute setting is used.  The current
      cursor position is not changed with this function.

   $NOTES$
      ■  Control characters, as with @...SAY commands in CA-Clipper are
         not interpreted.

   $EXAMPLES$
      Show special effect output that begins in the middle of the screen or
      window at line 10, with a 100-millisecond time delay:

      SaySpread("Characters", 100, 10)

      Output will be in the following steps, but always on the same line:

                ac
               ract
              aracte
             haracter
            Characters         // Result on line 10

   $PLATFORMS$
      DOS
   $SEEALSO$
      SayMoveIn(), SayDown()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ScreenAttr()
   $ONELINER$
      Determines the attribute at a particular position
   $SYNTAX$
      ScreenAttr([<nRow>], [<nColumn>]) --> nAttr

   $ARGUMENTS$
      <nRow>  Designates the line from which to determine the attribute.
      The default is the cursor line.

      <nColumn>  Designates the column from which to determine the
      attribute.  The default is the cursor column.

   $RETURNS$
      ScreenAttr() returns the attribute at the designated position.

   $DESCRIPTION$
      ScreenAttr() returns the current screen attribute at <nRow> and
      <nColumn>.  You can query targeted attributes this way and save them to
      use later, or process them later with InvertAttr().

   $NOTES$
      ■  If no parameters are passed, the current cursor position is
         queried.

   $EXAMPLES$
      ■  The attribute for the current cursor position:

         nVar:= ScreenAttr()

      ■  The attribute at the current column position in line 23:

         nVar:= ScreenAttr(23)

      ■  The attribute at column 70, line 23:

         nVar:= ScreenAttr(23, 70)

   $PLATFORMS$
      DOS
   $SEEALSO$
      InvertAttr()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ScreenFile()
   $ONELINER$
      Writes screen content to a file
   $SYNTAX$
      ScreenFile(<cFileName>, [<lOverwrite>],
         [<nOffset>]), [<lTrim>] --> nBytesWritten

   $ARGUMENTS$
      <cFileName>  Designates the name and path of the screen file.

      <lOverwrite>  Designates whether you are to append to an existing
      file (.T.), or to overwrite it (.F.).  The default is overwrite (.F.).

      <nOffset>  Designates the file offset from which you append, when
      <lOverwrite> is designated as .T..  The default is the end of file.

      <lTrim>  If this optional parameter is designated as .T., the
      function trims the file when the written data ends and before the last
      byte of the file.  The default is do not trim (.F.).

   $RETURNS$
      ScreenFile() returns the number of bytes written to the screen file.

   $DESCRIPTION$
      ScreenFile() saves the contents of a screen to a file.  Since the
      CA-Clipper SAVE SCREEN and RESTORE SCREEN also work with windows when
      you use the CA-Clipper Tools Extended Drivers, use ScreenFile() to save
      the entire screen.  The number of characters you can write this way
      depends on the respective screen mode.  For example, in a 50-line VGA
      mode you can write 8000 instead of 4000 characters.  Use SCREENSIZE() to
      determine the exact screen size at any given time.  You can only use the
      <nOffset> parameter when you specify <lOverwrite> at the same time.
      <nOffset> then specifies from which position in the screen file the new
      screen data is to be written.  If the <nOffset> position lies before the
      end of the file, the file is overwritten.  If it exceeds the end of the
      file, the data is appended.  The default value for <nOffset> is
      selected, so if you omit it and designate <lOverwrite> as .T., the file
      is appended.  This behavior allows you to save the contents of several
      screens to a file.

      It is possible that a screen could be written to an already existing
      file, and that everything beyond this screen is trimmed off.  The
      <lTrim> logical parameter must be designated as .T..

   $NOTES$
      ■  If ScreenFile() creates a new file, use SetFCreate() to create
         an alternate attribute for this new file .

      ■  If you turn on the CA-Clipper Tools CSetSafety() internal
         switch, the target file is not overwritten, even if the <lOverwrite>
         parameter is designated as .F..

      ■  Wildcards within the file name are not permitted here.

   $EXAMPLES$
      ■  An existing file is overwritten:

         ScreenFile("screen.tst")                        // Result:  4000>
         ScreenFile("\screen.tst")                       // Result:  4000>
         ScreenFile("a:\screen.tst")                     // Result:  4000

      ■   On a VGA card in 50-line mode:

         ScreenFile("screen.tst")                        // Result:  8000

      ■  The file is appended:

         ScreenFile("screen.tst", .T. )                  // Result:  4000

      ■  Insert a screen from an offset of 4000 ( i.e., after the first
         screen):

         ScreenFile("screen.tst", .T., 4000)             // Result:  4000

      ■  Insert a screen after the third screen:

         ScreenFile("screen.tst", .T., 12000)            // Result:  4000

      ■  Overwrite an existing file in the fourth screen and trim off
         the rest of the file:

         ScreenFile("screen.tst", .T., 12000, .T.)       // Result:  4000

      ■  Wildcards not permitted:

         ScreenFile("screen.*")                          // Result:  0

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileScreen(), SCREENSIZE(), CSetSafety(), SetFCreate()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ScreenMark()
   $ONELINER$
      Searches for a string on the screen and marks it with an attribute
   $SYNTAX$
      ScreenMark(<cSearchString>, <cAttr|nAttr>,
         <lUpperLower>, [<lAll>],
         [<cForwardDelimiter>],    [<cTrailingDelimiter>])
          --> lFound

   $ARGUMENTS$
      <cSearchString>  Designates the character string to search for in
      screen memory.

      <cAttr|nAttr>  Designates the new color attribute to use in the
      sequence located in screen memory.  Can be specified as a numeric or in
      the manner required under CA-Clipper.

      <lUpperLower>  Designates whether the function is case sensitive
      (.T.) or not (.F.).

      <lAll>  Designates whether to mark each occurrence (.T.) or only the
      first (.F.).  The default marks only the first (.F.).

      <cForwardDelimiter>  This optional parameter designates which
      character preceding the <cSearchString> to use as a delimiter.  The
      default is no delimiter considered.

      <cTrailingDelimiter>  This optional parameter designates which
      character after the <cSearchString> to use as a delimiter.  The default
      is no delimiter considered.

   $RETURNS$
      ScreenMark() returns a .T. when it locates the designated string at
      least once.

   $DESCRIPTION$
      ScreenMark() searches in the screen memory for a specified character
      sequence and emphasizes it with a new attribute.  For example, you could
      mark words out of MemoEdit() in inverse video.  When you press a cursor
      key, ScreenMark() is always called in the MemoEdit() that controls UDF.

      If you are searching for a specific word, then designate <lUpperLower>
      as .T..  If case sensitivity is not a major consideration, then
      designate <lUpperLower> as .F..

      If you want only words and not word fragments, then work with the two
      delimiter characters <cForwardDelimiter> and <cTrailingDelimiter>.
      Otherwise, the word "LOCK" is marked if the word "BLOCK" occurred.

      If you define a space (see Note) for <cForwardDelimiter> as a separator
      for the expression, then LOCK is no longer marked with BLOCK.  You can
      specify all delimiters that could be valid in character string form.
      The function allows a targeted expression to begin in the first position
      or end at the last position on the screen or window.

   $NOTES$
      Important!  The CA-Clipper Tools uses Chr(255) as the default to
      clear the screen, since the character can take on a color attribute on
      all screen adapters.  Be sure to consider this when you create a
      delimiter list.

      ■  The cursor position is not changed with this function.

   $EXAMPLES$
      ■  Mark the first word "Clipper" on the screen (exactly) with the
         INVERS attribute:

         ? ScreenMark("Clipper", "0/7", .T.)            // Not found if .F.

      ■  Mark all occurrences of "Clipper" (regardless of the case),
         the attribute is white/blue:

         ? ScreenMark("Clipper", "W/B", .F., .T.)       // Not found if .F.

      ■  Search for all "LOCK" words.  Expressions, such as "BLOCK" are
         not to be marked.  Blanks (when you use the CA-Clipper Tools these
         are Chr(255)), slashes, dashes, and brackets, are delimiters:

         cListA  :=  Chr(255) + "/("
         cListB  :=  Chr(255) + "-)"
         ? ScreenMark("LOCK", "W/B", .F., .T., cListA, cListB)

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ScreenMix()
   $ONELINER$
      Mixes characters and attributes of a screen
   $SYNTAX$
      ScreenMix(<cCharacterstring>, <cAttrString>,
         [<nRow>], [<nColumn>]) -->cNull

   $ARGUMENTS$
      <cCharacterstring>  Designates the a string to use.

      <cAttrString>  Designates which attributes to mix with the
      characters in the <cCharacterstring>.

      <nRow>  Designates the starting line of the output.  The default is
      the cursor line.

      <nColumn>  Designates the starting column of the output.  The
      default is the cursor column.

   $RETURNS$
      ScreenMix() always returns a null string.

   $DESCRIPTION$
      ScreenMix() allows you to combine two character strings --
      <cCharacterstring> which contains characters, and <cAttrString> which
      contains attributes.  You can mix them together and output the resulting
      character string directly to the screen.  This assigns the first
      attribute of <cAttrString> to the first character in <cCharacterstring>,
      and so on.  The first character is displayed in the color determined by
      the first attribute.  The <nRow> and <nColumn> parameters determine the
      first line and column for the output.

   $NOTES$
      ■  If the parameters for line and column (<nRow> and <nColumn>)
         are not specified, the output begins at the current cursor position.

   $EXAMPLES$
      ■  The following two character strings determine the text and
         attribute to output with ScreenMix().  The first "1" is red on white
         (116) and the help text is blue on white (113):

         cCharacter: = "1Help"
         cAttribute: = Chr(116) + Replicate(Chr(113), 5)

      ■  Show output at the current cursor position:

         ScreenMix(cCharacter, cAttribute)

      ■  Show output at line 24 at the cursor column:

         ScreenMix(cCharacter, cAttribute, 24)

      ■  Show output at line 24, column 0:

         ScreenMix(cCharacter, cAttribute, 24, 0)

   $PLATFORMS$
      DOS
   $SEEALSO$
      ColorToN(), SayScreen()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SCREENSIZE()
   $ONELINER$
      Queries the number of characters that can be displayed on a screen or window
   $SYNTAX$
      SCREENSIZE(<lMode>) --> nScreenSize

      Warning!  Contains <lMode>, an additional optional parameter over
      and above CA-Clipper Tools.

   $ARGUMENTS$
      <lMode>  If this parameter is designated as .T., then SCREENSIZE()
      returns the size of the physical screen; otherwise, it returns the size
      of the selected window.  The default (.F.) is the selected window size.

   $RETURNS$
      SCREENSIZE() returns the number of bytes available for screen output, in
      an active window, or the physical screen.

   $DESCRIPTION$
      SCREENSIZE() determines the screen size memory in bytes.  With 25 lines
      and 80 columns, there are exactly 2000 characters.  For each character,
      there is also an attribute byte that results in 4000 bytes of screen
      memory.

      If SCREENSIZE() is called without parameters or with .F., it returns the
      active window size.  When called with .T., it returns the physical
      screen size.

   $EXAMPLES$
      Display the number of available bytes:

      WOpen(10, 10, 20, 70)      // Open a window
      ? SCREENSIZE()             // Size of window
      ? SCREENSIZE(.T.)          // Size of physical screen

   $PLATFORMS$
      DOS
   $SEEALSO$
      NUMCOL(), MaxRow()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ScreenStr()
   $ONELINER$
      Reads a string, including attributes, from the screen
   $SYNTAX$
      SCREENSTR ([<nRow>], [<nColumn>], [<nCharCount>])
          --> cCharacterstring

   $ARGUMENTS$
      <nRow>  Designates the first line to read.  The default is the
      cursor line.

      <nColumn>  Designates the first column to read.  The default is the
      cursor column.

      <nCharCount>  Designates how many characters to read.  The default
      is to the end of the window or screen area.

   $RETURNS$
      ScreenStr() returns the character string that contains all of the bytes
      read from the screen.

   $DESCRIPTION$
      ScreenStr() returns a specified portion of the screen or window
      contents.  <nRow> specifies the first line, and <nColumn> the first
      column to read from.  <nCharCount> designates the number of characters
      to read, if you do not want the entire screen or window content.

   $NOTES$
      ■  The returned character string contains all the attribute
         bytes.  For the entire screen, a variable that is 25 lines by 80
         columns, is a total of 4000 characters.

      ■  If <nRow> or <nColumn> are not specified, then the function
         automatically uses the corresponding coordinates of the current
         cursor position.  The function does not change the cursor position.

   $EXAMPLES$
      ■  Read all characters with their accompanying attributes from
         the cursor position to the end of the screen:

         cVar: = ScreenStr()

      ■  Show all characters and attributes from the cursor position in
         line 24:

         cVar: = ScreenStr(24)

      ■  The last 10 characters and attributes in line 24:

         cVar: = ScreenStr(24, 70)

      ■  The last 10 characters (without attributes) in line 24:

         cVar: = CharOdd(ScreenStr(24, 70))

   $PLATFORMS$
      DOS
   $SEEALSO$
      StrScreen(), CharOdd(), CharEven()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetClearA()
   $ONELINER$
      Changes the default attribute for screen clear
   $SYNTAX$
      SetClearA([<cClearAttr|nClearAttr>]) --> cNull

   $ARGUMENTS$
      <cClearAttr|nClearAttr>  Designates the desired attribute for
      CLEARA.  The default is white on black (7).

   $RETURNS$
      SetClearA() always returns a null string

   $DESCRIPTION$
      SETCLEAR(A)ttribute
      SetClearA() allows you to set the current, standard attribute for screen-
      oriented CA-Clipper Tools functions.  If this function is not called
      within a program, the standard attribute of 7 (white on black) is used
      by the clearing functions.

   $NOTES$
      ■  You can specify the <cClearAttr|nClearAttr> parameter in
         different ways (see Introduction to this chapter).

   $EXAMPLES$
      ■  Use the standard attribute:

         SetClearA()

      ■  Shown below are three ways to set the clear attribute:

         SetClearA(19)
         SetClearA("03/01")
         SetClearA("B/GR")
   $PLATFORMS$
      DOS
   $SEEALSO$
      GetClearA(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetClearB()
   $ONELINER$
      Changes the default character for screen clear
   $SYNTAX$
      SetClearB([<cClearCharacter|nClearCharacter>])
         --> cNull

   $ARGUMENTS$
      <cClearCharacter|nClearCharacter>  Designates the desired clear
      character for CLEARB.  Can be a number in the range of 0 to 255 or the
      character string type.  The default value is Chr(255).

   $RETURNS$
      SetClearB() always returns a null string.

   $DESCRIPTION$
      SetClearB() sets the default character for screen-oriented CA-Clipper
      Tools functions.  If this function is not called within a program,
      character Chr(255) is used by the clearing functions.  This character
      (a "hard"' blank) can accept a color attribute on all screen adapters.

   $NOTES$
      ■  When you call SetClearB() without designating the
         <cClearCharacter|nClearCharacter> parameter, the standard character
         Chr(255) is used.

   $EXAMPLES$
      ■  Use Chr(255) as the standard character:

         SetClearB()

      ■  Use Chr(178) as a clear character SetClearB(178)

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetClearB(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetFont()
   $ONELINER$
      Loads the font directly out of a string
   $SYNTAX$
      SetFont(<cFontString>, [<nFontArea>], [<nOffset>],
         [<nCounter>]) -->nErrorCode

      or

      ETFONT(<cFontString>, [<nFontArea>], [<lCompute>])
         --> nErrorCode

   $ARGUMENTS$
      <cFontString>  Designates a string that contains a valid font
      definition.

      <nFontArea>  Designates the number of the desired font area.  For
      EGA adapters, the values are 1 to 4, for VGA, they are 1 to 8 or the
      number allowed by MAXFONT().

      <nOffset>  Designates the character position at which the font table
      is transmitted to the screen adapter.  The default value is 0.

      <nCounter>  Designates the number of characters for which a new font
      is loaded.  The default value is 256.

      <lCompute>  Use this parameter only when <nOffset> and <nCounter>
      are not in concurrent use.  When designated as .T., the function
      computes the pixel height from the length of the font string.

   $RETURNS$
      The function returns an error code with the following definitions:

      Table 6-4: Error Code Definitions
      <table>
          Error Code   Definition

           0           Font loaded successfully
          -1           Invalid font area designated
          -2           Impossible in current video mode
          -4           The <lOtherPixelHeight> mode is invalid (the Extended
                       Drivers has not been linked in)
         </table>

   $DESCRIPTION$
      With SetFont(), you can load a screen font from a string into the font
      area of an EGA or VGA card.  FONTSELECT() allows you to determine the
      font to serve for normal and the font to serve for high-density output.

      *Technical Background*

      EGA and VGA cards permit you to modify all 256 characters of the
      character generator or any portion of it with software.  For this
      purpose, load a previously created pixel pattern for the character in
      the corresponding position in a font area on the screen card.  Normally,
      an EGA card has a maximum of four font areas and a VGA has eight.  You
      can redefine any of the 256 characters within these font areas.  Use
      MAXFONT() to determine the actual number of font areas.

      Building fonts into a program requires unnecessary memory space.  It is
      also awkward to construct string fonts within a program.  The GETFONT()
      and SetFont() functions load a font from a screen card into a string
      variable, or from such a variable into a font area on the card.
      However, FONTLOAD() only offers the ability to load a font from a file
      into a particular area of the screen card.  In both cases, use
      FONTSELECT() to activate the loaded font when necessary.

      To construct new fonts, a font editor is included in CA-Clipper.

      *Variable Pixel Height*

      In principle, the EGA and VGA screen adapters provide the ability to
      display fonts with 2 to 32 pixels per character (1 pixel/character only,
      when there are 200 scan lines).  ROM fonts are only available for pixel
      heights of 8, 14, and 16, which explains the great expansion of the EGA
      25/43-line and VGA 25/28/50-line modes.  You must construct individual
      fonts for all other pixel heights.  This is easy with the
      CA-Clipper Tools font editor.

      If you deviate from the mode just set, use SetFont() to implement other
      desired pixel heights, where the <lCompute> parameter is designated as
      .T.  The pixel height is computed with the following formula:

                Pixel height = Len(Font-String)/256

      Partial fonts cannot be used for this calculation, only fonts that
      contain the full 256 characters.

      Since a change in pixel height also leads to a change in the screen mode
      and line count, always link in the CTUS.LIB Extended Drivers.

   $NOTES$
      ■  The screen adapters do not permit you to mix fonts with
         different pixel heights.

      ■  When an EGA card does not require the full use of memory, you
         can reduce a maximum number of four font areas.  Use MAXFONT() to
         determine the number of available fonts at any given time.

   $EXAMPLES$
      ■  Load all 256 font characters in font area 2:

         ? SetFont(cFontString, 2)      // 0 < OK
         FONTSELECT(2)                  // Font area 2 for<R>
                                        // non-highlighted

      ■  Exchange the top 128 characters of a font in font area 3:

         ? SetFont(cFontString, 3, 128, 128)   // 0 <F128M><142><F255D><N>OK
         FONTSELECT(3)                         // Font area 3 for<R>
                                               // non-highlighted

      ■  In this example, the just-installed font height is doubled
         wherever possible.  This is simple, since each byte in the font
         string is doubled:

         cFont  :=  GETFONT()
         SetFont(CharMix(cFont, cFont), .T.)

      ■  The font strings can be torn down to individual pixel lines.
         This example shows pixel lines as a bit pattern in a binary display:

         cFont  :=  GETFONT()
         nPixel :=  CharPix()

         FOR A = 0 TO 255
            FOR B = 1 TO nPixel
               nByte  := Asc(SubStr(cFont, (nPixel * A) + B, 1))
               ? NToC(nByte, 2, 8, "0")
            NEXT B
            Inkey(0)
            ?
         NEXT A

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETFONT(), FONTLOAD(), FONTSELECT(), FONTRESET()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetRC()
   $ONELINER$
      Sets line and column for the CA-Clipper cursor
   $SYNTAX$
      SetRC([<nRow>], [<nColumn>]) --> cNull

   $ARGUMENTS$
      <nRow>  Designates the new cursor line.  The default is the current
      BIOS line.

      <nColumn>  Designates the new cursor column.  The default is the
      current BIOS column.

   $RETURNS$
      SetRC() always returns a null string.

   $DESCRIPTION$
      This function resets the internal value that CA-Clipper returns for the
      current Row() line and Col() column.  The cursor automatically moves to
      this new location at the same time.  When output is not through
      CA-Clipper, the CA-Clipper internal values for Row() and Col() may
      deviate from the actual position returned in the BIOS.  If you implement
      SETRC without a parameter, then the position returned from the BIOS is
      set within CA-Clipper.

   $NOTES$
      ■  Negative values or those too large for the line or column, are
         corrected automatically.

   $EXAMPLES$
      ■  Set the BIOS line and column in CA-Clipper and display:

         SetRC()
         ? Row(), Col()

      ■  The BIOS line and the CA-Clipper column are used:

         SetRC(, Col())
         ? Row(), Col()

      ■  The CA-Clipper line and the BIOS column are used:

         SetRC( Row())
         ? Row(), Col()

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETSCRSTR()
   $ONELINER$
      Redirects screen output into a string
   $SYNTAX$
      SETSCRSTR(<lMode>) --> lRedirected

   $ARGUMENTS$
      <lMode>  Designates whether subsequent screen output is put into the
      internal memory area (.T.) or is to reappear on the screen (.F.).  The
      default is mode off (.F.)

   $RETURNS$
      SETSCRSTR() returns .T. when the subsequent screen output is routed to
      an internal memory area.  The function returns .F. when anything other
      than window 0 is selected.

   $DESCRIPTION$
      SETSCRSTR() selects a mode where all screen output is redirected to an
      internal memory area.  After switching on this mode, the memory area is
      initialized as if you had cleared the screen with an @ 0, 0 CLEAR.  All
      screen output that results from the CA-Clipper driver module or the CA-
      Clipper Extended Drivers is rerouted to this memory area.  The data
      stored there is then passed to a variable with GETSCRSTR(), and after
      the mode is switched off, it is passed to the CA-Clipper RestScreen()
      function.  Since the entire screen output is always rerouted and must
      always be selected (with the exception of window 0), call RestScreen()
      with the maximum coordinates for the physical screen of 0, 0, MaxRow(),
      MaxCol().

   $NOTES$
      Warning!  You cannot implement this function when windows are open.

      ■  If the CTUS.LIB Extended Drivers is not linked in, you cannot
         use a CA-Clipper Library function to reroute screen output to a
         variable.

      ■  External programs, DOS and BIOS output, can also be redirected
         in a string.  To do this, you must set DSETWINDOW() on (.T.).

      ■  Since no output appears on the screen during this hidden
         output mode, switch off "snow prevent" through NoSnow(.F.).

      ■  Use SET CURSOR ON/OFF, if you also want to switch the cursor
         off.

   $EXAMPLES$
      ■  Show hidden output.  Should the need arise, switch back to the
         physical screen:

         WSelect(0)
         ? SETSCRSTR(.T.)                  // .T. when mode on
         @ 10, 10 SAY "XXXXXXX"            // Normal screen output
            *....
         @@ 15, 10 SAY "YYYYYYY

      ■  Always call the  GETSCRSTR() function before SETSCRSTR(.F.):

         cVar  := GETSCRSTR()
         ? SETSCRSTR(.F.)                  // .F. when mode off
         RestScreen(0, 0, MaxRow(), MaxCol(), cVar)

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETSCRSTR(), MaxRow(), MaxCol(), DSETWINDOW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Standard()
   $ONELINER$
      Selects the standard color value for SET COLOR TO output
   $SYNTAX$
      Standard() --> cNull

   $RETURNS$
      Standard() always returns a null string.

   $DESCRIPTION$
      Standard() permits you to reselect the standard attribute for
      CA-Clipper  @...SAY and ? outputs, after you use Enhanced() or
      Unselected() to switch over.  An attribute is considered a standard,
      when it is the first parameter is passed by SET COLOR TO.

   $EXAMPLES$
      Change attribute output to enhanced, and then switch back to standard:

      ? "........"
      ? "........"
      Enhanced()
         ? "Different attribute!"
      Standard()
      ? "........"
      ? "........"

   $PLATFORMS$
      DOS
   $SEEALSO$
      Enhanced(), Unselected()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      StrScreen()
   $ONELINER$
      Displays a string with characters and attributes on the screen
   $SYNTAX$
      StrScreen(<cCharacterstring>, [<nRow>],
         [<nColumn>]) --> cNull

   $ARGUMENTS$
      <cCharacterstring>  Designates the character string to display.

      <nRow>  Designates the starting line for the output.  The default is
      the cursor line.

      <nColumn>  Designates the starting column for output.

   $RETURNS$
      StrScreen() always returns a null string.

   $DESCRIPTION$
      StrScreen() displays the contents of a variable to the screen (assuming
      that it is in a particular format).  You must always have a character,
      an attribute, another character, etc., in the designated character
      string.

      <nRow> and <nColumn> specify the first row and column in which to write
      the string.

   $NOTES$
      Warning!   The string must also contain attribute bytes.  Use
      ColorToN() to create the combined numeric attributes.

      ■  Output does not alter the cursor position.

   $EXAMPLES$
      ■  Output "ABC" at the current cursor position with a different
         attribute for each character:

         StrScreen("A"+Chr(1)+"B"+Chr(2)+"C"+Chr(3))

      ■  Output ABC with different attributes at the current cursor
         column in line 24:

         StrScreen("A"+Chr(1)+"B"+Chr(2)+"C"+Chr(3), 24)

      ■  Output ABC with different attributes at column 70, line 24:

         StrScreen("A"+Chr(1)+"B"+Chr(2)+"C"+Chr(3), 24, 70)

   $PLATFORMS$
      DOS
   $SEEALSO$
      ScreenStr(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Unselected()
   $ONELINER$
      Selects the unselected color value for SET COLOR TO output
   $SYNTAX$
      Unselected() --> cNull

   $RETURNS$
      Unselected() always returns a null string.

   $DESCRIPTION$
      Unselected() takes a color attribute designated by SET COLOR TO as
      unselected (fifth color value), and designates it as the active
      attribute for CA-Clipper @...SAY and ? output.  Use Standard() to switch
      back to the normal attribute.

   $EXAMPLES$
      Output with the unselected attribute:

      ? "........"
      ? "........"
      Unselected()
         ? "Different attribute!"
      Standard()
      ? "........"
      ? "........"

   $PLATFORMS$
      DOS
   $SEEALSO$
      Standard(), Enhanced()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      UnTextWin()
   $ONELINER$
      Replaces an area of characters from a region of the screen
   $SYNTAX$
      UnTextWin(<nTopLine>, <nLeftColumn>, <nBottomLine>,
         <nRightColumn>,
         <cReplacementCharacter|nReplacementCharacter>,
         [<cInitialCharacter|nInitialCharacter>],
         [<cEndCharacter|nEndCharacter>]) --> cNull

   $ARGUMENTS$
      <nTopLine>  Designates the line for the upper-left corner of the
      area.

      <nLeftColumn>  Designates the column for the upper-left corner of
      the area.

      <nBottomLine>  Designates the line for the bottom-right corner of
      the area.

      <nRightColumn>  Designates the line for the bottom-right column of
      the area.

      <cReplacementCharacter|nReplacementCharacter>  Replaces each
      character within the window, with the exception of those within the
      range of <cInitialCharacter|nInitialCharacter> and
      <cEndCharacter|nEndCharacter>.

      <cInitialCharacter|nInitialCharacter>  Designates the beginning of
      the bracketed area.  The character can be number in the range of 0 to
      255, or the character string type.  The default value is 176.

      <cEndCharacter|nEndCharacter>  Designates the end of the bracketed
      area.  The character can be number in the range of 0 to 255 or the
      character string type.  The default value is 223.

   $RETURNS$
      UnTextWin() always returns a null string.

   $DESCRIPTION$
      Use UnTextWin() to delete particular character from within a screen
      area.  You can bracket off a specific area of characters.  This area
      begins with <cInitialCharacter|nInitialCharacter> and ends with
      <cEndCharacter|nEndCharacter>.  The preset values have bracketed out
      characters 176 to 223 (the graphics characters).  This allows you to
      clear a screen, but retain the boxes.

      The designated area can even "double back"; EndCharacter could be
      smaller than Initial Character.  In this case, the area stretches from
      the larger value to 255 and, inclusive of 0, to the smaller value.  You
      might say these two areas are designated.

   $EXAMPLES$
      ■  Clear the screen, with the exception of the boxes.  Since no
         range is specified, 176 to 223 are bracketed out:

         UnTextWin(0, 0, 24, 79, " ")               // ""

      ■  Clear all characters, with the exception of uppercase letters
         (65-90).  A numeric BLANK is designated as a clear character:

         UnTextWin(0, 0, 24, 79, 32, 65, 90)        // ""

      ■  Double back on an area.  All characters with the exception of
         uppercase letters are deleted:

         UnTextWin(0, 0, 24, 79, 255, 91, 64)       // ""

   $PLATFORMS$
      DOS
   $SEEALSO$
      ClearWin(), ClWin()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      VGAPalette()
   $ONELINER$
      Changes VGA palette colors
   $SYNTAX$
      VGAPalette([<cColor|nColor>, [<nRedValue>,
         <nGreenValue>, <nBlueValue>]]) --> lValid

   $ARGUMENTS$
      <cColor|nColor>  Designates the color to change as a CA-Clipper
      color code or in the range of 0 to 15.  If no RGB value is specified,
      the color palette is reset to its default value.

      <nRedValue>  Designates the palette setting for the red portion in
      the range of 0 to 63.

      <nGreenValue>  Designates the palette setting for the green portion
      in the range of 0 to 63.

      <nBlueValue>  Designates the palette setting for the blue portion in
      the range of 0 to 63.

      ()  When the function is called without parameters, the palettes for all
      colors are reset to their default values.

   $RETURNS$
      VGAPalette() returns .T. when the selected setting is successfully
      implemented.

   $DESCRIPTION$
      A VGA card offers a larger color selection for the palette than the EGA
      adapter.  The three basic colors to add color synthesis are red, green,
      and blue.  With the <nRedValue> through <nBlueValue> parameters, the
      intensity for each of these three colors is set, and different color
      combinations can result.  You can assign one color mix to one or more of
      the SET COLOR TO <cColor|nColor> installed colors.

      If only the color is designated as a parameter, then the accompanying
      palette is reset to its default value.  When you call the function
      without parameters, all the palettes are reset.

   $NOTES$
      ■  The FONTRESET() function resets all color palettes.

   $EXAMPLES$
      ■  Show a lot of red, a little green, and some blue as a new
         setting for color 3:

         ? VGAPalette("BG", 60, 4, 10)      // .T., when accepted

      ■  Reset the red palette:

         VGAPalette("R")

      ■  Reset all palettes:

         VGAPalette()

   $PLATFORMS$
      DOS
   $SEEALSO$
      EGAPALETTE(), FONTRESET()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      VIDEOINIT()
   $ONELINER$
      Reinitializes a video system after a RUN
   $SYNTAX$
      VIDEOINIT()

   $DESCRIPTION$
      When you call an external program through RUN, or add on library
      routines that change the screen mode or other related settings, use
      VIDEOINIT() to reinitialize the CA-Clipper Tools internal video system.

   $NOTES$
      ■  Despite the fact no value is returned, the Var variable
         contains a value of .F. when you attempt something like Var:=
         VIDEOINIT().

   $EXAMPLES$
      ■  After calling an external program...

         RUN VGATEST.EXE

      ■  ...reset the CA-Clipper video system:

         VIDEOINIT()

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      VIDEOSETUP()
   $ONELINER$
      Queries video mode at system start
   $SYNTAX$
      VIDEOSETUP() --> nVideoMode

   $RETURNS$
      The returned number designates which video mode is installed at system
      start.  The following codes apply:

      Table 6-5: Video Mode Coding
      <table>
          Code    Mode

          0       Impossible to determine video mode
          1       Monochrome display w/color card & 40 columns
          2       Monochrome display w/color card & 80 columns
          3       Monochrome w/80 columns (HERCULES or IBM monochrome)
         </table>

   $DESCRIPTION$
      Depending on whether you have an XT or AT, this function returns the dip
      switch setting of the motherboard and/or the CMOS-RAM setting.

   $NOTES$
      ■  VIDEOSETUP() always returns the video mode at the time of the
         booting.

   $EXAMPLES$
      Display video mode of a monochrome system:

      ? VIDEOSETUP()            // returns:  3

   $PLATFORMS$
      DOS
   $SEEALSO$
      IsEGA(), IsHercules()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      VideoType()
   $ONELINER$
      Returns bit-coded information about available video modes
   $SYNTAX$
      VideoType() --> nVideoBitMode

   $RETURNS$
      VideoType() returns a value that reveals the bit codes for available
      video modes.

   $DESCRIPTION$
      This function returns bit-coded information about which video modes are
      available.  If needed, you can set more bits.  A HERCULES adapter is
      also a monochrome adapter; and a VGA card can emulate many different
      modes.  The following codes are used:

      Table 6-6: Coding of Screen Modes
      <table>
          Bit     Definition

          1       Monochrome adapter
          2       CGA adapter
          3       HERCULES adapter
          4       MCGA adapter
          5       PGA adapter
          6       EGA adapter
          7       GA adapter
         </table>

      Since different cards imitate several modes, the following values are
      usually returned:

      Table 6-7: Grouping of Screen Modes
      <table>
          Value   Symb. constants     Definition

          1       VCARD_MONOCHROME    Monochrome adapter
          2       VCARD_CGA           CGA adapter
          5       VCARD_HERCULES      HERCULES, also emulates monochrome
          10      VCARD_MCGA          MCGA, also emulates CGA
          19      VCARD_PGA           PGA, also emulates CGA and monochrome
          55      VCARD_EGA           EGA, emulates all those previously
                                      mentioned, except MCGA
          127     VCARD_VGA           VGA, emulates all those previously mentioned
         </table>

   $NOTES$
      ■  The information presented here assumes absolute hardware
         compatibility.

   $EXAMPLES$
      ■  Is it a VGA card?

         IF IsBit(VideoType(), 7)
            *...
         ENDIF

      ■  Is CGA mode available?

         IF IsBit(VideoType(), 2)
            *...
         ENDIF

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Disk Utilities
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      <b>Fundamental to the disk functions</b>

      <b>Fault tolerance and more</b>

       One of the biggest problems in stable application development is how to
       handle errors.  Errors that occur during hard or floppy disk operations
       are especially frustrating.  You may also encounter critical errors,
       which disable the program or operating system.  The result, known to all
       CA-Clipper programmers, are the DOS error choices:  (A)bort, (R)etry,
       (I)gnore.

      <b>Avoiding Errors</b>

       Error trap functions allow you to react to this type of error, but a
       strategy to avoid them completely is better.  Therefore, CA-Clipper
       Tools includes functions to make it easier to handle floppy and hard
       disk errors.

      <b>Backup Systems</b>

       Backup systems, another component of the CA-Clipper application, are
       also discussed in this chapter.  The recursive FileSeek() system, which
       allows you to format disks with DISKFORMAT(), is particularly useful.
       Complete directories can be scanned recursively, and queries regarding
       detailed information for every file can be made.  The ideal time to
       carry out this process is during source and target drive back ups,
       because only the information that has changed is copied.

       To avoid the annoying and not particularly fault-tolerant "RUN FORMAT",
       you can format the file disks directly from the application in all
       commonly available formats.  Since the control UDF for DISKFORMAT() uses
       a concept similar to dbEdit(), you can display the format procedures on
       the screen as desired.

       You can also determine a good deal of varied information about disk
       drives, files, and other things.  This information far exceeds that of
       the FileSeek() system.

      <b>File Attributes</b>

       Following is the coding for each function where a file can be
       designated:

       Table 1:
       <table>
           Value   Symb. constants     Assigned attribute

           0       FA_NORMAL
           1       FA_READONLY         READ ONLY
           2       FA_HIDDEN           HIDDEN
           4       FA_SYSTEM           SYSTEM
           8       FA_VOLUME           VOLUME
           16      FA_DIRECTORY        DIR
           32      FA_ARCHIVE          ARCHIVE
          </table>

       If multiple attributes are implemented for a file, then the table
       values are added accordingly.  For example, if the HIDDEN and SYSTEM
       attributes are implemented, the function must pass a 6 (2 + 4) as the
       attribute mask.

       All file attributes do not behave the same.  To initiate a file into the
       process, you must explicitly specify the HIDDEN, SYSTEM, VOLUME and DIR
       attributes.  However, if either no attribute, R/O, or ARCHIVE is
       implemented with a file, it does not matter which value is passed.
       These rules for attribute handling are grounded in DOS, which compares
       the specified value with the actual file attributes in this way.  Since
       in some circumstances this may lead to problems, the FileSeek() function
       allows you to switch on an additional EXACT ATTRIBUTE MATCHING.

      <b>Share Modes</b>

       For DOS version 3.0 or higher, if a function uses the DOS OPEN FILE call
       internally, it must pass a share mode.  This way, one station determines
       how all other stations in the network can access the open file. This is
       valid for as long as the file remains open.  The following variations
       exist:

       Table 3:  Share Mode
       <table>
           Code    Symb. constants     Share Modes

           0       SHARE_COMPAT        Compatibility mode.  Here, DOS or the
                                       network software itself, determines the
                                       share mode.  In Novell networks, the
                                       SHAREABLE attribute plays an important role
                                       in this relationship.
           1       SHARE_EXCLUSIVE     Both read and write by other programs are
                                       locked out
           2       SHARE_DENYWRITE     Write by other programs are locked out
           3       SHARE_DENYREAD      Read by other programs are locked out
           4       SHARE_DENYNONE      Not locked.  Read and write by other
                                       programs is allowed
          </table>

       With the basic setting, all files are opened in the compatibility mode
       (relating to older DOS).  As a rule, the share mode depends on file
       attributes or the network software setting.

       Also in this chapter is the SETSHARE() function, which determines the
       share mode that enables all CA-Clipper Tools functions to open a file.
       CA-Clipper commands or functions are not affected in any way.

      <b>CSetSafety()</b>

       Use the CSetSafety() function as a safety switch to protect existing
       files from unwanted overwriting during file operations with CA-Clipper
       Tools functions.  You will find this function in the chapter on Switches
       and Status Information, since it concerns all CA-Clipper Tools file
       operations.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DeleteFile()
   $ONELINER$
      Deletes an error-tolerant file
   $SYNTAX$
      DeleteFile(<cFileName>) --> nErrorCode

   $ARGUMENTS$
      <cFileName>  Designates which file name to delete.

   $RETURNS$
      DeleteFile() returns a code that signifies its completion status:

      Table 7-1:  DeleteFile() Error Codes
      <table>
          Code    Symb. constants     Definition

           0      NO_DISK_ERR         No error occurs
          -2      ER_FILE_NOT_FOUND   File not found
          -3      ER_PATH_NOT_FOUND   Path not found
          -5      ER_ACCESS_DENIED    Access denied (e.g., file is read-only)
         </table>

   $DESCRIPTION$
      In contrast to FileDelete(), which permits you to specify file groups
      with wildcards, DeleteFile() only accepts specific file names.  However,
      the function avoids all DOS error messages and returns an error code
      directly to the calling program.  This makes error-tolerant erasures in
      networks possible (see Examples).

   $NOTES$
      ■  You can use a drive designator and path name, but no
         wildcards.

   $EXAMPLES$
      ■  How NOT to delete a file in a network environment:

         IF FILE ("TEST.DBF")
            * Is it actually possible to delete the file?
            DELETE FILE TEST.DBF
         ENDIF

      ■  This is a better way:

         nStatus  :=  DeleteFile("TEST.DBF")
         IF nStatus == 0
            ? "File deleted."
         ELSE
            IF nStatus == -5
               ? "ACCESS DENIED!"
               ? "File in use elsewhere!"
            ENDIF
         ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileDelete(), RenameFile()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DirChange()
   $ONELINER$
      Changes the current directory
   $SYNTAX$
      DirChange(<cDirectory>) --> nErrorCode

   $ARGUMENTS$
      <cDirectory>  Designates the path of the directory that is changed.

   $RETURNS$
      DirChange() returns a 0 when it successfully changes the directory;
      otherwise, an error code is passed.  The codes are defined as follows:

      Table 7-2:  DirChange() Error Codes
      <table>
          Code    Symb. constants     Definition

           0      NO_DISK_ERR         No error occurred
          -2      ER_FILE_NOT_FOUND   File not found
          -3      ER_PATH_NOT_FOUND   Path not found
          -5      ER_ACCESS_DENIED    Access denied (e.g., in network)
         </table>

      DirChange() changes the current subdirectory or determines if a
      directory exists.  This allows DOS error messages to be intercepted.
      (See also DirMake()).

   $NOTES$
      ■  <cDirectory> may contain a drive designator and a path.
         Wildcards are not allowed.

   $EXAMPLES$
      Change to the "\DATA" directory:

      IF DirChange("\DATA") == 0
         ? "Current directory is now:  " + DirName()
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DirMake(), DirName(), DirRemove()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DirMake()
   $ONELINER$
      Creates a directory
   $SYNTAX$
      DirMake(<cDirectory>) --> nErrorCode

   $ARGUMENTS$
      <cDirectory>  Designates the directory name to create.

   $RETURNS$
      DirMake() returns a 0 when it has successfully created the directory;
      otherwise, an error code is passed.  The codes are defined as follows:

      Table 7-3:  DirMake() Error Codes
      <table>
          Code    Symb. constants     Definition

           0      NO_DISK_ERR         No error occurred
          -2      ER_FILE_NOT_FOUND   File not found
          -3      ER_PATH_NOT_FOUND   Path not found
          -5      ER_ACCESS_DENIED    Access denied (e.g., in network)
         </table>

   $DESCRIPTION$
      When you install the program, directories must be the first thing you
      create.  The DirMake() function allows you to create new directories
      from within your CA-Clipper application.

   $NOTES$
      ■  <cDirectory> can contain a drive designator and a path,
         wildcards are not allowed.

   $EXAMPLES$
      Change to the "\DATA" directory:

      IF DirChange("\DATA") == -3         // Path not found
         DirMake("\DATA")
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DirChange(), DirName(), DirRemove()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DirName()
   $ONELINER$
      Determines the name of the current directory
   $SYNTAX$
      DirName([<cDrive>]) --> cDirectory

   $ARGUMENTS$
      <cDrive>  Designates the drive for which the current directory is
      determined (a colon is unnecessary).  The default is the current drive.

   $RETURNS$
      DirName() returns the current directory name on the <cDrive>.

   $DESCRIPTION$
      DirName() determines the current directory name on the selected drive.
      You can use this function to construct complete access paths.

   $NOTES$
      ■  The maximum length of the returned value is 65 characters.  If
         no drive designator is specified, the current drive is assumed.

      ■  If there is an invalid drive designation, DirName() returns a
         null string.

   $EXAMPLES$
      ■  Display the current directory name:

         ? "Current Directory:  " + DirName()

      ■  With a drive designator:

         ? DirName("A")               // Current directory on Drive A:

   $PLATFORMS$
      DOS
   $SEEALSO$
      DirChange(), DirMake(), DirRemove()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DirRemove()
   $ONELINER$
      Removes a directory
   $SYNTAX$
      DirRemove(<cDirectory>) --> nErrorCode

   $ARGUMENTS$
      <cDirectory>  Designates which directory name to remove.

   $RETURNS$
      DirRemove() returns a 0 when the designated directory is successfully
      removed; otherwise, an error code is returned.  The codes are defined as
      follows:

      Table 7-4:  DirRemove() Error Code
      <table>
          Code    Definition

           0      Directory has been successfully removed.
          -3      Access path not found or directory not empty.
          -5      Access denied (e.g., in a network)
          -16     Current directory (cannot be removed)
         </table>

   $DESCRIPTION$
      DirRemove() removes a designated directory.  This frees up the memory
      disk that an empty subdirectory occupies.

   $NOTES$
      ■  Use a drive designator and access path with <cDirectory>,
         wildcards are not permitted.

      ■  The directory must be empty before you can remove it.

   $EXAMPLES$
      Remove the "\DATA" directory:

      IF DirRemove("\DATA") == 0
         ? "Directory deleted."
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DirChange(), DirMake(), DirName()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DiskChange()
   $ONELINER$
      Changes the current disk drive
   $SYNTAX$
      DiskChange(<cDrive>) --> lChanged

   $ARGUMENTS$
      <cDrive>  Designates which disk drive that you want to use.

   $RETURNS$
      DiskChange() returns .T., when the designated disk drive is successfully
      changed.

   $DESCRIPTION$
      DiskChange() allows you to change from the current disk drive to
      another.  To do this, call DiskChange() with the disk drive identifier
      (A,B,C, etc.).  The drive identifier can be specified with a colon (:).

   $EXAMPLES$
      Change to drive C:

      ? DiskChange("C")         // Returns .T. when successful

   $PLATFORMS$
      DOS
   $SEEALSO$
      DiskName(), DirChange()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DISKCHECK()
   $ONELINER$
      Creates a checksum for a disk
   $SYNTAX$
      DISKCHECK(<cDrive>, [<nStartSector>]) --> nCheckSum

   $ARGUMENTS$
      <cDrive>   Designates which drive (A, B, C, etc.) you want to check.

      <nStartSector>  Designates a sector to serve as a starting point to
      check the disk in the direction of the first sector.

   $RETURNS$
      DISKCHECK() returns a number that corresponds to a checksum for the data
      carrier in <cDrive>.  If read errors occur, the function returns a
      negative number when the first bad sector is found.

   $DESCRIPTION$
      DISKCKECK() begins its check with the last sector of the designated
      drive or with the <nStartSector> value, and works in the direction of
      the first sector.  If a sector is found to contain errors, then it
      returns a negative value.

      If it returns a -1, continue to check for other errors (such as a
      missing disk).  The CA-Clipper Tools function ERRORCODE() is quite
      useful here.  Error code returns a value that symbolizes the most-recent
      DOS error.

      Since DISKCHECK() returns a checksum, it is easy to check for disk
      changes.

   $NOTES$
      ■  You must specify the <cDrive> parameter.  If you omit it or
         specify an unavailable drive, DISKCHECK() returns an error code of -
         1.  DISKCHECK() takes more time to check a hard disk.

   $EXAMPLES$
      ■  Create a checksum for a floppy:

         Checksum  :=  DISKCHECK("A")

      ■  Show that the disks are changed:

         IF DISKCHECK("A") == Checksum
            ? "You have not changed disks!"
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      FILECHECK(), ERRORCODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DISKFORMAT()
   $ONELINER$
      Formats disks, controlled through a UDF
   $SYNTAX$
      DISKFORMAT(<cDrive>, [<nCapacity>], [<cUDF>],
         [<cBootText>], [<nRepetitions>]) --> nErrorCode

   $ARGUMENTS$
      <cDrive>  Designates the disk drive to format.  Only a floppy drive
      is permitted.  You may optionally specify a colon (:).

      <nCapacity>  Designates the appropriate disk capacity for the disk
      you are about to format.  Possible values are 160, 180, 320, 360, and
      1200 for 5.25"; 720 and 1440 for 3.5" disks.  The default is the maximum
      drive capacity.

      <cUDF>  Designates the name of a user-defined function call before
      each format step (track or head change).  The default is no UDF called.

      <cBootText>  This optional parameter designates text, with a maximum
      of 255 characters, to display if the formatted disk is booted.  The
      default is described in the "Notes" section on the following page.

      <nRepetitions>  Designates the number of repeat attempts you should
      make, to format a track before the function aborts.  The default is one
      repetition.

   $RETURNS$
      The function returns 0 when the disk is successfully formatted.

      Table 7-5:  DISKFORMAT() Error Codes
      <table>
          Error Codes  Symb. constants     Definition

           0           NO_DISK_ERROR       Format successful
          -1           DF_WRONG_DRIVE      Illegal drive, only A: and B:  allowed
          -2           DF_WRONG_DISK_SIZ   kB value not supported
          -3           DF_INTERRUPTED      Terminated by control UDF
          -4           DF_WRITE            Write error
         </table>

   $DESCRIPTION$
      DISKFORMAT() formats a disk under full CA-Clipper program control, so
      there is no need for a RUN FORMAT.  You cannot create bootable disks,
      only data disks.

      Since you can call a separate function (UDF) prior to every track and
      head change and the respective track and head number are passed, you can
      construct the visual display of the format process constructed as
      desired.

      You can only format floppy disks, so even with unforeseen incorrect
      parameters, your hard disk is safe.  All the standard floppy types are
      supported -- 160kB, 180kB, 320kB, 360kB, 1.2MB, 720kB, and 1.44MB.

      DISKFORMAT() is useful for formatting disks, at least when the preset
      repetition rate is retained or decreased.  After an unsuccessful attempt
      to format a track, the process is repeated one more time.  If this
      repetition also fails, the entire format is aborted.  If you want to be
      as safe as possible about the quality of the disk in used, select a
      repetition rate of 0.

      *The Control UDF*

      DISKFORMAT() calls the control UDF, which is specified as the third
      parameter, prior to each head and track change.  Both values, head and
      track, are passed as a parameter to the function.  As soon as all tracks
      are formatted and DISKFORMAT() has initialized the FAT and directory
      area, a value of -1 is passed for both parameters to the UDF.  Please be
      aware that both parameters must be passed.

      The numeric value returned for UDF can further influence DISKFORMAT():

      Table 7-6:  Control UDF Returned Values
      <table>
          Returned Value    Explanation

          0                 Continue format
          1                 Do not format this track (parameter 1)
          2                 Abort format
         </table>

   $NOTES$
      ■  If the defined control UDF does not exist, the function
         uninstalls itself and triggers a runtime error.  If an error message
         concerning a missing procedure is required during linking, you can
         specify EXTERNAL <function> in the program.

      ■  If you attempt to boot with a data disk created with
         DISKFORMAT() and did not designate any other text for the <cBootText>
         parameter, the following text is displayed:

          "No system disk.  Insert new disk, press any key to continue"

      ■  DISKFORMAT() begins to format a disk with the highest track
         number.  Therefore, an existing FAT and directory label are the last
         items deleted.

      ■  DISKFORMAT() always reformats a track, even if it is already
         formatted.  Therefore, when a format is successful, all the data is
         deleted.

      ■  Each track is verified again after it is formatted.

      ■  After the last track is formatted, the function continues to
         work a few seconds more.  The FAT and directory must be established
         and the boot text must be written.

   $EXAMPLES$
      ■  An example for formatting a disk in A: drive:

         DISKFORMAT() first determines whether the desired capacity is
         appropriate for the drive.  The control UDF "CONTROL" is concerned
         with the display of the track and head that are currently being
         formatted.  "This is a data diskette" is used as boot text for the
         disk.  The repeat rate is highly effective at 0.  Only the highest-
         quality disks are accepted.

         To provide an additional example of the return value for the UDF,
         only tracks 80 to 11 are formatted here, not the first 10:

         CLEAR
         cBootText  :=  "This is a data diskette"
         @ 10, 02 SAY "Track:
         "@ 11, 02 SAY "Head:
         "IF FLOPPYTYPE("A:") = 2
                                       // 1.2 MB disk
            nErrCode := DISKFORMAT("A:", 1200", CONTROL", cBootText, 0)
            IF nErrCode = 0
               ? "Format successful!"
            ENDIF
         ENDIF
         RETURN

         FUNCTION CONTROL(nTrack, nHead)
            LOCAL nRetval
            IF Track >= 11
               @ 10, 08 SAY Str(nTrack)
               @ 11, 08 SAY Str(nHead)
               nRetval := 0            // Continue format
            ELSE
               nRetval := 2            // Abort
            ENDIF
            RETURN(nRetval)

      ■  Shown below is another variation of the UDF.  Press the ESC
         key to abort the format.  If the format is completed, then the
         function displays the FAT initialization and root directory:

         FUNCTION CONTROL(nTrack, nHead)
            LOCAL nRetval
            IF Inkey() = 27
               nRetval := 2            // Abort
            ELSE
               nRetval := 0            // Continue format
            ENDIF
            IF nTrack = -1
               @ 10, 10 SAY "Initializing FAT and Root Directory!"
            ENDIF
            RETURN(nRetval)

   $PLATFORMS$
      DOS
   $SEEALSO$
      DriveType(), FLOPPYTYPE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DiskFree()
   $ONELINER$
      Determines the space available on a floppy or hard disk
   $SYNTAX$
      DiskFree([<cDrive>]) --> nFreeByte

   $ARGUMENTS$
      <cDrive>  Designates for which drive (A, B, C, etc.) the open
      capacity is determined.  The default value is the current drive.

   $RETURNS$
      DiskFree() returns the available memory capacity of the selected drive.

   $DESCRIPTION$
      DiskFree() determines if a disk has sufficient storage capacity for a
      file.

   $NOTES$
      ■  When <cDrive> is not specified, the function automatically
         uses the current drive.

   $EXAMPLES$
      Determine if there is enough space to copy a database:

      Required  :=  DbfSize()         // Database size
      IF DiskFree("A") < Required
         ? "Insufficient disk space for copying!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DiskTotal()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DiskName()
   $ONELINER$
      Determines the drive designator for the current drive
   $SYNTAX$
      DiskName() --> cDrive

   $RETURNS$
      DiskName() returns a letter that identifies the designator as the
      current drive.

   $DESCRIPTION$
      DiskName() determines the current drive designator for the construction
      of complete path names.

   $NOTES$
      ■  The designator does not contain a colon.

   $EXAMPLES$
      Display the drive designator for the current drive:

      ? DiskName()      // Returns a "C" with most hard disk systems

   $PLATFORMS$
      DOS
   $SEEALSO$
      DirName()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DISKREADY()
   $ONELINER$
      Tests to see if a disk drive is ready
   $SYNTAX$
      DISKREADY([<cDrive>], [<lDOS/BIOS>]) --> lDiskReady

   $ARGUMENTS$
      <cDrive>  Designates the drive designator (A, B, C, etc.) of the
      drive to test.  The default is the current disk drive.

      <lDOS/BIOS>  This logical parameter allows you to designate whether
      you want the function tested through the BIOS (.F.) or DOS (.T.).  The
      default is discussed in the Description below.

   $RETURNS$
      DISKREADY() returns .T. when the drive being tested is ready to use.

   $DESCRIPTION$
      To save space, you must frequently make multiple disk copies.
      DISKREADY() allows you to wait for a user disk change, without having to
      confront known DOS errors, or use CA-Clipper error trap functions.  Be
      sure to differentiate between floppy tests and "true" hard disks and
      logical partitions.

      *DOS or BIOS*

      In the simplest case, this function tests the respective drive through
      DOS.  If drive B is unavailable, the message  "Please insert disk in
      drive B:..." is output from the operating system.  When you test floppy
      drives, drive A: and B:, the BIOS route is recommended, since no message
      is output.  In any event, A: and/or B: can be mapped drives within a
      network.  Use the following logical expression for all the previous
      situations:

      (NetDisk(<cDrive>) .OR. <cDrive> >= "C")

      This logical expression returns .T. when the respective drive is either
      on the network or has a drive identifier of C: or higher.

   $EXAMPLES$
      The system waits between individual copy procedures until drive A: is
      ready again:

      DO Copy                        // Call copy procedure
      ? "Please insert a disk in Drive A:!"
      DO WHILE .NOT. DISKREADY("A")
         *...
      ENDDO
      DO Copy                        // Call copy procedure

   $PLATFORMS$
      DOS
   $SEEALSO$
      DISKREADYW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DISKREADYW()
   $ONELINER$
      Queries whether you can write to a drive
   $SYNTAX$
      DISKREADYW([<cDriveId>]), [<lDOS/BIOS>]) --> lDiskReady

   $ARGUMENTS$
      <cDriveId>  Designates which drive designator (A, B, C, etc.) to
      query.  The default value is the current disk drive.

      <lDOS/BIOS>  This logical parameter allows you to specify whether
      you want to query the function through the BIOS (.F.) or DOS (.T.).  The
      default is described in the Description below.

   $RETURNS$
      DISKREADYW() returns .T. when you query a drive that is operational and
      can be written to.

   $DESCRIPTION$
      As with DISKREADY(), this function determines if a drive is ready to
      use.  DISKREADYW() also determines if you can write to a drive.
      DISKREADY() cannot tell if a disk has a write-protect marker on it.  In
      this case, drive A: might be ready, but you could not write to it.  Use
      this function to build write-protect detection for important disks into
      the program.

      *Network Drives*

      In general, drives mapped within networks are viewed by the function as
      accessible and return .T. as a result.  For a disk, "accessible" means
      you can create, open, and delete files.  You can clearly differentiate
      these rights within networks such as Novell NETWARE.  Therefore, you
      must test for these accordingly.

      *DOS or BIOS*

      In the simplest case, this function always tests the respective drive
      through DOS.  If drive B: is unavailable, the message  "Please insert
      disk in drive B:" is output from the operating system.  When you test
      floppy drives drive A: and B:, the BIOS route is recommended, since no
      message is output.  In any event, A: and/or B: can be mapped drives
      within a network.  Use the following logical expression to cover all the
      previous situations:

      (NetDisk(<cDrive>) .OR. <cDrive> >= "C")

      This logical expression returns .T. when the respective drive is either
      on the network or has a drive identifier of C: or higher.

   $NOTES$
      ■  Research indicates work in the OS/2 compatibility box must be
         in the BIOS mode.

   $EXAMPLES$
      Determine if you can write a file to A: drive:

      IF DISKREADY("A")
         IF NETDISK ("A")
            IF NNETRIGHTS ("A:\")      // complete path
            * ...
            ENDIF
         ELSE
            IF DISKREADYW("A")
            ? "Disk is not write protected!"
            ELSE
            ? "Disk is write protected!"
            ENDIF
         ENDIF
      ELSE
         ? "Disk drive not ready!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DISKREADY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DISKSPEED()
   $ONELINER$
      Determines a comparison value for the drive speed
   $SYNTAX$
      DISKSPEED(<cDrive>) --> nDriveSpeed

   $ARGUMENTS$
      <cDrive>  Designates for which physical drive identifier (A, B, C,
      etc.) to determine the speed.  You do not need to use the colon (:).

   $RETURNS$
      DISKSPEED() returns a percentage comparison value to a floppy drive of a
      4.77 MHz PC, which corresponds to 100%.

   $DESCRIPTION$
      Use this function when you want to calculate the approximate duration of
      such complex file operations as INDEX or SORT.  Since the total duration
      always depends upon the remaining computer speed, you should also use
      the SPEED() function..

      If the designated drive is unavailable or cannot be checked (network
      drive), the function returns a 0 value.

   $NOTES$
      ■  You can only implement DISKSPEED() for physical drives, not
         network drives.

   $EXAMPLES$
      ■  Show the speed of drive A:

         ? DISKSPEED("A")            // depends on drive

      ■  Show the factor for your hard disk:

         ? DISKSPEED("C")            // e.g. 720  Factor 7.2

   $PLATFORMS$
      DOS
   $SEEALSO$
      SPEED()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DISKSTAT()
   $ONELINER$
      Determines the status of a drive.
   $SYNTAX$
      DISKSTAT([<cDrive>]) --> nStatus

   $ARGUMENTS$
      <cDrive>  Designates the drive designator (A, B, C, etc.) of the
      drive for which the status of the last operation is determined.  The
      default is the current disk drive.

   $RETURNS$
      DISKSTAT() returns the status of the floppy or hard disk operation as a
      number.  The bits have the following meanings:

      Table 7-7:  Drive Status Coding
      <table>
          Bit     Symb. constants     Definition

          1       DST_INVALID         Unknown command
          2       DST_READONLY        Address marker not found
          3       DST_SECTOR          Sector not found
          4       DST_DMA             DMA overflow
          5       DST_CRC             CRC error
          6       DST_CONTROLLER      Controller error
          7       DST_SEEK            Seek operation failure
          8       DST_TIMEOUT         Timeout error
         </table>

   $DESCRIPTION$
      When DOS returns a "block device error" message  (See ERRORORG()) and
      DISKSTAT() to determine a more detailed cause of the error).

   $NOTES$
      ■  This function passes the system status to a CA-Clipper
         application.  The system saves a status value for all floppy and hard
         disk operations.  When you reaccess a floppy disk drive from within
         your program, the previous disk operation status is lost.  The same
         applies to hard disk status.

   $EXAMPLES$
      Determine if the system was unable to find an address marker:

      IF ERRORORG() == DST_READONLY
         DiskError  :=  DISKSTAT("A")
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      ERRORBASE(), ERRORCODE(), ERRORORG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DiskTotal()
   $ONELINER$
      Determines the total capacity of a floppy or hard disk
   $SYNTAX$
      DiskTotal([<cDrive>]) --> nTotalSpace

   $ARGUMENTS$
      <cDrive>  Designates the drive for which memory capacity is
      determined.  The default is the current drive.

   $RETURNS$
      DiskTotal() returns a value that corresponds to the total capacity of
      the data carrier in the selected drive.  The default is the current disk
      drive.

   $DESCRIPTION$
      DiskTotal() determines if the capacity of the disk in use is sufficient
      for back up.  The advantage of DiskTotal() over any capacity determined
      by the system, is that it recognizes bad sectors and does not include
      them.

   $EXAMPLES$
      Determine if disk capacity is sufficient:

      nRequired  :=  DbfSize()
      IF DiskTotal("A") < nRequired
         ? "Error! Insufficient disk capacity!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DiskFree()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DISKTYPE()
   $ONELINER$
      Determines the type of data carrier
   $SYNTAX$
      DISKTYPE([<cDrive>]) --> nDiskType

   $ARGUMENTS$
      <cDrive>  Designates the drive designator (A, B, C, etc.) for which
      you want to determine the data carrier.  The default is the current
      drive.

   $RETURNS$
      The returned value corresponds to the FAT-ID byte of a floppy or hard
      disk.  The following codes apply:

      Table 7-8:  FAT-ID Definitions
      <table>
          FAT-ID  Symb. constants     Definition

          255     DT_DS_SEC_8         Double sided 8 sectors
          254     DT_SS_SEC_8         Single sided 8 sectors
          253     DT_DS_SEC_9         Double sided 9 sectors
          252     DT_SS_SEC_9         Single sided 9 sectors
          249     DT_DS_SEC_15        Double sided 15 sectors (HD-Disk)
          249     DT_35_SEC_9         Double sided 3.5" 9 sectors (ident. to 5.25"
                                      HD)
          240     DT_35_SEC_18        Double sided 3.5" 18 sectors
          248     DT_HARDDISK         Hard disk
         </table>

   $DESCRIPTION$
      If a 360K floppy is written on an AT in a 1.2 MB drive, you may not be
      able to read it on other systems, particularly on PC XTs.  This function
      determines how the floppy you are about to use is formatted and provides
      the corresponding warning.

   $EXAMPLES$
      Determine if an XT disk is being written to an AT:

      IF IsAt() .AND. DISKTYPE("A") == DT_DS_SEC_9
         ? "Warning!"
         ? "Under certain circumstances this disk not"
         ?? " readable on other systems!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DiskName(), DriveType(), FLOPPYTYPE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DriveType()
   $ONELINER$
      Determines the drive type
   $SYNTAX$
      DriveType([<cDrive>]) --> nDriveType

   $ARGUMENTS$
      <cDrive>   Designates the drive (A, B, C, etc.) for which the type
      is determined.  The default is the current drive.

   $RETURNS$
      DriveType() returns a numeric value for the drive type.  The following
      codes apply:

      Table 7-9:  Drive Type Coding
      <table>
          Code    Definition

          0       RAM Disk
          1       Floppy Disk (disk change cannot be established by system)
          2       Floppy Disk (disk change can be established by system)
          3       Hard Disk
         </table>

   $DESCRIPTION$
      Warning!  Only for AT-class computers.

      This function determines if you are dealing with a floppy drive, a hard
      disk, or a RAM disk.

   $NOTES$
      ■  Although DriveType() returns a 0 value for logical DOS
         partitions, RAM floppies, and unavailable drives, you must also
         differentiate with DISKTYPE().  Here, each hard disk partition
         returns a 248 value.  A RAM floppy created with VDISK.SYS behaves
         like a single-sided floppy with eight sectors, which returns a 254
         value.  If there is an unavailable drive, the DISTYPE() returns a
         value of 0.

   $EXAMPLES$
      Determine if the drive is a RAM floppy:

      IF DriveType() == 0 .AND. DISKTYPE() == 254
         ? "Drive " + DiskName() + ":  is a RAM-disk!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DISKTYPE(), DiskName()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileAppend()
   $ONELINER$
      Appends data to a file
   $SYNTAX$
      FileAppend(<cSourceFile>, <cTargetFile>)
         --> nAttachedByte

   $ARGUMENTS$
      <cSourceFile>  Designates the file that is appended to
      <cTargetFile>.

      <cTargetFile>  Designates the file to which <cSource> is appended.
      Drive and path designation are permitted for both files, wildcards are
      not.

   $RETURNS$
      FileAppend() returns the number of characters appended on to
      <cTargetFile>.

   $DESCRIPTION$
      FileAppend() takes fragmented files, split them up on different floppies
      and reassemble them.  This sort of fragmented file could be created with
      the FileCopy() system described in this chapter.  You only need explicit
      information, such as VOLUME labels, to recognize the different disks.
      If the target file does not exist, it is created with FileAppend().  If
      an error occurs while appending to the target file, the file deletes
      completely to avoid accidental and incorrect results.

      Never append data to file if there is no backup copy.

   $NOTES$
      ■  Use SetFCreate(), if FileAppend() creates a new file and an
         alternative attribute needs to be specified.

      ■  Use SETSHARE() to protect a target file from access, if it is
         on a network drive.

   $EXAMPLES$
      Shown below is a simplified program to reassemble a file that is divided
      among several disks by a FileCopy() backup.

      A catalog contains a list of the disks used during backup in the form of
      volume labels and backup file names.

      Structure of the DISKLIST catalog:

      Table 7-10: DISKLIST File Structure
      <table>
          Field Name     Field Content

          VolLabel       Back up disk drive and volume label
          BackupName     Back up file name, incl. drive and path
         </table>

      The data in DISKLIST is created by a FileCopy() backup:

      USE DISKLIST                                 // Saved volume labels
      cTargetFile  :=  "C:\TARGET.TXT"
      DO WHILE .NOT. Eof()
         IF .NOT. Empty(FileSeek(cVolLabel, 8)     // Correct disk ?
            FileAppend(cBackupName, cTargetFile)   // Yes, append data
            SKIP
         ELSE
            ? "Please insert the correct disk  !"
         ENDIF
      ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileCopy(), FileSeek(), SETSHARE(), SetFCreate(), CSetSafety()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileAttr()
   $ONELINER$
      Determines a file's attributes
   $SYNTAX$
      FileAttr([<cFile>]) --> nFileAttr

   $ARGUMENTS$
      <cFile>  Designates the file name, including the path and drive
      designation.

   $RETURNS$
      FileAttr() returns the attributes for the researched entry or the
      attribute from the FileSeek() buffer (when called without a parameter).

   $DESCRIPTION$
      FileAttr() is implemented alone or in conjunction with FileSeek().  If
      the function is called with the <cFile> parameter, it returns the
      attribute of the first entry found.  If no acceptable entry is
      available, a value of 0 is returned.

      When called without a parameter, FileAttr() returns the attribute for
      the most-recent file located with FileSeek().  When used with
      FileSeek(), you can determine the attribute for file groups (wildcards).

      When you call FileAttr() with the <cFile> parameter, the function
      internally passes 63 (all attributes) as a mask.  When used in
      conjunction with FileSeek(), you should also designate all 63 as an
      attribute mask, if all files are to be acknowledged.

      Table 7-11:  Coding the File Attribute
      <table>
          Value   Symb. constants     Assigned attribute

          0       FA_NORMAL
          1       FA_READONLY         READ ONLY (Read-only)
          2       FA_HIDDEN           HIDDEN (Hidden files)
          4       FA_SYSTEM           SYSTEM (System files)
          8       FA_VOLUME           VOLUME (Name of a floppy/hard disk)
          16      FA_DIRECTORY        DIR (Directory)
          32      FA_ARCHIVE          ARCHIVE (Changes since last backup)
         </table>

      If multiple attributes are implemented for a file, the value of each
      corresponding attribute is added.

   $EXAMPLES$
      ■  Show the attribute of a specific file:

         ? FileAttr("C:\TEXT\TEXT.TXT")      // 32  ARCHIVE

      ■  The attribute for an ARCHIVE/HIDDEN file:

         ? FileAttr("C\HIDE.TXT")            // 34  HIDDEN + ARCHIVE

      ■  Used in conjunction with FileSeek():

         cFile  :=  FileSeek("C:\TEXT\TEXT.TXT")
         DO WHILE .NOT. EMPTY (cFile)
            ? cFile, FileAttr()              // Name & file attribute
            cFile  :=  FileSeek()            // Search for next entry
         ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSeek(), FileDate(), FileSize(), FileTime()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileCCLose()
   $ONELINER$
      Closes a file after backup mode
   $SYNTAX$
      FileCCLose() --> lClosed

   $RETURNS$
      FileCCLose() returns .T., when the the file that was opened with
      FileCopy() is successfully closed.

   $DESCRIPTION$
      FILE COPY CLOSE
      After you copy on multiple disks, this function should be routinely
      called.  This is to prevent the source file, previously designed with
      FileCopy(), from remaining open.  For example, this may occur if you
      terminate the copy procedure.

   $NOTES$
      ■  Regardless of the share mode, all other users are not allowed
         access. This situation stays this way without needing a file handle.

   $EXAMPLES$
      Show a back up with FileCopy().  After terminating, close the source
      file:

      FileCopy(cSource, cTarget, .T.)      // Back up mode
      DO NEXTDISK                          // When terminated   Terminated =
      .T.
      DO WHILE FileCOpen() .AND. .NOT. Terminated
         FileCCont(cTarget)                // Next disk, new name
         DO NEXTDISK                       // Request for disk exchange
      ENDDO
      IF Terminated
         FileCCLose()                      // Close source file!
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileCopy(), FileCCont(), FileCOpen()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileCCont()
   $ONELINER$
      Copies sections of a file in backup mode
   $SYNTAX$
      FileCCont(<cFile>) --> nCopyByte

   $ARGUMENTS$
      <cFile>  Designates the file name for the target file.

   $RETURNS$
      FileCCont() returns the number of bytes copied.

   $DESCRIPTION$
      FILE COPY CONTINUE
      Use this function primarily after a FileCopy().  As much as possible of
      the remaining data is written to a new disk.  If the remaining data
      still does not fit on the designated target disk, call this function
      repeatedly until it writes all the remaining data.  Each time you call
      FileCCont(), a new name can be designated for the target file.  These
      files are then numbered consecutively (see Examples).

   $NOTES$
      ■  If a copy procedure on multiple disks terminates for any
         reason, call FileCCLose().

      ■  Use SetFCreate() to designate an attribute to form a new file.

      ■  The function acknowledges the CSetSafety() implementation, as
         does FileCopy()

   $EXAMPLES$
      Show a back up with FileCopy().  After terminating, close the source
      file:

      FileCopy(cSource, cTarget, .T.)   // Back up mode
      DO NEXTDISK                       // When terminated  Terminated = .T.
      DO WHILE FileCOpen() .AND. .NOT. Terminated
         FileCCont(cTarget)             // Next disk, new name
         DO NEXTDISK                    // Request for disk exchange
      ENDDO
      IF Terminated
         FileCCLose()                   // Close source file!
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileCopy(), FileCOpen(), FileCCLose(), FileCDaTi()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileCDaTi()
   $ONELINER$
      Determines whether a source file's date and time stamp or the system's date and time stamp, should be used to create or copy a file.  Use original or
   $SYNTAX$
      FileCDaTi([<lNewMode>]) --> lOldMode

   $ARGUMENTS$
      <lNewMode>  Designates the new status for FileCDaTi().  When .T. is
      designated, the target file contains the source file date; when it is
      .F., the system date.  The default is the source file date (.T.).

   $RETURNS$
      If no parameter is designated, FileCDaTi() returns the current setting
      for FileCDaTi(); otherwise, it returns the previous setting.

   $DESCRIPTION$
      FILE COPY DATE TIME
      FileCDaTi() determines which date the target file contains with a
      FileCopy().  When you partition to several disks in backup mode, this
      concerns all target files.  The CA-Clipper Tools default is .T., where
      the target file contains the date and time of the source file.  If you
      call FileCDaTi() with the parameter designated .F., then the target file
      contains the system date and time.

   $NOTES$
      ■  Use this function before FileCopy().

      ■  If the target file contains a unique setting such as a pseudo
         serialization, use the SetFDaTi() function.

   $EXAMPLES$
      ■  Query the FileCDaTi() setting:

         ? FileCDaTi()            // The current setting

      ■  The target file is to contain the system date and time:

         ? FileCDaTi(.F.)         // Returns the previous setting

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileCopy(), SetFDaTi()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FILECHECK()
   $ONELINER$
      Calculates/computes/determines a checksum for a file
   $SYNTAX$
      FILECHECK(<cFile>) --> nCheckSum

   $ARGUMENTS$
      <cFile>  Designates which file name (with path, if required), to
      check.

   $RETURNS$
      FILECHECK() returns a checksum value for <cFile>.

   $DESCRIPTION$
      FILECHECK() determines if there have been changes or read errors in a
      file, and then takes note of data backup.  This also allows you to
      protect your hard disk from simple viruses (see Examples).

   $NOTES$
      ■  You must specify the argument.  If it is omitted or an
         unavailable file is specified, FILECHECK() returns an error code of -
         1.  You may use a drive and access path, but no wildcards.

   $EXAMPLES$
      ■  Check database for changes:

         IF FILECHECK("CUST.DBF") <> Old_ChkSum
            ? "Warning! Data back-up required."
         ENDIF

      ■  Check COMMAND.COM for changes:

         IF FILECHECK("\COMMAND.COM") <> Cmd_ChkSum
            ? "COMMAND.COM has been changed! Caution, Virus!"
         ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DISKCHECK(), SETSHARE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileCOpen()
   $ONELINER$
      Tests to see if the file is still open in the backup mode
   $SYNTAX$
      FileCOpen() --> lOpenFile

   $RETURNS$
      FileCOpen() returns .T. when all data is not copied during a  FileCopy()
      or FileCCont().

   $DESCRIPTION$
      FILE COPY OPEN
      FileCOpen() determines whether all data is copied.  This concerns the
      source file, which is specified when the FileCopy() function is called.
      FileCOpen() returns .T. until all the data in the source file is read,
      whether by FILECOPY or the follow-on function FileCCont()

   $NOTES$
      ■  If you must abort the copy process, and FileCOpen() continues
         to returns .T., use FileCCLose().

   $EXAMPLES$
      Show a back up with FileCopy():

      nCounter   := 1                   // "BIG.001" etc.
      cTargetFile   := "BIG" + NToC(nCounter, 10, 3, "0")
      FileCopy("BIG.DBF", "A:\" + cTargetFile, .T.)
                                        // Back up mode
      DO WHILE FileCOpen()
         DO NEXTDISK                    // Request disk change
         nCounter     := nCounter + 1
         cTargetFile  := "BIG" + NToC(nCounter, 10, 3, "0")
         FileCCont(cTargetFile)         // Next disk - new name

      ENDDO
      FILECCLOSE                        // For safety

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileCopy(), FileCCont(), FileCCLose()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileCopy()
   $ONELINER$
      Copies files normally or in backup mode
   $SYNTAX$
      FileCopy(<cSourceFile>, <cTargetFile>, [<lMode>])
         --> nCopyByte

   $ARGUMENTS$
      <cSourceFile>  Designates the source file.  Drive and path
      designations are permitted, but not wildcards.

      <cTargetFile>  Designates the target file.  Drive and path
      designations are permitted, but not wildcards.

      <lMode>  Designates the backup mode on when designated as .T.  The
      default is no backup mode (.F.).

   $RETURNS$
      FileCopy() returns the number of bytes copied.

   $DESCRIPTION$
      This function has additional uses besides allowing you to quickly copy
      files.  When you use the optional <lMode> parameter, a unique backup
      mode is switched on.  This allows files that are larger than the target
      disks to be copied.  This function writes the maximum possible number of
      bytes to a disk.  FileCOpen() allows you to determine whether all data
      from the source file has been copied.  It then continues with the next
      disk.  The target disks should contain unique labels and be saved to a
      catalog.

   $NOTES$
      ■  The attribute to be used when newly creating a file can be
         specified with SETCREATE().

      ■  As a minimum, the share mode recommends that you do not write
         other program source and target files.

      ■  This function acknowledges the CSetSafety() setting, and as a
         result, cannot overwrite a target file.

   $EXAMPLES$
      ■  Show a simple copy:

         ? FileCopy("A:\TEXT.TXT", "C:\TEST.TXT")      // Bytes copied

      ■  A back up using FileCopy():

         nCounter  :=  1                               // "BIG.001" etc.
         cTargetFile  := "BIG" + NToC(nCounter, 10, 3, "0")
         FileCopy("BIG.DBF", "A:\" + cTargetFile, .T.)
                                                       // Back up mode
         DO WHILE FileCOpen()
            DO NEXTDISK                                // Request disk change
            nCounter     := nCounter + 1
            cTargetFile  := "BIG" + NToC(nCounter, 10, 3, "0")
            FileCCont(cTargetFile)                     // Next disk - new name
         ENDDO
         RETURN

         PROCEDURE NEXTDISK
            ? "Please insert new diskette in Drive A:!"
            WAIT
            RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileCCont(), FileCOpen(), FileCCLose(), FileAppend()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileDate()
   $ONELINER$
      Determines the file date
   $SYNTAX$
      FileDate([<cFileMap>, [<nFileAttr>]]) --> dFileDate

   $ARGUMENTS$
      <cFileMap>  Designates a file name, including its path and drive
      designation.

      <nFileAttr>  Designates the file attribute explained in the table
      below.  The default value is 0.

      ()  If you call this function without parameters, it returns the file
      date from the current FileSeek() buffer.

   $RETURNS$
      FileDate() returns the date of the searched for entry, the date from the
      FileSeek() buffer (when called without parameters), or an empty date.

   $DESCRIPTION$
      You can implement FileDate() alone or in conjunction with FileSeek().
      If you use the <cFileMap> parameter to call this function, it returns
      the date of the first entry found.  If a suitable entry is not present,
      an empty date is returned.

      When called without parameters, FileDate() returns the date of the last
      file it located with FileSeek().  You could also determine the dates for
      a file group (wildcards), when used it in conjunction with FileSeek().

      The attribute for the desired file can be specified in numeric form:

      Table 7-12:  Coding the File Attribute
      <table>
          Value   Symb. constants     Assigned attribute

          0       FA_NORMAL
          1       FA_READONLY         READ ONLY (Read-only)
          2       FA_HIDDEN           HIDDEN (Hidden files)
          4       FA_SYSTEM           SYSTEM (System files)
          16      FA_DIRECTORY        DIR (Directory)
          32      FA_ARCHIVE          ARCHIVE (Changes since last backup)
         </table>

      To find a file, specify only the SYSTEM, HIDDEN, VOLUME, or DIR
      attributes.  If multiple attributes are implemented simultaneously, the
      table values are added accordingly.  Of course, not all combinations are
      useful.

   $EXAMPLES$
      ■  Show the date of a particular file:

         ? FileDate("C:\TEXT\TEXT.TXT")     // The date

      ■  The date of an ARCHIVE/HIDDEN file:

         ? FileDate("C:\HIDE.TXT", 34)      // The date

      ■  Used in conjunction with FileSeek():

         cFile  :=  FileSeek("C:\TEXT\*.TXT")
         DO WHILE .NOT. Empty(cFile)
            ? cFile, FileDate()             // Name & date of file
            cFile  :=  FileSeek()           // Search for next entry
         ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSeek(), FileAttr(), FileTime(), FileSize()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileDelete()
   $ONELINER$
      Deletes file(s) by name and attribute
   $SYNTAX$
      FileDelete(<cFileMask>, [<nFileAttr>]) --> lDeleted

   $ARGUMENTS$
      <cFileMask>  Designates the file or files to delete.

      <nFileAttr>  Designates one of the following file attributes.  The
      default value is 32.

      Table 7-13:  File Attribute Coding
      <table>
          Value     Symb. constants   Definition

          0         FA_NORMAL
          1         FA_READONLY       Read-only
          2         FA_HIDDEN         HIDDEN (Concealed files)
          4         FA_SYSTEM         SYSTEM (System files)
          8         FA_VOLUME         VOLUME (Name of floppy/hard disk)
          32        FA_ARCHIVE        ARCHIVE (Changed since last backup)
         </table>

   $RETURNS$
      FileDelete() returns .T. when at least one or more files are deleted;
      otherwise, .F. is returned.

   $DESCRIPTION$
      Occasionally, you will need to clean up a floppy or a hard disk or
      delete whole file groups.  This function deletes entire file groups with
      a function call, without using the RUN command.

   $NOTES$
      Warning!  FileDelete() can also delete system files.

      ■  The default standard attribute is archive (32).  Drive and
         path designations, and wildcards are permitted.

      ■  Subdirectories must be deleted with the help of the
         DirRemove() function.

   $EXAMPLES$
      Attempt to delete all index files, then display the completion status:

      IF FileDelete("*.NDX")
         ? "Files deleted."
      ELSE
         ? "No files found."
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DeleteFile()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileMove()
   $ONELINER$
      Moves files to another directory
   $SYNTAX$
      FileMove(<cSourceFile>, <cTargetFile>) --> nErrorCode

   $ARGUMENTS$
      <cSourceFile>  Designates the name and the path of the source file.

      <cTargetFile>  Designates the name and the path of the target file.

   $RETURNS$
      FileMove() returns a value of 0 when the file can be moved; otherwise,
      an error code is returned.  The codes are defined below:

      Table 7-14:  FileMove() Error Codes
      <table>
          Code    Symb. constants        Definition

           0      NO_DISK_ERR            No errors
          -2      ER_FILE_NOT_FOUND      File not found
          -3      ER_PATH_NOT_FOUND      Access path not found
          -5      ER_ACCESS_DENIED       Access denied (e.g., network)
          -17     ER_DIFFERENT_DEVICE    Target file not on same drive
         </table>

   $DESCRIPTION$
      If a file is to be copied within a drive and then deleted it from the
      original position, it is quicker to move the file.  FileMove() makes
      this possible.  The directory entries are also changed, which is much
      quicker than copying and deleting.

   $NOTES$
      ■  You can use drive designators and access paths in
         <cSourceFile> and <cTargetFile> file names.  Wildcards are not
         permitted.

      ■  You can only move a file within a drive.  If the target
         directory already contains a file with the same name as the one from
         <cSourceFile>, the move is not completed.  In this case, FileMove()
         returns a value of -5.  The only option available in this situation,
         is to delete the file in the target directory.

   $EXAMPLES$
      Move a file from "\OLD" to "\NEW":

      IF FileMove("\OLD\CUST.DBF", "\NEW\CUST.DBF") = 0
         ? "The file is now in the \NEW directory"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileCopy()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileSeek()
   $ONELINER$
      Searches for files by name and attribute
   $SYNTAX$
      FileSeek([<cFileMap>, [<nFileAttr>], [<lExact>]])
          --> cFileName

   $ARGUMENTS$
      <cFileMap>  Designates a file name including its path and drive
      designation.  It may contain wildcards.

      <nFileAttr>  Designates the file attribute that corresponds to the
      ones described in the table on the next page.  The default value is 0.

      <lExact>  If you designate .T. as the optional parameter, FileSeek()
      also checks for the exact agreement of the file attributes of the
      respective file with the value passed by <nFileAttr>.

      ()  If you call the function without parameters, it serves as a
      sequential call for a FileSeek() with file specifications, and returns
      sequential entries as long as these are found.

   $RETURNS$
      FileSeek() returns the name of the first or next entry (when called
      without parameter) located in the selected directory.

   $DESCRIPTION$
      FileSeek() provides the foundation for a variety of functions.  As a
      group, they permit access to desired information about directory
      entries.  Implement the FileSeek() function when you want information
      about a file group (wildcards).  When you call it with the <cFileMap>
      parameter, it searches for the first entry in the designated directory.
      If you call it without parameters, it searches for the next matching
      entry in the directory.  If no more entries are present, it returns a
      null string.  An attribute mask can further define a file group that is
      being searched for.  The desired file attributes are coded as follows:

      Table 7-15:  Coding the File Attribute
      <table>
          Value   Symb. constants     Assigned attribute

          0       FA_NORMAL
          1       FA_READONLY         READ ONLY (Read-only)
          2       FA_HIDDEN           HIDDEN (Hidden files)
          4       FA_SYSTEM           SYSTEM (System files)
          8       FA_VOLUME           VOLUME (Name of a floppy/hard disk)
          16      FA_DIRECTORY        DIR (Directory)
          32      FA_ARCHIVE          ARCHIVE (Changes since last backup)
         </table>

      If you implement multiple attributes simultaneously, the table values
      are added accordingly.  Of course, not all combinations are useful.

      *Exact File Attributes*

      DOS does not make an exact comparison with a designated attribute mask
      and attributes actually found in a file.  Specify only the SYSTEM,
      HIDDEN, VOLUME, or DIR attributes for an entry to be found.  Files with
      only one other attribute bit set are always returned, regardless of the
      value specified in the attribute mask.  This way, a function call with a
      mask value of 16 returns not only subdirectories, but all files without
      a set attribute (e.g., all the ARCHIVE and R/O files).

      To avoid this, you can designate .T. as the third parameter.  The
      function itself also reviews the designated attribute mask with the
      actual file attributes, for an exact agreement.  Then, the designation
      of a 16 mask and .T., only returns subdirectories.

      *Internal Data Buffer*

      Every time you use FileSeek() all the data for a directory entry is
      saved to an internal buffer.  Individual information such as size, time,
      or date is easily accessible.  To do this, the FileTime(), FileDate(),
      etc., functions are called without parameters; otherwise, it requires
      another call to the disk, instead of taking the data from an internal
      buffer.

   $NOTES$
      ■  Use the recursive sample function SCANFILES() in the
         accompanying Tooldemo.prg file, to produce the most effective
         programs to work with entire directory structures.

      ■  Display the date and size of all files with the extension .TXT
         in a directory:

         cFile  :=  FileSeek("C:\TEXT\*.TXT")
         DO WHILE .NOT. Empty(cFile)
            ? FileSize()               // Size of file in buffer
            ? FileDate()               // Date of file in buffer
            cFile  :=  FileSeek()      // Search for next entry
         ENDDO

      ■  Display system files in the root directory.  Attribute: READ
         ONLY, HIDDEN, SYSTEM, ARCHIVE --> 39, although 6(2 + 4) will
         suffice as an attribute:

         cFile  :=  FileSeek("C:\*.*", 39)
         DO WHILE .NOT. Empty(cFile)
            ? cFile                    // File name
            cFile := FileSeek()        // Look for next entry
         ENDDO

      ■  Only query the subdirectory:

         cSubDir := FileSeek("C:\*.*, 16, .T.)
         DO WHILE .NOT. Empty(cSubDir)
            ? cSubDir                  // Name of the directory
            cSubDir := FileSeek()      // Search for next directory
         ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileAttr(), FileDate(), FileSize(), FileTime()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileSize()
   $ONELINER$
      Determines the size of a file
   $SYNTAX$
      FileSize([<cFileMap>, [<FileAttr>]]) --> nFileSize

   $ARGUMENTS$
      <cFileMap>  Designates the file name, path, and drive designation.

      <FileAttr>  Designates the file attribute that is explained in the
      table below.  The default value is 0.

      ()  If the function is called without parameters, it returns the file
      size from the current FileSeek() buffer.

   $RETURNS$
      FileSize() returns the designated file's size, the size from the
      FileSeek() buffer (when called without a parameter), or -1.

   $DESCRIPTION$
      Implement FileSize() alone or in conjunction with FileSeek().  If the
      function is called with the <cFileMap> parameter, it returns the size of
      the first entry found.  If no matching entry is available, then a value
      of -1  is returned

      When called without parameters, FileSize() returns the size of the most
      recent file found with FileSeek().  Used in conjunction with FileSeek(),
      you can also determine the size of file groups (wildcards).

      You can designate the attribute for the desired file in numeric form:

      Table 7-16:  Coding the File Attribute
      <table>
          Value   Symb. constants     Assigned attribute

          0       FA_NORMAL
          1       FA_READONLY         READ ONLY (Read-only)
          2       FA_HIDDEN           HIDDEN (Hidden files)
          4       FA_SYSTEM           SYSTEM (System files)
          32      FA_ARCHIVE          ARCHIVE (Changes since last backup.)
         </table>

      Specify only the SYSTEM, HIDDEN, VOLUME, or DIR attributes for an entry
      to be found.  If multiple attributes are implemented simul-taneously,
      the table values are added accordingly.  Of course, not all combinations
      are useful.

   $EXAMPLES$
      ■  Show the size of a particular file:

         ? FileSize("C:\TEXT\TEXT.TXT")      // File size or -1

      ■  The size of an ARCHIVE/HIDDEN file:

         ? FileSize("C:\HIDE.TXT", 34")      // File size or -1

      ■  Used in conjunction with FileSeek():

         cFile  :=  FileSeek(C:\TEXT.TXT")
         DO WHILE .NOT. Empty(cFile)
            ? cFile, FileSize()              // File name and size
            cFile  := FileSeek()             // Search for next entry
         ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSeek(), FileAttr(), FileDate(), FileTime()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileStr()
   $ONELINER$
      Reads a portion of a file into a string
   $SYNTAX$
      FileStr(<cFile>, [<nLength>], [<nOffset>],
         [<lCtrl-Z>]) --> cCharacterstring

   $ARGUMENTS$
      <cFile>  Designates the file from which a string is read.

      <nLength>  Designates how many characters you want to read from a
      file (up to a maximum of 65520 bytes).  The default is read all
      characters.

      <nOffset>  Designates an offset within the file from which the
      <nLength> characters or the rest of the file, are read.  The default is
      from the first character (0).

      <lCtrl-Z>  If this parameter is designated as .T., only data up to
      the first Ctrl-Z is read in.  The default is read all data (.F.).

   $RETURNS$
      FileStr() returns the string read in from the designated file.

   $DESCRIPTION$
      FileStr() also offers the capability to read files or a portion of them,
      into a string.  This is only possible with a function call, where the
      file name may contain a drive and path designation.  If you implement
      the <lCtrl-Z> parameter, you can be sure the function only reads data up
      to the first Ctrl-Z and ignores whatever might remains in of the file.

      In contrast to the CA-Clipper Fxxxx() functions, a disadvantage of
      FileStr() is a slower access speed, since the file you want to read
      cannot be held open.

   $NOTES$
      ■  This function reads all available bytes in working memory (up
         to 65520).  The amount of available free memory is determined by
         calling Memory(1).

      ■  As recommended in share mode, no other programs should write
         in the net through SETSHARE(2) for the duration of the read.

   $EXAMPLES$
      ■  Read in a file completely:

         ? FileStr("C:\TEXT\TEST.TXT")            // Displays file text

      ■  Read in everything to the first Ctrl-Z:

         cVar  := FileStr("C:\TEXT\TEST.TXT", .T.)

      ■  The file TEST.TXT contains "ABCDEFGHIJ".  Four characters,
         beginning from position 3, are to be read:

         ? FileStr("C:\TEXT\TEST.TXT", 4, 3)      // "CDEF"

      ■  Read the maximum that fits into the available working memory:

         cVar  := FileStr("C:\TEXT\TEST.TXT", Memory(1) *1024 -100)

   $PLATFORMS$
      DOS
   $SEEALSO$
      StrFile(), SETSHARE(), AlloFree()*
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileTime()
   $ONELINER$
      Determines a file's time
   $SYNTAX$
      FileTime([<cFileMap>, [<nFileAttr>]]) --> cFileClockTime

   $ARGUMENTS$
      <cFileMap>  Designates the file name, including the path and drive
      designation.

      <nFileAttr>  Designates the file attribute explained in the table
      below.  The default value is 0.

      ()  If the function is called without parameters, it returns the file
      time from the current FileSeek() buffer.

   $RETURNS$
      FileTime() returns the clock time for the "searched for" entry, the
      clock time from the FileSeek() buffer (when called without parameters),
      or a null string.

   $DESCRIPTION$
      Implement FileTime() alone or  in conjunction with FileSeek().  If the
      function is called with the <cFileMap> parameter, it returns the time of
      the first entry found.  If no matching entry is available, a null string
      is returned.

      When called without parameters, FileTime() returns the clock time of the
      last file found with FileSeek().  You can also determine the clock time
      of file groups (wildcards) when the function is used in conjunction with
      FileSeek().

      You can designate the attribute for the desired file in numeric form:

      Table 7-17:  Coding the File Attribute
      <table>
          Value   Symb. constants     Assigned attribute

          0       FA_NORMAL
          1       FA_READONLY         READ ONLY (Read-only)
          2       FA_HIDDEN           HIDDEN (Hidden files)
          4       FA_SYSTEM           SYSTEM (System files)
          16      FA_DIRECTORY        (Subdirectory)
          32      FA_ARCHIVE          ARCHIVE (Changes since last backup)
         </table>

      Only the SYSTEM, HIDDEN, VOLUME, or DIR attributes must be specified for
      an entry to be found.  If multiple attributes are implemented
      simultaneously, the table values are added accordingly.  Of course, not
      all combinations are useful.

   $EXAMPLES$
      ■  The clock time of a particular file:

         ? FileTime("C:\TEXT\TEXT.TXT")      // File clock time or ""

      ■  The clock time of an ARCHIVE/HIDDEN file:

         ? FileTime("C:\HIDE.TXT", 34")      // File clock time or ""

      ■  Used in conjunction with FileSeek():

         cFile  :=  FileSeek(C:\TEXT.TXT")
         DO WHILE .NOT. Empty(cFile)
            ? cFile, FileTime()              // File name and clock time
            cFile  := FileSeek()             // Search for next entry
         ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSeek(), FileAttr(), FileDate(), FileSize()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FILEVALID()
   $ONELINER$
      Tests whether a string has a valid file name
   $SYNTAX$
      FILEVALID(<cFileName>) --> lValid

   $ARGUMENTS$
      <cFileName>  Designates the file name you want to test for validity.

   $RETURNS$
      FILEVALID() returns .T. when the designated name is valid.

   $DESCRIPTION$
      FILEVALID() determines if a string contains a valid file name.  You
      could also test the validity of user input in this way.  If necessary,
      path and drive designations must be removed from the string.  The
      tokenizer described in the string chapter is available for this purpose
      (see Examples).

   $EXAMPLES$
      The last token in a string with drive and path designations should
      contain the file name:

      ACCEPT "Target_File  " TO cVar
      cFileName  := TOKEN(cVar, " \:")        // Last token
      DO WHILE .NOT. FILEVALID(cFileName)
         * Error message ...
         ACCEPT "Target_File  " TO cVar
         cFileName  := TOKEN(cVar, "\:")      // Last token
      ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      TOKEN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FLOPPYTYPE()
   $ONELINER$
      Determines the exact type of floppy drive
   $SYNTAX$
      FLOPPYTYPE([<cDrive>]) --> nFloppyType

   $ARGUMENTS$
      <cDrive>  Designates the drive (A, B, C, etc.) for which you want a
      type determined.  The default is the current disk drive.

   $RETURNS$
      The function returns the exact type of the designated disk drive, coded
      as follows:

      Table 7-18:  Coding of Drive Types
      <table>
          Code    Definition

           0      No floppy drive
           1      360-kB drive
           2      1.2-MB drive
           3      720-kB drive
           4      1.44-MB drive
         </table>

   $DESCRIPTION$
      This function gives you a numeric value that specifies exact type and
      capacity of the selected floppy drive.  Whether or not the device is a
      floppy drive, is determined beforehand by DriveType().

   $NOTES$
      ■  The drive type is determined without actually accessing the
         drive. Therefore, a disk does not have to be in the drive.

   $EXAMPLES$
      Is the current disk drive a floppy and what type?

      IF DriveType() = 1 .OR. DriveType() = 2
         DO CASE
         CASE FLOPPYTYPE() = 0
         ? "No floppy drive!"
         CASE FLOPPYTYPE() = 1
         ? "360 kB drive"
         CASE FLOPPYTYPE() = 2
         ? "1.2 MB drive"
         CASE FLOPPYTYPE() = 3
         ? "720 kB drive"
         CASE FLOPPYTYPE() = 4
         ? "1.44 MB drive"
         ENDCASE
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DISKTYPE(), DriveType()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETSHARE()
   $ONELINER$
      Determines the file open (share) mode
   $SYNTAX$
      GETSHARE() --> nShareMode

   $RETURNS$
      GETSHARE() returns the current share mode setting as a value between 0
      and 4.

   $DESCRIPTION$
      GETSHARE() determines the current share mode set with SETSHARE().  The
      coding that is used is described in this function.

   $EXAMPLES$
      The current share mode:

      IF GETSHARE() == 4
         ? "Reading and writing permitted for other programs !"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETSHARE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NUMDISKF()
   $ONELINER$
      Determines the number of installed disk drives
   $SYNTAX$
      NUMDISKF() --> nTotalFloppy

   $RETURNS$
      NUMDISKF() returns a value that specifies how many disk drives are
      installed in the system.

   $DESCRIPTION$
      NUMDISKF() determines the number of disk drives and allows you to choose
      which drive you want to copy onto.

   $EXAMPLES$
      Determine if a B: drive exists:

      IF NUMDISKF() == 2
         IF DISKREADY("B")
            ? "You can also use Drive B:!"
         ENDIF
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumDiskL(), NUMDISKH()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NUMDISKH()
   $ONELINER$
      Determines the number of hard disks
   $SYNTAX$
      NUMDISKH() --> nNumber

   $RETURNS$
      NUMDISKH() returns the number of physical hard disk drives.

   $DESCRIPTION$
      This function determines the number of physical hard disk drives (one or
      two).  These should not be confused with logical hard disk drives, that
      can be designated with DOS 3.3.

   $NOTES$
      ■  The function receives its information from the BIOS.

   $EXAMPLES$
      ■  How many hard disk drives does my system have?

         ? NUMDISKH()         // Result:  1

   $PLATFORMS$
      DOS
   $SEEALSO$
      NUMDISKF(), NumDiskL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NumDiskL()
   $ONELINER$
      Determines the number of available logical drives
   $SYNTAX$
      NumDiskL() --> nNumber

   $RETURNS$
      The returned value gives the number of logical drives used by DOS.

   $DESCRIPTION$
      NumDiskL() returns the number of available drives or the value specified
      by LASTDRIVE = in CONFIG.SYS.  In a NOVELL network, you can determine
      which is the first network drive (LASTDRIVE +1).

   $NOTES$
      ■  Normally, the function return value is 5, if there is no
         deviating input in CONFIG.SYS for LASTDRIVE =.

   $EXAMPLES$
      Display which drive is the first network drive:

      ? "First Network Drive:  " + Chr(NumDiskL() + 65) + ":"

   $PLATFORMS$
      DOS
   $SEEALSO$
      NUMDISKF(), NUMDISKH()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RenameFile()
   $ONELINER$
      Fault tolerant renaming of a file.
   $SYNTAX$
      RenameFile(<cOldFileName>, <cNewFileName>) --> nErrorCode

   $ARGUMENTS$
      <cOldFileName>   Designates the name and path of the existing file.

      <cNewFileName>   Designates the new name and path for the file.

   $RETURNS$
      The function returns a 0 when the file can be renamed; otherwise, it
      returns an error code.  The codes are defined below:

      Table 7-19:  RenameFile() Error Codes
      <table>
          Code    Definition

           0      No error found
          -2      File not found
          -3      Path not found
          -5      Access denied (e.g., in network)
          -17     Target file not on same network
         </table>

   $DESCRIPTION$
      Currently, you may not be able to rename a file on a network drive.
      Another user may currently have the file open.  RenameFile() actually
      says "attempt a RENAME and, should the situation arise, return an error
      code".  This follows the basic programming philosophy:  never fall into
      an error trap when you can avoid it.

   $NOTES$
      ■  The <cNewFileName> must always contain the complete path for
         the designated file (see Examples).

      ■  Wildcard characters cannot be used.

   $EXAMPLES$
      ■  Rename a file from OLD to NEW:

         IF RenameFile("OLD", "NEW") = 0
            ? "The file can be renamed!"
         ENDIF

      ■  Use the path from the old file specification for the new name:

         cFSpecOld   := "C:\TEST\TEST.TXT"
         cFileName   := TOKEN(cFSpecOld, ":\")      // last token
         cFSpecNew   := BEFOREATNUM(cFileName, cFSpecOld) + "TEST.NEW"
         RenameFile(cFSpecOld, cFSpecNew)

   $PLATFORMS$
      DOS
   $SEEALSO$
      DeleteFile()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RESTFSEEK()
   $ONELINER$
      Restores the FILESEEK environment
   $SYNTAX$
      RESTFSEEK(<cFileSeekEnvironment>) --> cNull

   $ARGUMENTS$
      <cFileSeekEnvironment>  Designates a string that contains the
      FileSeek() environment, which was passed by SAVEFSEEK().

   $RETURNS$
      RESTFSEEK() always returns a null string.

   $DESCRIPTION$
      RESTFSEEK() restores a saved FileSeek() environment.  Use both of these
      functions to run through subdirectories recursively.

   $EXAMPLES$
      The following small program shows all the files in all directories of
      the current drive, from the root.  The GETFILES procedure can be called
      recursively:

      DO GetFiles WITH "\"                  // Starts with root directory
      RETURN

      * ----------------------------------------
      PROCEDURE GetFiles(cSearchPath)
      PRIVATE cSeekEnv                      // Picks up SEEK environment
         ?                                  // Empty line for new dir.
      * All files, all attributes
      cFile  := FileSeek(cSearchPath + "*.*", 63)

      DO WHILE .NOT. Empty(cFile)

         IF cFile <> "."                    // ".." and "." are dummys
            IF IsBit(FileAttr(), 5)         // Subdirectory?
               cSeekEnv := SAVEFSEEK()      // Save environment
               * Recursive call with extended path!
               DO GetFiles WITH cSearchPath + cFile + "\"
               RESTFSEEK(cSeekEnv)          // Restore environment
            ELSE
               ? cSearchPath + cFile
            ENDIF
         ENDIF
         cFile := FileSeek()                // Next file
      ENDDO

      RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSeek(), SAVEFSEEK()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SAVEFSEEK()
   $ONELINER$
      Saves the current FILESEEK environment
   $SYNTAX$
      SAVEFSEEK() --> cFileSeekEnvironment

   $RETURNS$
      SAVESEEK() returns the current FileSeek() environment.  The information
      is needed for RESTFSEEK().

   $DESCRIPTION$
      The function saves the current FileSeek() environment to a string.  For
      example, if the sequence "First Search - Continued Search" is
      interrupted by branching into a subdirectory, you must save these files.

   $NOTES$
      ■  Be sure sufficient spare memory is available when working
         recursively at a higher level of complexity (which depends on the
         number of subdirectories).  See Examples on the following page.

   $EXAMPLES$
      The following small program shows all the files in all directories of
      the current drive, from the root.  The GetFiles procedure can be called
      recursively:

      DO GetFiles WITH "\"              // Starts with root directory
      RETURN
      * ----------------------------------------
      PROCEDURE GetFiles(cSearchPath)
      PRIVATE cSeekEnv                  // Picks up SEEK environment
      ?                                 // Empty line for new dir.
      * All files, all attributes
      cFile  := FileSeek(cSearchPath + "*.*", 63)
      DO WHILE .NOT. Empty(cFile)
         IF cFile <> "."                // ".." and "." are dummys
            IF IsBit(FileAttr(), 5)     // Subdirectory?
            cSeekEnv := SAVEFSEEK()     // Save environment
            * Recursive call with extended path!
            DO GetFiles WITH cSearchPath + cFile + "\"
            RESTFSEEK(cSeekEnv)         // Restore environment
            ELSE
            ? cSearchPath + cFile
            ENDIF
         ENDIF
         cFile := FileSeek()            // Next file
      ENDDO
      RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      RESTFSEEK()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetFAttr()
   $ONELINER$
      Sets a file's attributes
   $SYNTAX$
      SetFAttr(<cFile>, <nFileAttr>) --> nErrorCode

   $ARGUMENTS$
      <cFile>  Designates the file that has attributes you want to change.
      Drive and path designations are allowed, but no wildcards.

      <nFileAttr>  Designates the new attributes in numeric form.  The
      default is 32 (ARCHIVE).

   $RETURNS$
      SetFAttr() returns the attribute implemented to the designated file or a
      negative value as an error code.  The codes are explained below:

      Table 7-20:  SetFAttr() Error Codes
      <table>
          Code    Symb. constants     Definition

           0      NO_DISK_ERR         No error found
          -2      ER_FILE_NOT_FOUND   File not found
          -3      ER_PATH_NOT_FOUND   Path not found
          -5      ER_ACCESS_DENIED    Access denied (e.g., in network)
         </table>

   $DESCRIPTION$
      This function permits you to change a file attribute.  The attributes
      are represented as a numeric value and explained in the table below:

      Table 7-21:  Coding the File Attribute
      <table>
          Value   Symb. constants     Assigned attribute

          0       FA_NORMAL
          1       FA_READONLY         READ ONLY (Read-only)
          2       FA_HIDDEN           HIDDEN (Hidden files)
          4       FA_SYSTEM           SYSTEM (System files)
          32      FA_ARCHIVE          ARCHIVE (Changes since last backup)
         </table>

      If you implement multiple attributes for a file, you must also add the
      individual values.

   $NOTES$
      ■  Use the Volume() function to create volume labels and
         directories through the DirMake() function.  Additional attributes
         can also be set at directory level.

      ■  The BitToC() and CToBit() functions can prove helpful in
         conjunction with the file attributes.

      ■  An attempt to set (.AND...) attributes at pseudo files can
         trigger a system crash.

   $EXAMPLES$
      ■  Set a file to HIDDEN:

         ? SetFAttr("TEST.TXT", 2)       // Returns 0, if successful

      ■  When a file is not available:

         ? SetFAttr("ABCDEFGH"), 2)      // Returns: -2

      ■  Influence the return value:

         nAttribute  := SetFAttr("TEST.TXT", 7)
         IF nAttribute <> 7
            *...
         ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSeek(), FileAttr(), BitToC(), CToBit()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetFCreate()
   $ONELINER$
      Default attribute for creating with CA-Clipper Tools functions
   $SYNTAX$
      SetFCreate([<nNewFileAttr>]) --> nOldFileAttr

   $ARGUMENTS$
      <nNewFileAttr>  Designates a file attribute for a new file.

   $RETURNS$
      SetFCreate() returns the current default attribute or the previous file
      attribute, if the parameter is specified.

   $DESCRIPTION$
      CA-Clipper Tools functions use a value of 32 (setting the ARCHIVE bit)
      to preset the default for file creation.  For example, use SetFCreate()
      when a file needs to acquire another attribute in a network environment.

      Table 7-22:  Coding the File Attribute
      <table>
          Value   Symb. constants     Assigned attribute

          0       FA_NORMAL
          1       FA_READONLY         READ ONLY (Read-only)
          2       FA_HIDDEN           HIDDEN (Hidden files)
          4       FA_SYSTEM           SYSTEM (System files)
          32      FA_ARCHIVE          ARCHIVE (Changes since last backup)
         </table>

   $NOTES$
      ■  The set values only apply to files you create with CA-Clipper
         Tools functions.

   $EXAMPLES$
      ■  Create a read-only file:

         SetFCreate(1)
         StrFile("Nantucket", "TEST.TXT")

      ■  Query the attribute set:

         ? SetFCreate()

   $PLATFORMS$
      DOS
   $SEEALSO$
      StrFile(), FileCopy(), FileCCont(), FileAppend()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetFDaTi()
   $ONELINER$
      Sets the date and time of a file
   $SYNTAX$
      SetFDaTi(<cFile>, [<dFileDate>], [<cFileTime>]) --> lAmended

   $ARGUMENTS$
      <cFile>  Designates for which file the date and/or time is changed.
      Drive and path designations are possible, wildcards are not.

      <dFileDate>  Designates the date for the file.  The default is the
      system date.

      <cFileTime>  Designates the time for the file.  The default is the
      system time.

   $RETURNS$
      SetFDaTi() returns .T. when the change is successfully executed.

   $DESCRIPTION$
      SetFDaTi() permits you to set the clock date and time of a file.  Since
      the date and time of a file usually change at the same time, these have
      been brought together in one function.  It is possible to only change
      the time or the date, when one parameter is given and the other is not.
      The different parameter types tell the function what is to change.

   $NOTES$
      ■  The time is given in a 24-hour format, that is between
         "00:00:00" and "23:59:59".

   $EXAMPLES$
      ■  Set the date and time:

         SetFDaTi("C:\TEXT\TEST.TXT", CToD("01/01/91"), "01:10:00")

      ■  Set current date and time:

         SetFDaTi("TEST.TXT")                  // Date() + Time()

      ■  Only change the date:

         SetFDaTi("TEST.TXT", Date() -10)      // Ten days prior to today

      ■  Only change the time, resetting to start time:

         SetFDaTi("TEST.TXT", SecToTime(Start))

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSeek(), FileDate(), FileTime(), SecToTime()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETSHARE()
   $ONELINER$
      Sets the default opening mode (share mode) for CA-Clipper Tools file functions
   $SYNTAX$
      SETSHARE(<nShareMode>) --> lAccepted

   $ARGUMENTS$
      <nShareMode>  Designates the desired share mode.

   $RETURNS$
      SETSHARE() returns .T. when the desired share mode is implemented (must
      be DOS version - 3.1 or higher).

   $DESCRIPTION$
      The setting you implement here influences all CA-Clipper Tools functions
      that open, read, or write to a file.  The share mode can be set here.
      It determines when a program opens a file under DOS and how other
      programs within a network may address this file.  The CA-Clipper Tools
      default is 0, compatibility mode.  The following codes apply:

      Table 7-23: Share Mode Coding
      <table>
          Code    Share Mode

          0       Compatibility mode.  Here DOS or the network software itself
                  determines the share mode.  In Novell networks, the SHAREABLE
                  attribute plays an important role in this relationship.
          1       Both read and write by other programs are locked out.
          2       Write by other programs are locked out.
          3       Read by other programs are locked out.
          4       Not locked.  Read and write by other programs is allowed
         </table>

   $NOTES$
      Important!  This function can only be used with DOS versions 3.1 or
      higher.  Older versions return .F..

   $EXAMPLES$
      ■  Change share mode, prohibit writing by others:

         ? SETSHARE(2)          // .T., when >= DOS 3.1

      ■  Bad parameter:

         ? SETSHARE(12)         // .F.

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETSHARE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      StrFile()
   $ONELINER$
      Writes a string to a file
   $SYNTAX$
      StrFile(<cCharacterstring>, <cFile>, [<lOverwrite>],
         [<nOffset>], [<lCutOff>]) --> nRecordedByte

   $ARGUMENTS$
      <cCharacterstring>  Designates the character string to write to a
      file.

      <cFile>  Designates a file name.  Drive and path designations are
      permitted, but no wildcards.

      <lOverwrite>  If not designated or designated as .F., determines
      whether or not a new file is created.  When .T., it writes to an
      existing file.  The default is create new file (.F.).

      <nOffset>  Designates an offset within the file from which the
      <cCharacterstring> string is to be written.  The default is End of file.

      <lCutOff>  When this optional parameter is designated as .T., the
      function truncates the file if data written ends before the last file
      byte.  The default is no cut off (.F.).

   $RETURNS$
      StrFile() returns the actual number of bytes written.

   $DESCRIPTION$
      This function provides another capability besides writing the contents
      of a string to a file.  In contrast to the CA-Clipper Fxxxx() functions,
      only one function call is necessary to write data to a file.  However,
      it can result in some speed disadvantages, since files acted on by
      StrFile() cannot be held open.

      If the target file is unavailable, the StrFile() function always creates
      it.

   $NOTES$
      ■  The attribute to create a new file, can be designated with the
         SetFCreate() function.

      ■  As recommended with the share mode, reads and writes from
         other network programs should be locked out with SETSHARE() for this
         period of time.

      ■  This function acknowledges the setting for CSetSafety().

   $EXAMPLES$
      ■  Add to the end of a file:

         ? StrFile("ABCDEFGH", "TEST.TXT", .T.)             // Result: 8

      ■  A file with drive and path designations, result: 10:

         ? StrFile("0123456789", "C:\TEXT\TEST.TXT", .T.)

      ■  Data in an existing file is overwritten from position 20 with
         a designated string:

         ? StrFile("NANTUCKET", "TEST.TXT", .T., 20)        // Result: 9

      ■  A 5-character string is written starting at position 10 in an
         existing file 20-characters long.  Since the final parameter is
         specified as .T. once, and specified as .F. once, you see different
         results:

         ? StrFile(Replicate("X", 20), "TEST.TXT")
         ? StrFile("AAAAA", "TEST.TXT", .T., 10, .F  // "XXXXXXXXXXAAAAAXXXXX"
         ? StrFile("AAAAA", "TEST.TXT", .T., 10, .T  // "XXXXXXXXXXAAAAA"

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileStr(), SETSHARE(), SetFCreate(), CSetSafety()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TempFile()
   $ONELINER$
      Creates a file for temporary use
   $SYNTAX$
      TempFile([<cDirectory>], [<cExtension>], [<nFileAttr>])
          --> cFileName

   $ARGUMENTS$
      <cDirectory>  Designates the drive and directory where the temporary
      file is to be created.  The default is the current drive/directory.

      <cExtension>  Designates the file extension for the file.  The
      default is no extension.

      <nFileAttr> Designates a file attribute for the file.  The default
      is the SetFCreate() setting.

   $RETURNS$
      Returns the name of the temporary file.  If no file is created, the
      function returns a null string.

   $DESCRIPTION$
      If you only need a file for a short time and want to avoid conflicts
      with existing files, use TempFile() to create a file with a unique name.
      Names created by TempFile() use the system date and system time.  You
      can hide the file, if you specify an attribute.  Attributes are coded as
      follows:

      Table 7-24:  File Attribute Coding
      <table>
          Value   Symb. constants     Definition

          0       FA_NORMAL
          1       FA_READONLY         READ ONLY
          2       FA_HIDDEN           HIDDEN (Hidden files)
          4       FA_SYSTEM           SYSTEM (System files)
          32      FA_ARCHIVE          ARCHIVE (Changed since last backup)
         </table>

   $NOTES$
      ■  The temporary file name is always 8 characters long and
         consists exclusively of numbers with a period, if no extension has
         been specified.  The file is created with a length of 0 bytes.

      ■  A designated file attribute has precedence over a setting
         created with SetFCreate().

   $EXAMPLES$
      ■  Create a temporary file in the current drive and directory:

         cTempFile := TempFile()

      ■  Create a temporary file in the root directory of the E: drive:

         cTempFile := TempFile("E:\")

      ■  Create a temporary file with a .TMP extension and a HIDDEN
         attribute in the root directory of the A: drive:

         cTempFile := TempFile("A:\", "TMP", 2)

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetFAttr(), SetFCreate()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TrueName()
   $ONELINER$
      Standardizes the path designation
   $SYNTAX$
      TrueName(<cPathDesignation>) --> cStandardizedPath

   $ARGUMENTS$
      <cPathDesignation>  Designates a path as a standard.  It is assumed
      that it is in accordance with DOS rules.

   $RETURNS$
      TrueName() returns the standardized path whenever possible.

   $DESCRIPTION$
      Path designations are made for the drive as well as the path itself,
      with regard to the current position designation.  With TrueName(),
      related path designations are changed around so that they relate to the
      root directory of a particular drive.

      The function does not test to see if a path exists.  If the designated
      path is not valid or the specified drive is unavailable, it returns a
      null string.

   $NOTES$
      Warning!  Additional information is built into the path of network
      drives. Under PC-LAN/MS-NET, the path contains the
      designation:\\<ServerName>.  Under Novell, \\<ServerName>\ <VolumeName>
      (see Examples).

   $EXAMPLES$
      ■  Which complete path corresponds to the current disk drive?

         ? TrueName(".")                        // e.g. "C:\TEST1"

      ■  Anything valid under DOS is acceptable:

         ? TrueName("..\..\TEST1\.\TEST2")      // e.g. "C:\TEST1\TEST2"

      ■  In a Novell network, remove tokens 2 and 3, server name, and
         volume name:

         IF NNetwork()
            cPath   := TrueName(cOldPath)
            cToken1   := TOKEN(cPath, ":\", 1)
            cToken2   := TOKEN(cPath, ":\", 2)
            cToken3   := TOKEN(cPath, ":\", 3)
            cPath   := cToken1 + AfterAtNum(cToken2 + cToken3, cPath)
         ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      TOKEN(), AfterAtNum()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      VolSerial()
   $ONELINER$
      Determines the DOS disk serial number
   $SYNTAX$
      VolSerial([<cDrive>]) --> nVolSerial

   $ARGUMENTS$
      <cDrive>  Designates the drive whose volume serial number is
      queried.  The default is the current disk drive.

   $RETURNS$
      VolSerial() returns the volume serial number of the DOS  disk, hard
      disk, or a 0, when you are not dealing with a DOS 4.0 or higher disk
      (see Notes).  When the current drive is unavailable, it returns -1.

   $DESCRIPTION$
      VOLUME SERIAL NUMBER
      Beginning with DOS version 4.0, every floppy or hard disk receives a
      volume serial number during formatting.  This is a 32-bit number is
      created by DOS using the date, clock time, and a counter.

   $NOTES$
      ■  Incompatibilities are possible.

      ■  The function always returns a value from the disk parameter
         block of a floppy or hard disk.  Based on the Microsoft
         recommendation for DOS versions prior to 4.0, a value of 0 is
         returned.

   $EXAMPLES$
      Query the volume serial number:

      ? VolSerial()            // 0, when no DOS 4.x disk

   $PLATFORMS$
      DOS
   $SEEALSO$
      OSVER()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Volume()
   $ONELINER$
      Establishes a volume label for a floppy or hard disk
   $SYNTAX$
      Volume(<cDiskName>) --> lEstablished

   $ARGUMENTS$
      <cDiskName>  Designates a name to use on a new volume label.  A
      drive designation is allowed; path designation and wildcards are not.

   $RETURNS$
      Volume() returns .T. when the new volume entry is created.

   $DESCRIPTION$
      DOS provides a volume label as a disk identifier.  With the Volume()
      function you can establish this label.  There is never more than one
      label per floppy or hard disk.  A volume label can be up to 11
      characters long, but when you use a period (.) it must always follow the
      eighth character.

      You can query the volume label with FileSeek(), since the value 8 is
      assigned as the volume attribute.

   $NOTES$
      ■  A new volume label is always created in the root directory.

      ■  The function acknowledges the CSetSafety() setting and, if
         necessary, does not overwrite an existing label.

   $EXAMPLES$
      ■  Establish a volume label for A: drive:

      ■  Query the A: drive volume label:

         ? FileSeek("A:\*.*", 8)      // Based on example 1 "VOLO815"

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSeek()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Printer Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      This chapter discusses printer output.  Although CA-Clipper handles
      printer errors with an error trap, it is always better to avoid them
      completely.  As a result, error traps for printer output will not become
      superfluous, since errors also occur during output.  You can also
      determine a wide variety of information, such as the number of available
      printers or the printer status.

      This chapter also describes functions that support DOS print spoolers.
      To implement these functions, prior to starting the respective
      application, you must run the DOS PRINT program to make the print
      spooler memory resident.  Files can then be exclusively passed from a
      program to the spooler.  However, you must first reroute your print
      output to a file (SET PRINTER TO <file>), before you can output it in
      the background.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NUMPRINTER()
   $ONELINER$
      Returns the number of parallel ports
   $SYNTAX$
      NUMPRINTER() --> 1.04nNumber

   $RETURNS$
      NUMPRINTER() returns the number of parallel printer interfaces installed
      on the machine.

   $DESCRIPTION$
      Once you establish that multiple printer ports are installed, choose
      which printer wants to use (e.g., dot-matrix or laser printer).
      NUMPRINTER() also detects if a printer is not installed over the usual
      printer interface, because there is no port available.

   $NOTES$
      ■  This function cannot determine if a printer is connected and
         ready to operate.

   $EXAMPLES$
      Determine if a printer interface is available:

      ?  "There are " + Str(NUMPRINTER(), 2) + " Printer ports"
      ?? "available"

   $PLATFORMS$
      DOS
   $SEEALSO$
      PrintReady(), PrintINIT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PRINTFILE()
   $ONELINER$
      Prints out ASCII files; clears high bits
   $SYNTAX$
      PRINTFILE(<cFile>, [<lIgnoreHighBit>]) --> lSuccess

   $ARGUMENTS$
      <cFile> Designates the file name to print.

      <lIgnoreHighBit>  When designated as .T., the high bits are not
      cleared.  The default is clears high bits (.F.).

   $RETURNS$
      The returned value specifies if a file is successfully printed.  A .T.
      corresponds to a successful execution.

   $DESCRIPTION$
      PRINTFILE() sends the <cFile>ASCII file to the printer while it clears
      each high bit that is set (MSB -- Most Significant Bit) with each
      carriage return and line feed.  This allows files created with
      MEMOWRITE() to print without any special preparation.  If you do not
      want to suppress the high bit (e.g., when printing a character such as
      <130>, designate the second parameter as .T. to turn it off).

   $NOTES$
      ■  Due to known name conflicts with other add on libraries (e.g.,
         dGE, use the name FILEPRINT()on an alternate basis.

      ■  The settings for SET PRINTER TO and other printer-related
         functions such as  SETPXLAT() are acknowledged.

   $EXAMPLES$
      ■  Print the Memofile.txt file:

         PRINTFILE("Memofile.txt")

      ■  Use the function name FILEPRINT() on an alternate basis:

         FILEPRINT("Memofile.txt")

      ■  Without high-bit suppression:

         FILEPRINT("Memofile.txt", .T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      PrintReady(), SETSHARE(), SETPXLAT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PrintINIT()
   $ONELINER$
      Initializes one of the printers
   $SYNTAX$
      PrintINIT([<nPrinter>, [<lMode>]]) --> nStatus

   $ARGUMENTS$
      <nPrinter>  Designates the number the printer to initialize.  Values
      can be from 1 to 3 and correspond to the devices LPT1 to LPT3.  The
      default value is LPT1(1).

      <lMode>  When designated as .T., CA-Clipper is set internally to the
      top of form.  The default for CA-Clipper is not at the top of form
      (.F.).

   $RETURNS$
      The returned value corresponds to the status of the <nPrinter> selected
      printer.  The individual bits are defined as follows:

      Table 8-1:  Printer Bit Status
      <table>
          Bit     Definition

          1       Timeout error
          2       Not used
          3       Not used
          4       Transmission error
          5       Printer online
          6       Out of paper
          7       Printer acknowledged
          8       Printer not available
         </table>

   $DESCRIPTION$
      Use PrintINIT() to reset a printer to its original state or to redefine
      the top of form.  When <lMode> is designated as .T., the CA-Clipper
      internal setting is top of form.  This corresponds to a call of SETPRC
      (0, 0).

   $EXAMPLES$
      Reset output to LPT1:

      PrintINIT(1)

   $PLATFORMS$
      DOS
   $SEEALSO$
      PrintStat(), TOF()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PrintReady()
   $ONELINER$
      Determines if a particular printer is ready
   $SYNTAX$
      PrintReady([<nPrinter>]) --> lReady

   $ARGUMENTS$
      <nPrinter>  Designates which LPT device to test.  A 1 corresponds to
      LPT1, 2 is LPT2, and a 3 is LPT3.  The default is LPT1(1).

   $RETURNS$
      PrintReady() returns a value of .T. when the printer is ready.  In any
      other case, PrintReady() returns .F..

   $DESCRIPTION$
      This function tests whether the printer is ready before you attempt to
      print.  This could help you avoid printer errors.

   $EXAMPLES$
      In the following example, printing only occurs when the printer is
      ready:

      IF PrintReady(1)
         *...               // Print
      ELSE
         *...               // Error message
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      NUMPRINTER(), PrintINIT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PRINTSCR()
   $ONELINER$
      Prints screen contents
   $SYNTAX$
      PRINTSCR() --> cNull

   $RETURNS$
      PRINTSCR() always returns a null string.

   $DESCRIPTION$
      A call to PRINTSCR() has the same effect as when you press the PRINT
      SCREEN key.

   $NOTES$
      ■  Due to known name conflicts with other add on libraries (e.g.,
         dGE, use the name PRTSCREEN() as an alternate.

      ■  The Print Screen output, whether executed by this function or
         manually, may be further influenced by PRINTSCRX().

   $EXAMPLES$
      Print screen contents:

      PRINTSCR()

   $PLATFORMS$
      DOS
   $SEEALSO$
      PRINTSCRX()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PRINTSCRX()
   $ONELINER$
      Prints screen contents while it exchanges specific characters
   $SYNTAX$
      PRINTSCRX([<nPrinter>, [<cCharacter|nCharacter>]])
          --> lInstalled

   $ARGUMENTS$
      <nPrinter>  Designates the number of the printer where output is
      directed.  LPT(1) to LPT(3) are possible.

      <cCharacter|nCharacter>  Designates a character that replaces all
      non-printable characters during a "'Print-Screen".  The character can be
      numeric in the range of 0 to 255 or the character string type.

      ()  A call without parameters uninstalls the function.

   $RETURNS$
      PRINTSCRX() returns .T. when the extended Print Screen output is
      successfully installed.

   $DESCRIPTION$
      The PRINTSCRX() replaces the non-printable characters (code <32) in an
      output with other characters, but you can also select another printer.
      This way, Print Screen output is no longer forced to LPT1(PRN).  Not
      only does it influence PRINTSCR(), but also the use of SHIFT-PRINT-
      SCREEN.

   $NOTES$
      Warning!  The PRINTSCRX() function changes one of the system
      interrupts.  Therefore, prior to ending the program, uninstall this
      function by calling it without parameters.  You can use the CTUS.LIB
      Extended Drivers or the INTSAVE utility program.  The Extended Drivers
      automatically restores all interrupts to the same status they had at the
      beginning of the CA-Clipper application.

   $EXAMPLES$
      ■  Print-Screen output to LPT3:

         PRINTSCRX(3)

      ■  Exchange non-printing characters for spaces.  Output to LPT2:

         PRINTSCRX(2, " ")

      ■  Same as on previous page, second parameter numeric:

         PRINTSCRX(2, 32)

   $PLATFORMS$
      DOS
   $SEEALSO$
      PRINTSCR(), Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PrintSend()
   $ONELINER$
      Sends characters directly to a printer
   $SYNTAX$
      PrintSend(<cCharacter|nCharacter>, <nPrinter>)
         --> nNumber

   $ARGUMENTS$
      <cCharacter|nCharacter>  Designates as a code for an individual
      character in the range of 0 to 255, or as a string.

      <nPrinter>  Designates the printer where output occurs.  The values
      1 to 3 correspond to devices LPT1 to LPT3.

   $RETURNS$
      PrintSend() returns a value that corresponds to the number of characters
      that could not be sent to the printer.  If 0 is returned, all characters
      were sent to the printer.

   $DESCRIPTION$
      Use PrintSend() when you want to send one or more characters to a
      printer, and switching from SET PRINTER and SET CONSOLE is undesirable
      and costly as an option.  This function allows you to send characters
      (and special characters) to a printer at any time.

   $EXAMPLES$
      ■  Send formfeed characters to the printer, when the printer is
         not at top of form:

         IF .NOT. TOF()
            PrintSend(12)         //  Output Chr(12)
         ENDIF

      ■  Send a character string:

         PrintSend("Hello")

   $PLATFORMS$
      DOS
   $SEEALSO$
      TOF(), PRINTFILE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PrintStat()
   $ONELINER$
      Determines the status of a parallel port
   $SYNTAX$
      PrintStat([<nPrinter>]) --> nStatus

   $ARGUMENTS$
      <nPrinter>  Designates the printer whose status is determined.  The
      allowed values of 1 to 3 correspond to devices LPT1 to LPT3.  The
      default is LPT1(1).

   $RETURNS$
      The returned value corresponds to the status of the <nPrinter> selected
      printer.  The individual bits are defined as follows:

      Table 8-2:  Printer Bit Status
      <table>
          Bit     Definition

          1       Time out error
          2       Not used
          3       Not used
          4       Transmission error
          5       Printer online
          6       Out of paper
          7       Printer acknowledged
          8       Printer not available
         </table>

   $DESCRIPTION$
      If a printer error occurs, PrintStat() allows you to isolate the error
      more precisely.  PrintStat() returns information about why an error
      occurs.

   $EXAMPLES$
      In this example, the printer status is only queried when the printer is
      not ready:

      IF .NOT. PrintReady(1)
         nStatus  :=  PrintStat(1)
         IF IsBit(nStatus, 6)         //  Test bit 6
         ? "Paper out!"
         ENDIF
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      PrintReady(), PrintINIT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPOOLACTIV()
   $ONELINER$
      Determines if the DOS PRINT program is installed
   $SYNTAX$
      SPOOLACTIV() --> lSpoolActive

   $RETURNS$
      SPOOLACTIV() returns .T. when the DOS memory-resident print spooler is
      installed.

   $DESCRIPTION$
      Before you implement any print spool functions, use SPOOLACTIV() to test
      if the DOS PRINT program is installed.  If inactive, then you must leave
      the application because memory-resident programs cannot load from within
      CA-Clipper applications.

   $NOTES$
      ■  Use SPOOLACTIV() to continue output stopped with SPOOLENTRY().

   $EXAMPLES$
      Test if PRINT is loaded:

      IF SPOOLACTIVE()
         SPOOLADD("C:\TEST\PRINT.DAT")
      ELSE
         ? "Spooling not possible !"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPOOLADD()
   $ONELINER$
      Appends a file to the print queue.
   $SYNTAX$
      SPOOLADD(<nFile>) --> lAppended

   $ARGUMENTS$
      <nFile>  Designates a file to add to the print spool queue.

   $RETURNS$
      SPOOLADD() returns .T. when the file is successfully added to the spool
      queue.

   $DESCRIPTION$
      SPOOLLADD() passes a new file to the spooler where data is printed in
      the background.  If no data can be added because the file does not exist
      or because the queue is full, the function returns to .F..

   $EXAMPLES$
      Print to a file, then print it in the background:

      SET PRINTER TO C:\TEST\PRINT.DAT         // Redirect print
      SET DEVICE TO PRINT                      // Print Output
      @....SAY....
      @....SAY....
      SET DEVICE TO SCREEN
      SET PRINTER TO                           // Close output file

      IF SPOOLACTIV()
         SPOOLADD("C:\TEST\PRINT.DAT")         // .T., if correct
      ELSE
         *'normal' print
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      SPOOLACTIV(), SPOOLDEL(), SPOOLFLUSH(), SPOOLCOUNT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPOOLCOUNT()
   $ONELINER$
      Determines the number of entries in the print spool queue
   $DESCRIPTION$
      The function allows you to determines the number of entries in the print
      spool queue.  This value can be useful in a loop in conjunction with
      SPOOLENTRY().  A file currently being printed is not counted.

   $NOTES$
      ■  When using SPOOLENTRY() in conjunction with SPOOLCOUNT(),
         SPOOLENTRY() stops print output.

   $EXAMPLES$
      ■  Display entries (stops output):

         FOR I = 1 TO SPOOLCOUNT()
            ? SPOOLENTRY (I)                     // Path and file name
         NEXT I
         SPOOLACTIV()                            // Continue printing

      ■  Delete the next-to-last entry:

         ? SPOOLDEL(SPOOLENTRY9SPOOLCOUNT() -1   //.T., when done

   $PLATFORMS$
      DOS
   $SEEALSO$
      SPOOLENTRY(), SPOOLDEL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPOOLDEL()
   $ONELINER$
      Deletes files from the print queue
   $SYNTAX$
      SPOOLDEL (<cFile>) --> 1Deleted

   $ARGUMENTS$
      <cFile>  Designates which file to remove from the print spool queue.

   $RETURNS$
      SPOOLDEL() returns .T. when the designated file is successfully removed
      from the print spool queue.

   $DESCRIPTION$
      If the wrong file is put in the print spool queue, and is not yet
      printed, you can delete it from the internal list.  SPOOLCOUNT() and
      SPOOLENTRY() return information about files currently in the queue.

   $EXAMPLES$
      Delete all files with the extension .SYS form the print queue:

      FOR I = 1 TO SPOOLCOUNT
         cFile:=   SPOOLCOUNT(0)

         IF RIGHT (cFile)
         ENDIF
      NEXT I
      SPOOLACTIV()      // Continue

   $PLATFORMS$
      DOS
   $SEEALSO$
      SPOOLACTIV(), SPOOLCOUNT(), SPOOLENTRY(), SPOOLFLUSH()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPOOLENTRY()
   $ONELINER$
      Determines the name and path of a print job
   $SYNTAX$
      SPOOLENTRY([<nEntryNumber>]) --> cFileName

   $ARGUMENTS$
      <nEntryNumber>  Designates to which queue entry to return the file
      name. The default is the last entry.

   $RETURNS$
      SPOOLENTRY() returns the complete file specification for the designated
      queue entry or a null string for an invalid parameter.

   $DESCRIPTION$
      SPOOLENTRY() determines the file path and name for a particular entry in
      a print spool queue.  If the optional parameter is not specified, the
      function returns the last entry.  If no matching entry is available,
      then a null string is returned.

      Call SPOOLENTRY() to stop the current print output.  Call SPOOLACTIV()
      to continue the function.

   $EXAMPLES$
      ■  The last entry:

         ? SPOOLENTRY()                     // File name incl.path
         SPOOLACTIV()                       // Continue output

      ■  The next to last entry:

         ? SPOOLENTRY(SPOOLCOUNT() -1)      // "" if not available
         SPOOLACTIV()                       // Continue output

   $PLATFORMS$
      DOS
   $SEEALSO$
      SPOOLCOUNT(), SPOOLDEL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPOOLFLUSH()
   $ONELINER$
      Completely empty the print queue
   $SYNTAX$
      SPOOLFLUSH() --> lDeleteAll

   $RETURNS$
      SPOOLFLUSH() returns .T. when you can remove all entries.

   $DESCRIPTION$
      SPOOLFLUSH() allows you to remove all entries from the print spool
      queue.  An entry currently being printed, is not taken into account,
      (just as with SPOOLCOUNT()).

   $EXAMPLES$
      Delete the spool queue:

      IF SPOOLFLUSH()               // All deleted ?
         ? "Print spool queue is empty !"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      SPOOLCOUNT(), SPOOLENTRY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TOF()
   $ONELINER$
      Determines if CA-Clipper is at top of form (TOF)
   $SYNTAX$
      TOF() --> lTopOfForm

   $RETURNS$
      Returns the logical value .T. to designate if a printer is at TOF.

   $DESCRIPTION$
      TOF() determines if the printer should execute a formfeed or not.

   $NOTES$
      ■  TOF() acknowledges the values that CA-Clipper maintains
         internally. TOF() cannot determine if the printer is actually at
         TOF()

   $EXAMPLES$
      When the printer is not at top of form, execute an EJECT:

      IF .NOT. TOF()
         EJECT
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      PrintINIT(), PrintSend()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Date / Time Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      This section contains functions that make many date computations easier
      to perform.  Date-type values have been a feature of the xBASE language
      standard, and is preserved in CA-Clipper.  In spite of this, it is
      always necessary to develop UDFs to execute certain technical financial
      computations.  CA-Clipper Tools offers an alternative that not only
      spares you the work of writing a UDF, but also provides implementation
      in Assembler to guarantee fast execution.

      This chapter also contains clock time functions.  These include time
      changes, time span computations, time control of loops, and memory-
      resident clock display.

      Please note that valid date tests are already carried out in CA-Clipper.
      CA-Clipper internal date tests cannot be canceled, so it is impossible
      to implement an individual UDF for error handling , if there is an
      invalid date.

      CA-Clipper always replaces an invalid date with a null date.  These
      internal tests are carried out by keyboard input, as well as by CToD()
      allocation.  For this reason, there are no examples with invalid dates
      in the date function descriptions.  Rather, the result of a function
      with a null date is shown.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AddMonth()
   $ONELINER$
      Adds or subtracts months to/from a date
   $SYNTAX$
      AddMonth([<dDate>], [<nMonth>]) --> dNewDate

   $ARGUMENTS$
      <dDate>  Designates the date to which the <nMonth> months is added.
      The default is the system date.

      <nMonth>  Designates the number of months to add to <dDate>.

   $RETURNS$
      AddMonth() returns the new date after <nMonth> is added to <dDate>.

   $DESCRIPTION$
      Use this function to calculate payment due dates based on an invoice
      date and for similar applications.  It permits you to add months to a
      given date.  If you use a negative number, months are subtracted.

   $NOTES$
      ■  An empty date parameter will result in an empty date.

   $EXAMPLES$
      Show today's date, plus 36 months:

      ? "The payment period ends on: ", AddMonth(36)

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      BoM()
   $ONELINER$
      Determines the date of the first day of a month
   $SYNTAX$
      BoM([<dDate>]) --> dBeginningOfMonth

   $ARGUMENTS$
      <dDate>  Designates a date for which the first day of the month that
      contains this date, is determined.  The default is the system date.

   $RETURNS$
      BoM() returns the first day of the month in which <dDate> lies.

   $DESCRIPTION$
      BoM() allows you to determine the first day of the month that contains
      <dDate>.  This allows you to determine how many days have past since the
      beginning of the month.

   $NOTES$
      ■  If no date is passed, then the function automatically uses the
         system date.  An empty date parameter always returns an empty date.

   $EXAMPLES$
      Display the elapsed days in the current month:

      ? Date() - BoM()

   $PLATFORMS$
      DOS
   $SEEALSO$
      EoM(), BoQ(), EoQ(), BoY(), EoY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      BoQ()
   $ONELINER$
      Determines the date for the beginning of a quarter
   $SYNTAX$
      BoQ([<dDate>]) --> dBeginningOfQuarter

   $ARGUMENTS$
      <dDate>  Designates a date for which the first day of the quarter in
      which it lies is determined.  The default is the system date.

   $RETURNS$
      BoQ() returns the date at the beginning of the quarter that contains
      <dDate>.

   $DESCRIPTION$
      For example, use BoQ() to determine when the current quarter that
      contains <dDate> began, and then compute the number of days that have
      elapsed since the quarter began.

   $NOTES$
      ■  If you do not specify a date, the function automatically uses
         the system date.  An empty date parameter always returns an empty
         date.

   $EXAMPLES$
      Display the date of the first day of the current quarter:

      ? "The first day of the current quarter is:", BoQ()

   $PLATFORMS$
      DOS
   $SEEALSO$
      BoM(), EoM(), EoQ(), BoY(), EoY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      BoY()
   $ONELINER$
      Determines the date for the beginning of a year
   $SYNTAX$
      BoY([<dDate>]) --> dBeginningOfYear

   $ARGUMENTS$
      <dDate>  Designates the date for which the first day of the year is
      determined.  The default is the system date.

   $RETURNS$
      BoY() returns the first of January for the year that contains <dDate>.

   $DESCRIPTION$
      BoY() determines the year without having to create a date-type variable.

   $NOTES$
      ■  If no date is specified, the function automatically uses the
         system date.  An empty date parameter always returns an empty date.

   $EXAMPLES$
      The first date of the current year (1991):

      ? BoY()            // 01/01/91

   $PLATFORMS$
      DOS
   $SEEALSO$
      BoM(), EoM(), BoQ(), EoQ(), EoY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CToDoW()
   $ONELINER$
      Converts the name of the day of the week into a corresponding number
   $SYNTAX$
      CToDoW(<cDayofWeek>) --> nDayofWeek

   $ARGUMENTS$
      <cDayofWeek>  Designates a character string that contains the name
      of a day of the week.

   $RETURNS$
      CToDoW() returns the number of the day for the day name.

   $DESCRIPTION$
      Use CToDoW() to change the name of a day of the week to a number.
      Sunday corresponds to 1, Monday 2, etc..  If the function returns a 0
      value, an invalid parameter has been passed.  You can shorten the day
      names, but these abbreviations must be explicit to return an accurate
      value.

   $NOTES$
      ■  Uppercase and lowercase letters do not affect the name of the
         day of the week.

      ■  The function's operation depends on the country-specific
         adaptation of your CA-Clipper compiler.  With an English version of
         CA-Clipper, only English day names are recognized.

   $EXAMPLES$
      ■  What number of the day of the week is Sunday?

         ? CToDoW("Sunday")         // Result:  1

      ■  Show several ways to get the day of the week for Wednesday:

         ? CToDoW("WEDNESDAY")      // Result:  4
         ? CToDoW("Wednesday")      // Result:  4
         ? CToDoW("Wed")            // Result:  4

      ■  What number of the day of the week is Monday?

         CToDoW("M")                // Result:  2

   $PLATFORMS$
      DOS
   $SEEALSO$
      NToCDoW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CToMonth()
   $ONELINER$
      Converts the name of the month into a corresponding number
   $SYNTAX$
      CToMonth(<cMonth>) --> nMonth

   $ARGUMENTS$
      <cMonth>  Designates the name of one of the 12 months.

   $RETURNS$
      CToMonth() returns the number for the designated month name.

   $DESCRIPTION$
      Use CToMonth() to change the name of a month into a number.  January
      corresponds to 1, February 2, etc..  If the function returns a 0 value,
      then an invalid parameter has been passed.  If you shorten the month
      name, use explicit abbreviations to return an accurate return value.

   $NOTES$
      ■  Uppercase and lowercase letters do not affect the name of the
         month.

      ■  The function's operation depends on the country-specific
         adaptation of your CA-Clipper compiler.  With an English version of
         CA-Clipper, only English month names are recognized.

   $EXAMPLES$
      ■  Show the number for January:

         ? CToMonth("January")      // Result: 1

      ■  Show several ways to determine the month number for August:

         ? CToMonth("AUGUST")       // Result: 8
         ? CToMonth("August")       // Result: 8
         ? CToMonth("Au")           // Result: 8

      ■  The number for April:

         ?CToMonth("A")             // Result: 4

   $PLATFORMS$
      DOS
   $SEEALSO$
      NToCMonth()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DMY()
   $ONELINER$
      Returns a date in "DD Month YY" format
   $SYNTAX$
      DMY([<dDate>], [<lMode>]) --> cDate

   $ARGUMENTS$
      <dDate>  Designates the date from which to create a string.  The
      default is the system date.

      <lMode>  Designates whether to insert a period (.) after the day
      (see Examples).  The default is no period (.F.).

   $RETURNS$
      DMY() returns a character string in "DD[.] Month YY" format or "DD[.]
      Month YYYY" format.

   $DESCRIPTION$
      Use DMY() to return the date as a character string using the day, name
      of month, and year.  The CA-Clipper SET CENTURY ON/OFF switch determines
      whether or not the year is displayed in two or four digits.  If the
      <lMode> parameter is designated .T., the function builds in a "." after
      the day designation. If no date is designated as a parameter, the
      function automatically uses the current system date.

   $NOTES$
      ■  The month name returned depends on which CA-Clipper nations
         module is in use.

   $EXAMPLES$
      ■  Display the system date (1/1/89):

         SET CENTURY OFF
         ? DMY()                            // 1 January 89

      ■  With ".":

         ? DMY(.T.)                         // 1. January 89

      ■  Display a different date:

         SET CENTURY ON
         ? DMY(CToD("02/01/89"), .T.)       // 1. February 1989

   $PLATFORMS$
      DOS
   $SEEALSO$
      MDY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DoY()
   $ONELINER$
      Determines the day of the year for a specific date
   $SYNTAX$
      DoY([<dDate>]) --> nDayOfYear

   $ARGUMENTS$
      <dDate>  Designates which date to use to calculate the day of the
      year.  The default is the system date.

   $RETURNS$
      DoY() returns a calendar day number that specifies which day of the year
      <dDate> represents.

   $DESCRIPTION$
      If you frequently work with time periods, then this function is quite
      useful.  DoY() lets you assign a calendar day number to a date that
      relates to the beginning of the year.

   $NOTES$
      ■  When no date is specified, DoY() uses the system date.
         January 1 is always 1, December 31 is 366 in a leap year; otherwise,
         it is 365.  An empty date returns a 0 result.

   $EXAMPLES$
      How long is it until Christmas?

      ? "There are", NToC(DoY(CToD("12/24/91"))- DoY())  ;
         , " days until Christmas!"

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      EoM()
   $ONELINER$
      Determines the date for the last day of a month
   $SYNTAX$
      EoM([<dDate>]) --> dEndOfMonth

   $ARGUMENTS$
      <dDate>  Designates the date for which the last day of the month it
      lies in, is calulated.  The default is the system date.

   $RETURNS$
      EoM() returns the date of the last day of the month in <dDate>.

   $DESCRIPTION$
      EoM() determines the last day of the month in which <dDate> lies.  It
      also allows you to calculate how many days remain until the end of the
      month.

   $NOTES$
      ■  If no date is specified, the function automatically uses the
         system date.  An empty date parameter will always return an empty
         date.

      ■  Unlike LastDayOM(), EoM() does not return a numeric value (the
         number of days in the month), but another date.

   $EXAMPLES$
      Display the remaining days in the current month:

      ? EoM() - Date()

   $PLATFORMS$
      DOS
   $SEEALSO$
      BoM(), BoQ(), EoQ(), BoY(), EoY(), LastDayOM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      EoQ()
   $ONELINER$
      Determines the date for the end of a quarter
   $SYNTAX$
      EoQ([<dDate>]) --> dEndOfQuarter

   $ARGUMENTS$
      <dDate>  Designates the date for the last day of the quarter in
      which it lies, is calculated.  The default is the system date.

   $RETURNS$
      EoQ() returns the last day for the quarter that contains <dDate>.

   $DESCRIPTION$
      EoQ() determines when the current quarter that contains <dDate> ends.
      For example, it lets you calculate the number of days that remain before
      the end of the quarter.

   $NOTES$
      ■  If you do not specify a date, the function automatically uses
         the system date.  An empty date parameter results in an empty date.

   $EXAMPLES$
      The last day of the current quarter is:

      ? "The last day of the current quarter is:", EoQ()

   $PLATFORMS$
      DOS
   $SEEALSO$
      BoM(), EoM(), BoQ(), BoY(), EoY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      EoY()
   $ONELINER$
      Determines the date for the end of the year
   $SYNTAX$
      EoY([<dDate>]) --> dEndOfYear

   $ARGUMENTS$
      <dDate>  Designates the date determined for the last day of the
      year.   The default is the system date.

   $RETURNS$
      The returned date is December 31 of the specified year.

   $DESCRIPTION$
      EoY() determines the date for the end of year without having to create a
      date-type variable.

   $NOTES$
      ■  If no date is specified, the function automatically uses the
         system date.  An empty date parameter always returns an empty date.

   $EXAMPLES$
      ■  The last day of the current year (1991):

         ? EoY()            // 12/31/91

   $PLATFORMS$
      DOS
   $SEEALSO$
      BoM(), EoM(), BoQ(), EoQ(), BoY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsLeap()
   $ONELINER$
      Tests if a specific year is a leap year
   $SYNTAX$
      IsLeap([<dDate>]) --> lLeapYear

   $ARGUMENTS$
      <dDate>  Designates whether or not the specified date is in a leap
      year.  The default is the system date.

   $RETURNS$
      IsLeap() returns .T. when  <dDate> lies in a leap year; otherwise, it
      returns .F..

   $DESCRIPTION$
      A number of technical financial calculations need to know if a year has
      365 or 366 days.  IsLeap() determines this.

   $NOTES$
      ■  When parameters are missing, the function automatically uses
         the system date.  You must adhere to all rules for leap year tests.
         In the rare occurrence of a century change, the function also returns
         a correct result.

   $EXAMPLES$
      Determine if the following dates are in a leap year:

      ? IsLeap(CToD("01/01/1901"))      // .F., No leap year
      ? IsLeap(CToD("09/30/1988"))      // .T., leap year
      ? IsLeap(CToD("01/01/2000"))      // .T., leap year

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      LastDayOM()
   $ONELINER$
      Determines the number of days in a month
   $SYNTAX$
      LastDayOM([<dDate|nMonth>]) --> nDaysInMonth

   $ARGUMENTS$
      <dDate|nMonth>  Designates either a date or the number of a month.
      The default is the system date.

   $RETURNS$
      LastDayOM() returns the number of days in the month specified by
      <dDate|nMonth>.

   $DESCRIPTION$
      To administer due dates and other similar dates, it is useful to know
      the number of days that remain in a month.  Specify either the day's
      date or month as a parameter, and you get the length of the month in
      days.  If you subtract the number of days until today's date, you are
      left with the days that remain until month end.

   $NOTES$
      ■  Without the <dDate|nMonth> parameter, the function
         automatically uses the system date.  If there is an invalid number of
         months, LastDayOM() returns 0 as an error code.

   $EXAMPLES$
      How many days remain before the end of the month?

      ? "There are " + Str(LastDayOM() - Day(), 2) +;
         " days until the end of the month"

   $PLATFORMS$
      DOS
   $SEEALSO$
      EoM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MDY()
   $ONELINER$
      Returns a date in the "Month DD, YY" format
   $SYNTAX$
      MDY([<dDate>]) --> cDate

   $ARGUMENTS$
      <dDate>  Designates the date from which to create a string.  The
      default is the system date.

   $RETURNS$
      MDY() returns a character string in Month DD, YY, or "Month DD, YYYY"
      format.

   $DESCRIPTION$
      MDY() returns the date in a character string that contains the day, name
      of month, and year.  The CA-Clipper SET CENTURY ON/OFF switch determines
      whether or not the year is displayed in 2 or 4 digits.

      If the function is called without a parameter, it automatically uses the
      current system date.

   $NOTES$
      ■  The returned month name always depends on which CA-Clipper
         nations module is in use.  A German or French version of
         CA-Clipper returns the appropriate month names, despite its
         characteristically American display.

   $EXAMPLES$
      ■  Display system date (1/1/89):

         SET CENTURY OFF
         ? MDY()                      //  January 1, 89

      ■  Display a different date:

         SET CENTURY ON
         ? MDY(CToD("02/01/89"))      //  February 1, 1989

   $PLATFORMS$
      DOS
   $SEEALSO$
      DMY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NToCDoW()
   $ONELINER$
      Changes the number of a weekday into a weekday name
   $SYNTAX$
      NToCDoW(<nWeekday>) --> cWeekday

   $ARGUMENTS$
      <nWeekday>  Designates a weekday number from 1 to 7.

   $RETURNS$
      NToCDoW() returns a name that corresponds to its weekday number.

   $DESCRIPTION$
      This function converts a weekday number into the corresponding name.
      Sunday is 1, Monday is 2, Saturday is 7.  If you pass a number outside
      of this range, the function returns a 0 value.

   $NOTES$
      ■  Function operation depends on the country-specific adaptation
         of your CA-Clipper compiler.  With an English version of CA-Clipper,
         only English day names are returned.

   $EXAMPLES$
      An English CA-Clipper returns:

      ? NToCDoW(1)      // "Sunday"
      ? NToCDoW(4)      // "Wednesday"
      ? NToCDoW(7)      // "Saturday"
      ? NToCDoW(8)      // ""

   $PLATFORMS$
      DOS
   $SEEALSO$
      CToDoW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NToCMonth()
   $ONELINER$
      Changes the number of a month into a month name
   $SYNTAX$
      NToCMonth(<nMonth>) --> cMonth

   $ARGUMENTS$
      <nMonth>  Designates a month number for which a month name is returned.

   $RETURNS$
      NToCMonth() returns the name that corresponds to the month number.

   $DESCRIPTION$
      NToCMonth() determines the month name that corresponds to its month
      number.  January is 1, February is 2, ..., December is 12.  If a number
      outside this range is passed, the function returns a null string as a
      value.

   $NOTES$
      The function's operation depends on the country specific adaptation of
      your CA-Clipper compiler.  With an English version of CA-Clipper, only
      English day names are returned.

   $EXAMPLES$
      An English CA-Clipper returns:

      ? NToCMonth(1)         //"January"
      ? NToCMonth(2)         //"February"
      ? NToCMonth(12)        //"December"
      ? NToCMonth(14)        //""

   $PLATFORMS$
      DOS
   $SEEALSO$
      CToMonth()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Quarter()
   $ONELINER$
      Determines the quarter in which a specific date lies
   $SYNTAX$
      Quarter([<dDate>]) --> nQuarter

   $ARGUMENTS$
      <dDate>  Designates in which quarter the specified date lies.  The
      default is the system date.

   $RETURNS$
      Quarter() returns a number that identifies the quarter in which <dDate>
      lies.

   $DESCRIPTION$
      Quarter() determines which quarter of the year <dDate> lies.

   $NOTES$
      ■  When no date is specified, the function automatically uses the
         system date.  An empty date returns 0 as a result.

   $EXAMPLES$
      Compute a delivery date:

      ? "We will deliver in quarter ", Quarter(CToD("07/12/1991")), "1991"

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SecToTime()
   $ONELINER$
      Converts seconds into a time string
   $SYNTAX$
      SecToTime(<nSeconds>, [<lHundredth>]) --> cTime

   $ARGUMENTS$
      <nSeconds>  Designates the number of seconds since midnight to
      convert into a character string in time format.

      <lHundredth>  If this optional parameter is designated as .T., the
      resulting time string contains hundredths of seconds.  The default is no
      hundredths (.F.).

   $RETURNS$
      SecToTime() returns a time string that corresponds to <nSeconds> in the
      "HH:MM:SS" or "HH:MM:SS:hh" format.

   $DESCRIPTION$
      This function can be applied in two areas -- to convert numeric time
      spans in seconds, and to convert a point in time into the "HH:MM:SS" or
      "HH:MM:SS:hh" format.

      If hundredths of seconds are also desired in the time string result,
      then designate the second parameter as .T..  The portion of the value
      for <nSeconds> to the right of the decimal is also converted.

   $NOTES$
      ■  Seconds since midnight are in the range of 0 to 86400.  With
         larger values, the function internally executes the operation
         <nSeconds>
         % 86400 and then uses the result value.  86400 seconds corresponds to
         an entire day.

      ■  There is no rounding when values like 45366.98 are converted
         without hundredths.

   $EXAMPLES$
      ■  Calculate the span between two times.  The result is displayed
         in the "HH:MM:SS" format:

         nBeginning  :=  170
         nEnd         :=  3656
         ? SecToTime(nEnd - nBeginning)     // "00:58:06"

      ■  With hundredth seconds:

         ? SecToTime(45873.22, .T.)         // "12:44:33:22"

   $PLATFORMS$
      DOS
   $SEEALSO$
      TimeToSec()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetDate()
   $ONELINER$
      Sets the system date
   $SYNTAX$
      SetDate(<dDate>, [<lMode>]) --> lSet

   $ARGUMENTS$
      <dDate>  Designates which date to use to set the system date.

      <lMode>  Designates whether the date should also be set in the CMOS-
      RAM of an AT.  The default is do not write (.F.).

   $RETURNS$
      SetDate() returns .T. when the date is successfully set.

   $DESCRIPTION$
      When you use this function to set the system date from within your
      CA-Clipper application, all files acquire this date with each write
      procedure.

   $NOTES$
      ■  Please note that you can only implement the optional <lMode>
         parameter for AT-compatible machines.  The correct operation of
         SetDate() cannot be guaranteed on machines that use a hardware clock.
         The default value for <lMode> is .F..

   $EXAMPLES$
      ■  Set the system date in each case; but the hardware clock only
         on an AT:

         dNewDate  :=  CToD("07/30/91")
         IF IsAt()
            SetDate(dNewDate, .T.)
         ELSE
            SetDate(dNewDate)
         ENDIF

      ■  Or, more compactly:

         SetDate(dNewDate, IsAt())

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetTime(), IsAt()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetTime()
   $ONELINER$
      Sets the system clock
   $SYNTAX$
      SetTime(<cTime>, [<lMode>]) --> lSet

   $ARGUMENTS$
      <cTime>  Designates a character string that contains the time that
      is to become the system time.

      <lMode>  Designates whether the time should also be set in the
      CMOS-RAM of an AT.  The default is do not write to CMOS-RAM.

   $RETURNS$
      The function returns .T. when the time is set successfully.

   $DESCRIPTION$
      When you use this function to convert the time into the system time from
      within your CA-Clipper application, all files acquire this time with
      each write procedure.

   $NOTES$
      ■  Please note that you can only implement the optional <lMode>
         parameter in AT-compatible machines.  The correct operation of
         SetTime() cannot be guaranteed on machines that use a hardware clock.
         The default value for <lMode> is .F..

   $EXAMPLES$
      ■  Set the system time in each case; but the hardware clock only
         on an AT:

         cNewTime  :=  "10:20:00"
         IF IsAt()
            SetTime(cNewTime, .T.)
         ELSE
            SetTime(cNewTime)
         ENDIF

      ■  Or, more compactly:

         SetTime(cNewTime, IsAt())

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetDate()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ShowTime()
   $ONELINER$
      Continuously displays the time at desired screen position
   $SYNTAX$
      ShowTime([<nRow>], [<nColumn>], [<lMode>],
         [<cAttr|nAttr>], [<l12/24>], [<lAM/PM>]) --> cNull

   $ARGUMENTS$
      <nRow>  Designates the row where the time is displayed.  The default
      is the cursor row.

      <nColumn>  Designates the column where the time is displayed.  The
      default is the cursor column.

      <lMode>  Designates whether seconds are to appear in the time
      display (.F.), or not (.T.).  The default is display seconds (.F.).

      <cAttr|nAttr>  Designates to the screen attribute to use for the
      time display.  Strings in the form "NN/NN" or "CC/CC" (e.g., "0/7" or
      "B/GR") are possible.  The default is the setting for CLEARA (see
      Introduction, Video Functions).

      <l12/24>  By designating this parameter as .T., a 12-hour display is
      selected.  The default is a 24-hour display (.F.).

      <lAM/PM>  If you have a 24-hour display, you may want to switch on
      an am/pm display.  When you specify this parameter as .T., an "a" or "p"
      (as in DOS), appears to reflect the time.  The default is no display
      (.F.).

      ()  A call without parameters uninstalls the time display.

   $RETURNS$
      ShowTime() always returns a null string.

   $DESCRIPTION$
      This function permits you to constantly display the time in any screen
      position desired. ShowTime() is interrupt controlled and has the ability
      to display the time in either "hh:mm:ss" or "hh:mm" format.  A 12- or 24-
      hour display can be selected, with or without an am/pm display.

   $NOTES$
      Warning!  ShowTime() works with the interrupt system.  Before
      leaving your CA-Clipper application, you must uninstall ShowTime() , so
      that the interrupt vectors can be restored.  Otherwise, the system will
      be unstable and will eventually crash.  Simultaneous use of the
      accompanying Extended Drivers Modules automatically restores the
      interrupt vectors in use.

      ■  Specify the screen attribute as either a numeric or a string
         in "NN/NN" form.  If no attribute is specified, the value for CLEARA
         applies (see Introduction Video Functions).

   $EXAMPLES$
      ■  Display a clock in row 0, column 70, with no seconds display
         and the standard attribute.  When a display is shown in row 0, switch
         SCOREBOARD off!

         SET SCOREBOARD OFF
         ShowTime(0, 70, .T.)      //  Turn on clock
            *...
            *...
         nSHOWTIME()               //  Uninstall clock

      ■  Show a 12-hour display with am/pm on the lowest row.  White
         letters on a blue background:

         ShowTime(24, 70, .T., "W/B")

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SToD()
   $ONELINER$
      Converts an ANSI date string into CA-Clipper format
   $SYNTAX$
      SToD(<cAnsiDate>) --> dDate

   $ARGUMENTS$
      <cAnsiDate>  Designates the character string that contains a date in
      the ANSI format "YYYYMMDD" that is to be converted into the CA-Clipper
      date format.

   $RETURNS$
      SToD() returns the <cAnsiDate> character string in the corresponding CA-
      Clipper date format.

   $DESCRIPTION$
      SToD() converts an ANSI date created by the CA-Clipper DToS() function,
      back into the standard date format.

   $NOTES$
      ■  If the ANSI date is invalid, a null date is returned.

   $EXAMPLES$
      Display the ANSI date in default date format:

      APPEND FROM OTHDATE
      LIST SToD(cAnsiDate)

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TimeToSec()
   $ONELINER$
      Calculates the seconds since midnight
   $SYNTAX$
      TimeToSec(<cTime>) --> nSeconds

   $ARGUMENTS$
      <cTime>  Designates a character string that contains the time in the
      format "HH:MM:SS:hh".  The default is the system time.

   $RETURNS$
      The returned value designates how many seconds have elapsed between
      midnight and <cTime>.  Hundredths of seconds are contained as a decimal
      value.

   $DESCRIPTION$
      When computing time periods, or when adding times, it is simpler to deal
      with seconds since midnight instead of time designations.  These
      calculations are simplified significantly.  The SecToTime() function
      converts the result into a time designation again.  Starting from back
      to front, you can omit the hundredths, seconds, and minutes from the
      time string that is passed as a parameter.  These values are then
      assumed to be "00".

      If you do not specify a parameter, the function uses the current time on
      the system clock.

   $EXAMPLES$
      ■  A simple conversion:

         ? TimeToSec("12:44:33:22")                 // Result:  45873.22

      ■  The period between two times is calculated. The result is
         displayed in seconds:

         cBegin      :=  "12:55:44:33"
         cEnd         :=  "14:56:12:22"
         ? TimeToSec(cEnd) - TimeToSec(cBegin)      // Period in seconds

      ■  Possible formats:

         ? TimeToSec("12")
         ? TimeToSec("12:44)
         ? TimeToSec("12:44:33)
         ? TimeToSec("12:44:33:22")

   $PLATFORMS$
      DOS
   $SEEALSO$
      SecToTime()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      TimeValid()
   $ONELINER$
      Determines whether a specified time is valid
   $SYNTAX$
      TimeValid(<cTime>) --> lValid

   $ARGUMENTS$
      <cTime>  Designates a character string that contains the time to
      test.

   $RETURNS$
      TimeValid() returns .T. when <cTime> is a valid time; or .F. when
      <cTime> is an invalid time.

   $DESCRIPTION$
      With input that requires time manipulation, writing your own UDF to
      check time inputs was unavoidable up to now.  TimeValid() permits
      complete checking of a time designation.  You can use this function
      effectively with a VALID clause within a READ mask.

   $NOTES$
      ■  Note the format for time designations.  There must always be
         two digits for hours, minutes, seconds, and hundredths; otherwise,
         the time it is regarded as invalid.  Valid examples are "12",
         "12:59", "12:59:59", and "12:59:59:99".  By contrast, invalid
         examples are "24", "12:60", or "12:1", and/or "12:".  If you work
         with time strings that are not completely filled and that you need to
         check with TimeValid(), then they must be TRIMmed prior to the use of
         TimeValid() (see following Examples).

   $EXAMPLES$
      ■  Using the VALID clause with TRIM, all valid times are
         accepted, even if no seconds or minutes are specified:

         cBegin  :=  Space(11)
         @ 5, 10 SAY "Please input time for beginning work:";
         GET cBegin VALID TIMEVALID(Trim(cBegin))
         READ

      ■  Using a VALID clause without TRIM, hours and minutes must be
         specified, so that TimeValid() can confirm a valid time:

         cBegin  :=  Space(5)
         @ 5, 10 SAY "Please input time for beginning work:";
         GET cBegin VALID TIMEVALID(cBegin)
         READ

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WaitPeriod()
   $ONELINER$
      Pauses a specified time in increments of 1/100 seconds
   $SYNTAX$
      WaitPeriod([<nDelay>]) --> lNotElapsed

   $ARGUMENTS$
      <nDelay>  Designates the waiting period at initialization in
      1/100ths of seconds.  Values from 1 to 8, 640, 000 (one day) are
      possible.

   $RETURNS$
      WaitPeriod() returns .T. , if the time span designated at initialization
      has not elapsed.

   $DESCRIPTION$
      This function sets a time span for a CA-Clipper DO WHILE loop to run.
      The function must initialize prior to the loop, since you must specify
      the <nDelay> parameter in 1/100th seconds.  Subsequently, the function
      can be implemented without a parameter for additional loop conditions.
      It returns .T., as long as the designated time span has not yet run out.

   $NOTES$
      ■  The function notes the status of the internal timer at
         initialization.  From that point on, the initialization should always
         precede the respective DO WHILE; otherwise, the time delay is
         incorrect.  The passing of midnight (the time resets to the 0 value)
         is taken into account.

   $EXAMPLES$
      Run a loop for 5 seconds:

      WaitPeriod(500)               // Initialization, 5 seconds
      DO WHILE <cond1> .AND. <cond2> .AND. WaitPeriod()
         *...
      ENDDO

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Week()
   $ONELINER$
      Returns the calendar week for a date
   $SYNTAX$
      Week([<dDate>]) --> nWeekOfYear

   $ARGUMENTS$
      <dDate>  Designates a date for which the week it lies in, is
      determined.  The default is the system date.

   $RETURNS$
      Week() returns a sequential week number that designates in which week of
      the year <dDate> lies.

   $DESCRIPTION$
      The week of the year in which a day lies is information required by a
      number of technical financial calculations or wage accounting.  This
      function determines this week and acknowledged all calendar rules.

   $NOTES$
      ■  When no date is specified, then Week() uses the system date.
         An empty date leads to a 0 result.

   $EXAMPLES$
      Determine the week for a date:

      dDate  :=  CToD("03/14/92")

      ? "This date is in week:  ", Week(dDate)

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      WoM()
   $ONELINER$
      Returns the week within a month.
   $SYNTAX$
      WoM([<dDate>]) --> nWeekOfMonth

   $ARGUMENTS$
      <dDate>  Designates a date for which you want to determine which
      week of the month it lies in.  The default is the system date.

   $RETURNS$
      WoM() returns the number that reflects the week within a month in which
      <dDate>lies.

   $DESCRIPTION$
      The WoM() function can returns the corresponding week of the month for
      every valid date.

   $NOTES$
      ■  When no date is specified, WoM() uses the system date.  An
         empty date returns a result of 0.

   $EXAMPLES$
      Compute a delivery date:

      ? "We will deliver in week" + Str(WoM(dDate)) + " in; August!"

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Database Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      The functions presented in this chapter are a useful extension of
      database handling.  For example, you can determine if there is a memo
      file (.dbt) associated with a database, the number of decimal places, or
      the data type of a particular field.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DBFDSKSIZE()
   $ONELINER$
      Determines the size of a selected (.dbf) file on a disk drive
   $SYNTAX$
      DBFDSKSIZE() --> nFileSize

   $RETURNS$
      DBFDSKSIZE() returns the size of the current database on the floppy or
      hard disk (i.e., how many bytes are saved in this file).

   $DESCRIPTION$
      One of the DBFDSKSIZE() function's most useful applications is when it
      is used in conjunction with DbfSize().  When the results for both
      functions indicate there is a deviation in the size of a database, this
      means a portion of the data is not yet written to the floppy/hard disk.
      You can also determine if and when new input is written to a floppy/hard
      disk.

   $NOTES$
      ■  This function operates on the currently SELECTed work area.

   $EXAMPLES$
      Determine if a portion of data input has been written out to disk yet:

      SIZEIF Dbf() - DBFDSKSIZE() >= 512
         * COMMIT               //  Warning! Works only with DOS 3.3 and up
         USE File
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DbfSize()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DbfSize()
   $ONELINER$
      Determines the size of a selected (.dbf) file in memory
   $SYNTAX$
      DbfSize() --> nFileSize

   $RETURNS$
      DbfSize() returns the byte size of the current database in working
      memory.

   $DESCRIPTION$
      DbfSize() determines how much room a database occupies, before you write
      this file to a disk.  The function is also useful when used in
      conjunction with DBFDSKSIZE().  When the results for both functions
      indicate there is a deviation in the size of a database, this means a
      portion of the data is not yet written to the floppy/hard disk.  You can
      also determine if and when new input is written to a floppy/hard disk.

   $NOTES$
      ■  This function always operates on the currently SELECTed work
         area.

   $EXAMPLES$
      Can a (.dbf) file be copied to the target disk?

      USE DATA.
      IF DiskFree("A") < DbfSize().
         ? "The file can not be copied.".
         ? "Insufficient space remaining on disk.".
      ELSE.
         COPY TO A:COPY.
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DBFDSKSIZE(), DiskFree()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FieldDeci()
   $ONELINER$
      Determines the number of decimal places in a field
   $SYNTAX$
      FieldDeci(<nField>) --> nDecimalPlaces

   $ARGUMENTS$
      <nField>  Designates for which numeric data field to determine the
      number of decimal places.

   $RETURNS$
      When a field number is valid, FieldDeci() returns the number of decimal
      places in a numeric data field.

   $DESCRIPTION$
      It is important to know how many decimal places are in a data field so
      you can limit the input of significant digits in the corresponding
      number.  FieldDeci() determines the number of decimal places available.
      This allows you to tailor inputs to the database without changing the
      program.

   $NOTES$
      ■  If you have an invalid field number, the function returns a
         value of 0.

   $EXAMPLES$
      Convert the second field to a string with the correct number of decimal
      places:

      @ 0, 60 SAY "Price:  " + Str(cField2, 8, FieldDeci(2))

   $PLATFORMS$
      DOS
   $SEEALSO$
      FieldSize(), FieldType()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FieldNum()
   $ONELINER$
      Determines the field number for a specific field in a database file
   $SYNTAX$
      FieldNum(<cFieldName>) --> nFieldNumber

   $ARGUMENTS$
      <cFieldName>  Designates to the field name.

   $RETURNS$
      FieldNum() returns the number of the data field.

   $DESCRIPTION$
      FieldNum() is the exact opposite of the CA-Clipper Field() function.
      Use this function when you need a data field number instead of the data
      field name.  FieldNum() determines if a symbol name pertains to a data
      field or a memory variable (see Examples).

   $NOTES$
      ■  If a data field with the name <cFieldName> is not available,
         the function returns a value of 0.

   $EXAMPLES$
      Is it a field or a variable?

      IF FieldNum("cName") > 0.
         REPLACE cName WITH Upper(cName).
      ELSE.
         cName  :=  Upper(cName).
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      DBFDSKSIZE(), DiskFree()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FieldSize()
   $ONELINER$
      Determines the size of a field
   $SYNTAX$
      FieldSize(<nField>) --> nLength

   $ARGUMENTS$
      <nField>  Designates the number of the field to evaluate.

   $RETURNS$
      FieldSize() returns a numeric value that corresponds to the field length
      of a valid field number.

   $DESCRIPTION$
      Use FieldSize() to determine the length (or size) of data field of
      desired data types.  This determines the window width needed for output
      to appear without a line break, or the length needed for an input to
      automatically fit in the database.

   $NOTES$
      ■  If there is an invalid data field number, the function returns
         a value of 0.

   $EXAMPLES$
      Determine the total length of fields 3 to 5:

      nLength  :=  0
      FOR I = 3 TO 5
         nLength := nLength + FieldSize()
      NEXT

   $PLATFORMS$
      DOS
   $SEEALSO$
      FieldDeci(), FieldType()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FieldType()
   $ONELINER$
      Determines the data type for a field
   $SYNTAX$
      FieldType(<nField>) --> cType

   $ARGUMENTS$
      <nField>  Designates the data field for which the data type is
      determined.

   $RETURNS$
      FieldType() returns a single character that designates the data type of
      the data field (assuming the data field number is valid).  FieldType()
      returns the following characters for the various data field types:

      Table 10-1: Coding for Data Field Types
      <table>
          Character    Data Type

          C            Character string
          N            Numeric
          D            Date
          L            Logical
          M            MEMO
         </table>

   $DESCRIPTION$
      FieldType() operates in a similar fashion to the CA-Clipper Type()
      function.  With Type(), you must always know only the name of the data
      field.  However, FieldType() requires that you only know the data field,
      not its name.  Use the function to confirm data types for data fields
      when a program is working with different databases that have different
      field names.

   $NOTES$
      ■  If there are  invalid data field numbers, the function returns
         a null string.

   $EXAMPLES$
      Data type for field number 5:

      IF FieldType(5) = "C"
         ? "Field No. 5 is a character field!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      FieldSize(), FieldDeci()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ISDBT()
   $ONELINER$
      Determines if a memo file (.dbt) is present
   $SYNTAX$
      ISDBT() --> lPresent

   $RETURNS$
      ISDBT() returns .T., if a database has a memo file associated with it.

   $DESCRIPTION$
      ISDBT() determines if a database has a memo file associated with it, and
      allows you to compress that memo file.

   $EXAMPLES$
      If the database has a memo file, the database is copied to minimize the
      memo file:

      USE DATA
      IF ISDBT()
         COPY TO TEMP
         CLOSE DATABASES
         DeleteFile("DATA.DBF")
         DeleteFile("DATA.DBT")
         RenameFile("TEMP.DBF", "DATA.DBF")
         RenameFile("TEMP.DBT", "DATA.DBT")
      ENDIF

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Set Status
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      In this chapter, the group of functions determine the switch status and
      were implemented in the CA-Clipper Tools (CA-Clipper Summer 1987
      release).  CA-Clipper implemented the Set() function, so that these
      settings can be determined, set, and saved with this version.
      Therefore, some functions in this chapter only exist to enable
      compatibility with existing programs.  All the affected functions are
      flagged with an "*".

      If the functions relate to the CA-Clipper switches (SET's), the function
      name is represented as follows:  CSET + the first four characters of the
      switch name.  For example, if the switch is named CONFIRM, then the
      function that corresponds is CSETCONF().  If the parameter is optional
      and unspecified, the function returns the current setting for its
      switch, without a status change.  When called with parameters, the
      function sets the switch to the passed value and returns the prior
      status as a value.  In this way, a function call can both change a
      switch and save the old status.  The logical value .T. corresponds to
      the ON setting of a switch; .F. corresponds to OFF.

      b>Example</b>

      In the following example, the CONFIRM switch was set to .F.:

      lOldValue:= CSETCONF(.T.)

      After execution, the old variable lOldValue has a value of .F.; while
      the CONFIRM switch is ON (.T.).

      In addition to their usefulness with CA-Clipper switches, these
      functions determine an assortment of other status information.  For
      example, you can determine the current status of the debugger, set
      LASTKEY, and differentiate key traps.  You can also determine the status
      of CAPS-LOCK, NUM-LOCK, INSERT, and SCROLL-LOCK.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETALL()
   $ONELINER$
      Saves all ON/OFF switch settings
   $SYNTAX$
      CSETALL([<cNewSwitchList>]) --> cOldSwitchList

   $ARGUMENTS$
      <cNewSwitchList>  Designates in a specific format (shown in the
      tables on the next page), which switches are to be on or off.

   $RETURNS$
      CSETALL() returns the current setting of all ON/OFF switches when no
      parameter is specified.  When the parameter is specified, the function
      returns the previous setting.

   $DESCRIPTION$
      This function allows you to query the current setting for all CA-Clipper
      ON/OFF switches and change them.  Since you can save 21 different
      switches, the function returns a 21-character string made with 0's and
      1's, rather than logical values.  This function makes it easy to save
      all the ON/OFF switches in a CA-Clipper error trap, and reset them when
      you exit.  The following switches are contained in the character string
      (in the order they occur in the returned string):

      Table 11-1: Clipper Switch Status
      <table>
          Byte    Function      Clipper Switch

          1       CSETALTE()     SET ALTERNATE
          2       CSETBELL()     SET BELL
          3       CSETCARR()     SET CARRY
          4       CSetCent()     SET CENTURY
          5       CSETCONF()     SET CONFIRM
          6       CSETCONS()     SET CONSOLE
          7       CSetCurs()     SET CURSOR
          8       CSETDELE()     SET DELETED
          9       CSETDELI()     SET DELIMITERS
          10      CSETDEVI()     SET DEVICE
          11      CSETESCA()     SET ESCAPE
          12      CSETEXAC()     SET EXACT
          13      CSETEXCL()     SET EXCLUSIVE
          14      CSETFIXE()     SET FIXED
         </table>

      Table 11-2: Clipper Switch Status
      <table>
          Byte    Function       Clipper Switch

          15      ReadInsert()   INSERT Mode
          16      CSETINTE()     SET INTENSITY
          17      CSETPRIN()     SET PRINT
          18      CSETSCOR()     SET SCOREBOARD
          19      CSETSOFT()     SET SOFTSEEK
          20      CSETUNIQ()     SET UNIQUE
          21      CSETWRAP()     SET WRAP
         </table>

   $NOTES$
      ■  If you specify an invalid parameter, the function returns a
         null string and does not reset any switch.

   $EXAMPLES$
      Display the current bell status:

      cSwitches  :=  CSETALL()         // 010000000000000000000

      IF SubStr(cSwitches, 2, 1) == "1"
         ? " BELL is on!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSETxxxx()*
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETCLIP()
   $ONELINER$
      Determines the content of CA-Clipper environmental variables
   $SYNTAX$
      CSETCLIP(<cEnvParameter>) --> nEnvParameterValue

      Important!  CA-Clipper no longer supports all possible settings for
      environmental variables in the CA-Clipper Summer 1987 release.
      Therefore, CSETCLIP() is modified to reflect these changes.

   $ARGUMENTS$
      <cEnvArguments>  Designates which SET CA-Clipper setting to return.

   $RETURNS$
      SETCLIP() returns the setting of the requested SET CLIPPER= option.

   $DESCRIPTION$
      The CA-Clipper environmental variable contains settings for a
      CA-Clipper application.  Use CSETCLIP() to query these values from
      within the application.  The letter you use for the respective SET
      CLIPPER= option is given as a parameter. This value cannot be set from a
      running program since memory allocation is already determined.  (You
      must determine memory allocation before you start an application.)

   $NOTES$
      ■  Uppercase or lowercase letters have no impact on the
         parameter.

   $EXAMPLES$
      ■  Uppercase or lowercase letters do not impact the parameter:

         ? CSETCLIP("F")       // SET CLIPPER= Fnnn
         ? CSETCLIP("e")       // SET CLIPPER= Ennn
         ? CSETCLIP("X")       // SET CLIPPER= Xnnn
         ? CSETCLIP("SWAPK")   // SET CLIPPER= SWAPK:nnn

      ■  With an invalid parameter:

         ? CSETCLIP("z")       // -1

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETDATE()*
   $ONELINER$
      Queries the SET DATE setting
   $SYNTAX$
      CSETDATE() --> nDateFormat

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $RETURNS$
      The returned numeric code signifies the current setting for SET DATE.

   $DESCRIPTION$
      This function allows you to query the current setting for SET DATE.  The
      table below describes the numeric codes that are returned:

      Table 11-3: Coding for country specific date formats
      <table>
          Code    Definition

          1       AMERICAN
          2       ANSI
          3       BRITISH
          4       FRENCH
          5       GERMAN
          6       ITALIAN
         </table>

   $NOTES$
      ■  This function cannot alter the status of SET DATE.

   $EXAMPLES$
      For SET DATE AMERICAN, CSETDATE() returns a value of 1.

      SET DATE AMERICAN ? CSETDATE()      // 1

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETDECI()*
   $ONELINER$
      Queries the setting for SET DECIMALS TO
   $SYNTAX$
      CSETDECI() --> nDecimalPlaces

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $RETURNS$
      CSETDECI() returns the value of the current number of decimal places
      that are displayed.

   $DESCRIPTION$
      This function queries the current setting for SET DECIMALS TO.

   $NOTES$
      ■  This function cannot change the number of decimal places.

   $EXAMPLES$
      ■  Set decimal places with CA-Clipper:

         SET DECIMALS TO 2

      ■  Returns the number of decimal places previously set:

         ? CSETDECI()      // 2

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETDEFA()*
   $ONELINER$
      Queries the setting for SET DEFAULT
   $SYNTAX$
      CSETDEFA() --> cDefaultPath

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $RETURNS$
      CSETDEFA() returns the current DEFAULT path setting.

   $DESCRIPTION$
      This function queries the current SET DEFAULT TO setting.

   $NOTES$
      ■  This function cannot change the DEFAULT path.

   $EXAMPLES$
      ■  A path set under CA-Clipper:

         SET DEFAULT TO C:\DATA

      ■  Query the previously set DEFAULT path:

         ? CSETDEFA()      // "C:\DATA"

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETFUNC()*
   $ONELINER$
      Queries the setting for SET FUNCTION TO
   $SYNTAX$
      CSETFUNC(<nFunctionKey>) --> cCharacterString

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $ARGUMENTS$
      <nFunctionKey>  Designates the function key for which the associated
      character string is determined.

   $RETURNS$
      CSETFUNC() returns the character string associated with <nFunctionKey>.

   $DESCRIPTION$
      This function queries the setting for SET FUNCTION TO.

   $NOTES$
      ■  To use this function, you must include the CT.CH file at the
         beginning of your program with the command:

         #include "CT.CH"

         Find more information on this function in CT.CH.

   $EXAMPLES$
      The F10 key is assigned to Ctrl-C.  The setting changes in a function
      Test().  Since it is saved, you can restore it upon return:

      SET FUNCTION 10 TO Chr(3)
      cOldFunc  := CSETFUNC(10)      // Save assignment
      Test()                         // Call UDF
      SET FUNCTION 10 TO cOldFunc

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSetKey()*
   $ONELINER$
      Queries the setting for SET KEY TO
   $SYNTAX$
      CSetKey(<nKeyValue>) --> cProcedureName

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $ARGUMENTS$
      <nKeyValue>  Designates the Inkey() for which the associated
      procedure name is determined.

   $RETURNS$
      CSetKey() returns a character string that names the procedure associated
      with <nKeyValue>.

   $DESCRIPTION$
      This function queries the setting for SET KEY..TO.

   $NOTES$
      ■  To use this function, you must include the CT.CH file at the
         beginning of your program with the command:

         #include "CT.CH"

         Find more information on this function in CH.CH.

   $EXAMPLES$
      Save the assignment for the function key F2:

      cOldF2Proc  :=  CSetKey(-1)

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSETALL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETLDEL()*
   $ONELINER$
      Queries the setting for the left delimiters
   $SYNTAX$
      CSETLDEL() --> cLeftDelimiter

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $RETURNS$
      CSETLDEL() returns the character established as the left delimiter.

   $DESCRIPTION$
      This function queries the current character used in GET fields as a left
      delimiter.

   $NOTES$
      ■  This function cannot change the delimiter.

   $EXAMPLES$
      Query the character for the left delimiter:

      cLeftDelim:= CSETLDEL()

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSETRDEL()*, CSETxxxx()*
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETMARG()*
   $ONELINER$
      Queries the setting for SET MARGIN TO
   $SYNTAX$
      CSETMARG() -->    nLMargin

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $RETURNS$
      CSETMARG() returns a value that corresponds to the value SET MARGIN
      determined for the left print border.

   $DESCRIPTION$
      This function determines the current setting for the left print border.

   $NOTES$
      ■  This function cannot change the value set for the margin.

   $EXAMPLES$
      Save the value for SET MARGIN:

      nPrintBound:=  CSETMARG()

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETPATH()*
   $ONELINER$
      Queries the setting for SET PATH TO
   $SYNTAX$
      CSETPATH() --> cSearchPath

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $RETURNS$
      CSETPATH() returns a value that corresponds to the current
      CA-Clipper file search path.

   $DESCRIPTION$
      This function returns the file search path set by SET PATH TO.

   $EXAMPLES$
      Save the path set with SET PATH TO:

      cSearchPath:=  CSETPATH()

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETRDEL()*
   $ONELINER$
      Queries the setting for the right delimiter
   $SYNTAX$
      CSETRDEL() --> cRightDelimiter

      *  This function is retained for compatibility purposes.  Use the
         CA-Clipper Set() function to develop future applications.

   $RETURNS$
      CSETRDEL() returns the character established as the right delimiter.

   $DESCRIPTION$
      This function queries the current character used as a right delimiter in
      GET fields.

   $NOTES$
      ■  This function cannot change the delimiter.

   $EXAMPLES$
      Query the character for the right delimiter:

      cRightDelim:= CSETRDEL()

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSETLDEL()*, CSETxxxx()*
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETRDONLY()*
   $ALIAS$
      CSETRDONLY()
   $ONELINER$
      Queries/sets the read-only mode switch
   $SYNTAX$
      CSETRDONLY([<lR/O-NewMode>]) --> lR/O-OldMode

      *  This function is retained in CA-Clipper Tools II/5.0 for
         compatibility purposes.  Use the READ-ONLY clause of the
         CA-Clipper  USE command to develop future applications.

   $ARGUMENTS$
      <lR/O-NewMode>  Designates the new switch status.  .T. turns the
      read-only mode on; .F. turns it off.  The default value is off.

   $RETURNS$
      If no parameter is passed, the function returns to the current switch
      setting; otherwise, it returns the previous setting.

   $DESCRIPTION$
      Important!  Please note the changes in the CA-Clipper USE command!

      This function was implemented in the CA-Clipper Summer 1987 release to
      allow you to open files in read-only mode.  This function was also
      useful for CD-ROM access and the enabled you to open a network database
      if you lacked write permission.

      However, in CA-Clipper READONLY you can append to the USE command and do
      not have to implement CSETRONLY().  The switch has been retained in this
      release to insure compatibility with previous versions of CA-Clipper
      Tools.  You can still use it to query, but it no longer has direct
      impact on the open mode.

      This switch functions in the enclosed CA-Clipper Tools CT.CH definition
      file.

   $NOTES$
      ■  For new applications, use the read-only key word in
         conjunction with the USE command.

   $EXAMPLES$
      Set the read-only mode switch (it only functions when you use the CT.CH
      header file):

      ? CSETRDONLY(.T.)         // Returns old setting
      USE ....                  // Open with READ ONLY access

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSetSafety()
   $ONELINER$
      Queries/sets the safety mode switch
   $SYNTAX$
      CSetSafety([<lNewSwitch>]) --> lOldSwitch

   $ARGUMENTS$
      <lNewSwitch>  Designates whether existing files should not be
      overwritten during CA-Clipper Tools file operations.  Designates .F. for
      yes; .T. for no.

   $RETURNS$
      CSetSafety() returns the current setting for the CA-Clipper Tools safety
      mode switch; or if <lNewSwitch> is passed, the previous setting.

   $DESCRIPTION$
      CSetSafety() returns a logical value for the current setting of the
      CA-Clipper Tools internal safety mode switch.  If you designate
      CSetSafety() as .T., the CA-Clipper Tools functions do not overwrite
      existing files.

   $NOTES$
      Warning!  CSetSafety() only works with CA-Clipper Tools functions..

   $EXAMPLES$
      ■  Query the SAFETY function:

         lSafety:=  CSetSafety()

      ■  Turn safety mode on and save the previous status:

         lOldSafety:= CSetSafety(.T.)

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETSNOW()
   $ONELINER$
      Helps prevent snow on the screen
   $SYNTAX$
      CSETSNOW([<lNewSwitch>]) --> lOldSwitch

      *  This function is retained in CA-Clipper Tools for compatibility
         purposes.  Use the CA-Clipper NoSnow() function to develop future
         applications.

   $ARGUMENTS$
      <lNewSwitch>   Designates the new status for "Snow Prevent".  A .T.
      signifies on; .F. means off.  The default value for Snow Prevent is off
      (.F.).

   $RETURNS$
      CSETSNOW() returns the current setting, when no parameter is designated;
      otherwise, it returns the previous setting.

   $DESCRIPTION$
      Snow tends be is especially bad in CGA card screen output.  To prevent
      it, set the CSETSNOW switch.

      Use the CA-Clipper NoSnow() function for new applications.

   $NOTES$
      ■  CSETALL() does not acknowledge the CSETSNOW() setting.

   $EXAMPLES$
      ■  Output with Snow Prevent on:

         CSETSNOW(.T.)                   // Returns old setting

      ■  Acknowledge existing hardware:

         CSETSNOW(IsCGA())               //  Snow prevent if CGA card

   $PLATFORMS$
      DOS
   $SEEALSO$
      IsCGA()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CSETxxxx()*
   $ONELINER$
      Queries the SET position of a particular ON/OFF switch and provides the option to set it
   $SYNTAX$
      CSETxxxx([<lNewSwitch>]) --> lOldSwitch

      *  This function is retained in CA-Clipper Tools for compatibility
         purposes.  Use the CA-Clipper Set() function to develop future
         applications.

   $ARGUMENTS$
      <lNewSwitch>  Designates the new status for the SET xxxx command.
      .T. corresponds to on; .F. signifies off.

   $RETURNS$
      If no parameter is passed, the function returns the current setting;
      otherwise, it returns the previous setting.

   $DESCRIPTION$
      This is a group of 20 functions.  If you call all these functions the
      same way, they return the same value.  Each function name consists of
      "CSET", and the first four characters of the respective CA-Clipper set
      condition:

      Table 11-4:  Functions to Query Clipper Set Conditions
      <table>
          Function       Set Condition

          CSETALTE()     SET ALTERNATE ON/OFF
          CSETBELL()     SET BELL ON/OFF
          CSETCARR()     SET CARRY ON/OFF (See note)
          CSetCent()     SET CENTURY ON/OFF
          CSETCONF()     SET CONFIRM ON/OFF
          CSETCONS()     SET CONSOLE ON/OFF
          CSetCurs()     SET CURSOR ON/OFF
          CSETDELE()     SET DELETED ON/OFF
          CSETDELI()     SET DELIMITERS ON/OFF
          CSETDEVI()     SET DEVICE TO PRINT (.T.)/SCREEN (.F.)
          CSETESCA()     SET ESCAPE ON/OFF
          CSETEXAC()     SET EXACT ON/OFF
          CSETEXCL()     SET EXCLUSIVE ON/OFF
          CSETFIXE()     SET FIXED ON/OFF
          CSETTINTE()    SET INTENSITY ON/OFF
          CSETPRIN()     SET PRINT ON/OFF
          CSETSCOR()     SET SCOREBOARD ON/OFF
          CSETSOFT()     SET SOFTSEEK ON/OFF
          CSETUNIQ()     SET UNIQUE ON/OFF
          CSETWRAP()     SET WRAP ON/OFF
         </table>

   $NOTES$
      ■  CSETCARR() is not useful in CA-Clipper.  Since this function
         was in CA-Clipper Tools and also occupies a position in CSETALL(), it
         is retained for compatibility purposes.

   $EXAMPLES$
      ■  Switch SET UNIQUE on:

         ? CSETUNIQ(.T.)         // Returns previous setting

      ■  Save a setting:

         lOldWRAP:= CSETWRAP()

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSETALL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ISDEBUG()
   $ONELINER$
      Determines if the debugger is available in the application
   $SYNTAX$
      ISDEBUG() --> lDebugger

   $RETURNS$
      ISDEBUG() returns a value that signifies if the CA-Clipper debugger is
      available.

   $DESCRIPTION$
      This function determines if the debugger is available in an application.
      This enables a program to acknowledge this special situation and then
      conditionally execute or ignore portions of the program.

   $NOTES$
      ■  This is not a CA-Clipper switch.  This information is provided
         by CA-Clipper Tools.

   $EXAMPLES$
      Indicate if the debugger is active:

      IF ISDEBUG()
         ? "The debugger is being used!"
      ENDIF

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KSetCaps()
   $ONELINER$
      Queries/sets the system setting for CAPS LOCK
   $SYNTAX$
      KSetCaps([<lNewSwitch>]) --> lOldSwitch

   $ARGUMENTS$
      <lNewSwitch>  Designates "CAPS LOCK" as on (.T.) or off (.F.).  The
      default value is the system setting.

   $RETURNS$
      KSetCaps() returns the current setting for CAPS LOCK when no parameter
      is specified; otherwise, it returns the previous setting.

   $DESCRIPTION$
      KSetCaps() returns the current system setting for CAPS LOCK.  If the
      <lNewSwitch> is specified, CAPS LOCK is set accordingly.

   $EXAMPLES$
      ■  Query the CAPSLOCK function:

         lCaps:= KSetCaps()

      ■  Switch on CAPSLOCK and save the previous status:

         lOldCaps:= KSetCaps(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      KSetIns(), KSetNum(), KSetScroll()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KSetIns()
   $ONELINER$
      Queries/sets the system setting for "INSERT"
   $SYNTAX$
      KSetIns([<lNewSwitch>]) --> lOldSwitch

   $ARGUMENTS$
      <lNewSwitch>  Designates whether INSERT is on (.T.) or off (.F.).
      The default value is the system setting.

   $RETURNS$
      KSetIns() returns the current setting for INSERT when no parameter is
      specified; otherwise, it returns the previous setting.

   $DESCRIPTION$
      KSetIns() returns the current system setting for INSERT.  If the
      <lNewSwitch> is specified; INSERT is set accordingly.

   $EXAMPLES$
      ■  Query the INSERT function:

         lInsert: = KSetIns()

      ■  Switch on INSERT and save the previous status:

         lOldInsert: = KSetIns(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      KSetCaps(), KSetNum(), KSetScroll()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KSetNum()
   $ONELINER$
      Queries/sets the system setting for NUMLOCK
   $SYNTAX$
      KSetNum([<lNewSwitch>]) --> lOldSwitch

   $ARGUMENTS$
      <lNewSwitch>  Designates whether "NUM LOCK" is on (.T.) or off
      (.F.).  The default value is the system setting.

   $RETURNS$
      KSetNum() returns the current setting for NUM LOCK when no parameter is
      specified; otherwise, it returns the previous setting.

   $DESCRIPTION$
      KSetNum() returns the current system setting for NUM LOCK.  If the
      <lNewSwitch> is specified, NUM LOCK is set accordingly.

   $EXAMPLES$
      ■  Query the NUMLOCK function:

         lNumLock: = KSetNum()

      ■  Switch on NUMLOCK and save the previous status:

         lOldNumLock: = KSetNum(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      KSetIns(), KSetCaps(), KSetScroll()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KSetScroll()
   $ONELINER$
      Queries/sets the system setting for SCROLL LOCK
   $SYNTAX$
      KSetScroll([<lNewSwitch>]) --> lOldSwitch

   $ARGUMENTS$
      <lNewSwitch>  Designates whether "SCROLL LOCK" is on (.T.) or off
      (.F.).  The default value is the system setting.

   $RETURNS$
      KSetScroll() returns the current setting for SCROLL LOCK when no
      parameter is specified; otherwise, it returns the previous setting.

   $DESCRIPTION$
      KSetScroll() returns the current system setting for SCROLL LOCK.  If the
      <lNewSwitch> is specified, SCROLL LOCK is set accordingly.

   $NOTES$
      ■  This function turns the interactive movement mode for windows
         on or off.

   $EXAMPLES$
      ■  Query the SCROLL LOCK function:

         Scroll: = KSetScroll()

      ■  Switch on SCROLL LOCK and save the previous status:

         OldScroll: = KSetScroll(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      KSetIns(), KSetCaps(), KSetNum()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      LASTKFUNC()
   $ONELINER$
      Returns the function name that created the most-recent key trap
   $SYNTAX$
      LASTKFUNC() --> cFunctionName

   $RETURNS$
      LASTKFUNC() returns the function name (KeyTime(), KeySec(), or
      com_Key()) that placed the character in the keyboard buffer.

   $DESCRIPTION$
      This function determines if a key code was placed in the keyboard buffer
      by KeyTime(), KeySec(), or com_Key().

   $NOTES$
      ■  If a trap is created by com_Key(), the last character of the
         function name that is returned, is a number that corresponds to the
         port that triggered an interrupt.

   $EXAMPLES$
      Name the function that created the last error:

      cTrapFunc: = LASTKFUNC()
      IF cTrapFunc = "COM_KEY"
         ? "Interrupt via port", Right(cTrapFunc, 1)
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      LASTKLINE(), LASTKPROC(), KeyTime(), KeySec(), com_Key()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      LASTKLINE()
   $ONELINER$
      Returns the line number of the most-recent key trap
   $SYNTAX$
      LASTKLINE() --> nLineNumber

   $RETURNS$
      LASTKLINE() returns a source code line number.

   $DESCRIPTION$
      This function notes the program lines where KeyTime(), KeySec(),
      com_Key(), or com_SKey() placed a key code in the keyboard buffer.  With
      CA-Clipper, key traps only become active when a wait state is triggered.
      This function differs from the CA-Clipper ProcLine() function because it
      returns the line number where the respective result occurs, rather than
      the line of the input command that triggered the trap.

   $NOTES$
      ■  LASTKLINE() returns a value, only if the program compiles
         without the compiler switch value of -l (suppress line number
         information).

      ■  The function returns a value of 0 when the executed line is in
         CA-Clipper Tools, the external function, or -1 option.

   $EXAMPLES$
      Return the line number of the last key trap:

      ? "Trap by", LASTKFUNC(), "in line", LASTKLINE()

   $PLATFORMS$
      DOS
   $SEEALSO$
      LASTKFUNC(), LASTKPROC(), KeyTime(), KeySec(), com_Key()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      LASTKPROC()
   $ONELINER$
      Returns the procedure name that was interrupted
   $SYNTAX$
      LASTKPROC() --> cProcedureName

   $RETURNS$
      LASTKPROC() returns the name of the procedure or function (KeyTime(),
      KeySec(), com_Key(), or com_SKey()) that places a character in the
      keyboard buffer when executed.

   $DESCRIPTION$
      CA-Clipper Tools notices when other procedures or functions encounter an
      interrupt.  LASTKPROC() does not return the procedure name triggered by
      an input field key trap (as with GET..READ); instead, it returns the
      procedure name that was interrupted.

   $NOTES$
      ■  This function also returns the names of user-defined functions
         (UDFs).

   $EXAMPLES$
      Return the procedure name that was interrupted:

      IF LASTKPROC() = "INPUT"
         * Note to user
         @ 24, 30 SAY "One moment please!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      LASTKFUNC(), LASTKLINE(), KeyTime(), KeySec(), com_Key()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NUMFKEY()
   $ONELINER$
      Determines the number of function keys
   $SYNTAX$
      NUMFKEY() --> nTotalKeys

   $RETURNS$
      NUMFKEY() returns a value that corresponds to the number of available
      function keys.

   $DESCRIPTION$
      NUMFKEY() returns the number of function keys to use with SET FUNCTION
      nn TO.

   $NOTES$
      ■  A value returned by NUMFKEY() is set to 40, both in CA-Clipper
         IBM driver and the CA-Clipper Tools Extended Drivers.  This does not
         change when you have an extended keyboard with 12 function keys.

   $EXAMPLES$
      Display all the function key assignments:

      FOR nI = 1 TO NUMFKEY()
         ? CSETFUNC(nI)
      NEXT

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSETFUNC()*
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetLastKey()
   $ONELINER$
      Sets the value for LastKey()
   $SYNTAX$
      SetLastKey(<nKeyValue>) --> cNull

   $ARGUMENTS$
      <nKeyValue> Designates the character code passed to LastKey().

   $RETURNS$
      SetLastKey() always returns a null string.

   $DESCRIPTION$
      SetLastKey() changes the contents of the memory area used by LastKey().
      This allows you to save the current contents of the LastKey() buffer in
      an error trap and restore it when you return to the program.

   $EXAMPLES$
      Save the last key value so it can be changed and restored later:

      nCharacter: = LastKey()        // Save character code   *...   *...
      SetLastKey(nCharacter)         //  Reset LASTKEY

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      System Informations
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      The functions in this chapter provide system information about the
      operating system (MS-DOS), the BIOS, and hardware.  It determines a
      large number of system facts and settings -- from the DOS-COUNTRY
      setting to the mathematical coprocessor.  It is even possible to warm or
      cold boot a computer from within a program.  In addition, you can query
      and set  DOS VERIFY and BREAK.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      BIOSDATE()
   $ONELINER$
      Determines the system BIOS date
   $SYNTAX$
      BIOSDATE() --> dBIOSdate

   $RETURNS$
      BIOSDATE() returns the ROM BIOS date.

   $DESCRIPTION$
      As a rule, all industry-standard PC's insert a generated date at a
      particular memory location in the BIOS.  Based on this date,
      incompatibilities known to exist up to a particular release can be
      acknowledged.  The function returns a date-type value and spares you an
      elaborate PEEK.

   $NOTES$
      ■  Although unlikely, you may not find a date at this BIOS
         position.  Therefore, you should test to see if a date is returned.

   $EXAMPLES$
      Is this an older computer?

      IF BIOSDATE() < CToD("01/01/85")
         ? "Older version ...!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      PCType(), CPUType()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      BOOTCOLD()
   $ONELINER$
      Triggers a cold boot
   $SYNTAX$
      BOOTCOLD()

   $DESCRIPTION$
      BOOTCOLD() allows you to restart the system after a critical error
      (assuming anything is still working), or to allow any program changes
      you have made in CONFIG.SYS or AUTOEXEC.BAT to take effect.  The
      function calls for a cold start.  This means a RAM check and POST (power
      on self test) are carried out.

   $NOTES$
      ■  Close all files prior to a boot.  You can use CLOSE DATABASES.

      ■  If there is a large system memory, a RAM check takes a long
         time.  To avoid this lengthy procedure, you might consider using the
         BOOTWARM() function for a restart after changing CONFIG.SYS.

   $EXAMPLES$
      An error in an error trap can no longer be changed:

      CLOSE DATABASES
      BOOTCOLD()

   $PLATFORMS$
      DOS
   $SEEALSO$
      BOOTWARM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      BOOTWARM()
   $ONELINER$
      Triggers a warm start of the system
   $SYNTAX$
      BOOTWARM()

   $DESCRIPTION$
      This function allows changes in CONFIG.SYS or AUTOEXEC.BAT to become
      effective.  This function restarts the system just like BOOTCOLD(), but
      no RAM check or POST (power on self test) are carried out.

   $NOTES$
      ■  Close all files before you boot.  You can use CLOSE DATABASES
         to do this.

      ■  BOOTWARM() is the same as pressing the Ctrl-Alt-Del keys.

   $EXAMPLES$
      A new CONFIG.SYS is created within the program and the system reboots:

      COPY TO CONFIG.SYS SDF
      CLOSE DATABASES
      BOOTWARM()

   $PLATFORMS$
      DOS
   $SEEALSO$
      BOOTCOLD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CPUType()
   $ONELINER$
      Determines what type of microprocessor in use
   $SYNTAX$
      CPUType() --> nCPUType

   $RETURNS$
      CPUType() returns a numeric code that identifies the microprocessor in
      use.

   $DESCRIPTION$
      This function determines which microprocessor is in use.  For instance,
      a PC may use a Vnn microprocessor or an AT may use a 386 microprocessor.
      The microprocessors have the following codes:

      Table 12-1: Microprocessor Coding
      <table>
          Value   Symb. constant    Processor

          0       CPU_8088          8088
          1       CPU_8086          8086
          2       CPU_V20           V20
          3       CPU_V30           V30
          4       CPU_80188         80188
          5       CPU_80186         80186
          6       CPU_80286         80286
          7       CPU_80386         80386
          8       CPU_80486         80486
         </table>

   $EXAMPLES$
      What type of microprocessor is on the AT?

      IF CPUType() == CPU_80386
         ? "A 386 ..."
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      PCType(), SPEED()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DosParam()
   $ONELINER$
      Retrieves the DOS command line as a string
   $SYNTAX$
      DosParam() --> cDOSCommandLine

   $RETURNS$
      DosParam() returns the parameters from the DOS command line.

   $DESCRIPTION$
      DosParam() returns all the parameters passed from the DOS command when
      you run the application.  Use DosParam() when you do not want the
      parameters to be separated.  With this function, it is no longer
      necessary to check each individual parameter in a loop.

   $NOTES$
      ■  With the TOKEN() function, it is easy to break down the
         returned character string.  It can also use your own rules.

   $EXAMPLES$
      Given the DOS command line C>MyApp A: C: /a ,
      the following is true:

      DosParam()                // "A: C: /a"
      TOKEN(DosParam())         // "A"

      This way, it is easy to break down parameter lines according to your own
      rules.

   $PLATFORMS$
      DOS
   $SEEALSO$
      TOKEN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      EnvParam()
   $ONELINER$
      Reads the entire DOS environment table into a string
   $SYNTAX$
      EnvParam() --> cEnvironment

   $RETURNS$
      EnvParam() returns a string that corresponds to the complete environment
      table.

   $DESCRIPTION$
      This function returns the entire DOS environment table.  The DOS Chr(0)
      delimiter, which follows each variable and its setting, is replaced with
      CR/LF.  This allows the returned string to work well with the CA-Clipper
      Tools string functions (especially the tokenizer).

   $NOTES$
      ■  With the CA-Clipper function GetEnv(), you can query
         individual parameters from the environment.  Initially, this may seem
         convenient, but there is a problem because no blanks are allowed
         before and after the '='.

   $EXAMPLES$
      Read in the environment and analyze it:

      cVar  :=  EnvParam()                           // CR/LF as delimiter
      TOKENINIT (@cVar, Chr(13) + Chr(10),2)         // CR/LF as delimiter,
      skip 2
      DO WHILE .NOT. TokenEnd()
         Env  :=  TokenNext(cVar)
         ? Env
      ENDDO

   $PLATFORMS$
      DOS
   $SEEALSO$
      TokenInit(), TokenNext()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ERRORACT()
   $ONELINER$
      Recommends an action for a DOS error that has occurred previously
   $SYNTAX$
      ERRORACT() --> nActionCode

      Warning!  This function requires DOS 3.1 or higher.

   $RETURNS$
      ERRORACT() returns a numeric code that provides more information on how
      to react to the last DOS error.  Coding is as follows:

      Table 12-2: DOS Error Action Codes
      <table>
          Code    Definition

          1       Try several times, then ask user
          2       Try several times with pauses, then ask user
          3       Ask user for data
          4       Leave program normally
          5       Leave program as soon as possible
          6       Ignore
          7       User should correct error and try again
         </table>

   $DESCRIPTION$
      DOS reacts to errors in several ways.  One of the best known and least
      preferred by programmers is the question:  "(A)bort, (R)etry, (I)gnore".
      ERRORACT() tells you how the application should react to the last DOS
      error that occurred.

   $EXAMPLES$
      Show an error that requires the program to terminate:

      nAction  :=  ERRORACT()
      IF nAction = 4
         ? "Unfortunately, the program must be terminated!"
         QUIT
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      ERRORBASE(), ERRORCODE(), ERRORORG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ERRORBASE()
   $ONELINER$
      Source of the most-recent DOS error
   $SYNTAX$
      ERRORBASE() --> nErrorCode

      Warning!  This function requires DOS 3.1 or higher.

   $RETURNS$
      ERRORBASE() returns a numeric code that provides additional information
      about the cause of the error.  These codes and their definitions are in
      the table below:

      Table 12-3: Causes for DOS Errors
      <table>
          Code      Definition

          1         Insufficient memory
          2         Access temporarily denied
          3         No access for this user
          4         Internal error, system software
          5         Hardware error
          6         Error in system software
          7         Error in applications program
          8         File not found
          9         Wrong file format or type
          10        File is protected
          11        Incorrect medium in drive
          12        Other error
         </table>

   $DESCRIPTION$
      If an error is detected with ERRORCODE(), use ERRORBASE() for more
      information about the cause of the error, from within the data returned
      by DOS.

   $EXAMPLES$
      Determine the cause for an error:

      nCause  :=  ERRORBASE()
      IF nCause = 3
         ? "Access denied!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      ERRORACT(), ERRORCODE(), ERRORORG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ERRORCODE()
   $ONELINER$
      Identifies a DOS error that has occurred previously
   $SYNTAX$
      ERRORCODE([<lKeep>]) --> nDosErrorCode

      Warning!  This function requires DOS 3.1 or higher.

   $ARGUMENTS$
      <lKeep>  When this parameter is designated as .T., the function
      returns the internal error code memory value.

   $RETURNS$
      ERRORCODE() returns a value that represents the error code that occurred
      during the most-recently executed DOS function.

   $DESCRIPTION$
      If you do not specify a parameter or if the parameter is .F., then
      ERRORCODE() calls the DOS error function (INT 21h, 59h) and returns the
      code value stored for the most-recent error.  DOS stores the most-recent
      error code until a new error occurs.  If your operation is error free,
      this value is not  reset.

      To take this situation into account, ERRORCODE() can alternatively be
      called with <lkeep> set to .T..  If called like this, the error code
      always relates to the last CA-Clipper Tools function that was executed.
      Since the respective CA-Clipper Tools function behavior is stored at an
      internal memory location, it is impossible to implement this option with
      regular CA-Clipper functions.

   $NOTES$
      ■  You can find a table that contains all the error codes in
         Appendix B:  Error Codes.

   $EXAMPLES$
      ■  This example attempts to copy a file.  If an error occurs,
         FileCopy() returns a value of 0 which offers no specific error
         information:

         nBytes  :=  FileCopy("TEST\TEST.PRG", "NEW.PRG")
         IF nBytes = 0 .AND. ERRORCODE() = 3
            ? "File path not found!"
         ENDIF

      ■  An example of two file copies is illustrated below:

        The first file is unsuccessful, but the second file is not:

         FileCopy("XXXXX.TXT", "YYYY.TXT")
         ? ERRORCODE(.T.)                  // 2 - File not found
         ? ERRORCODE()                     // 2 - File not found
         FileCopy("SOURCE.TXT", "TARGET.TXT")
         ? ERRORCODE(.T.)                  // 0 - Last Tools
                                           // function was successful
         ? ERRORCODE()                     // 2 - File not found

      Warning!  Any CA-Clipper Tools function that contains a DOS call
      resets the internal variable retrieved by setting <lKeep> .  The
      following call series never returns the desired result, because the
      first call of ERRORCODE() contains a DOS call:

      ? ERRORCODE(), ERRORCODE(.T.)        // Result: x, 0

   $PLATFORMS$
      DOS
   $SEEALSO$
      ERRORACT(), ERRORBASE(), ERRORORG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ERRORORG()
   $ONELINER$
      Origin of the most-recent DOS error
   $SYNTAX$
      ERRORORG() --> nError

      Warning!  This function requires DOS 3.1 or higher.

   $RETURNS$
      ERRORORG() returns a numeric code that provides more information about
      the device on which the error occurred.  The table below details this
      information:

      Table 12-4: Origin of DOS Errors
      <table>
          Code    Definition

          1       Unknown
          2       Block device (floppy, hard disk, etc.)
          3       Network
          4       Character device (COM, SCRN, etc.)
          5       RAM
         </table>

   $DESCRIPTION$
      ERRORORG() tells what type of device generated the most-recent DOS
      error.  This essential information allows you to handle the error in an
      appropriate way.

   $EXAMPLES$
      Determine the source of an error:

      nSource  :=  ERRORORG()
      IF nSource = 3
         ? "Error is on the network!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      ERRORACT(), ERRORCODE(), ERRORBASE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ExeName()
   $ONELINER$
      Returns name and directory of the current CA-Clipper program
   $SYNTAX$
      ExeName() --> cProgram

   $RETURNS$
      ExeName() returns the name and path of the current .EXE program.

   $DESCRIPTION$
      This function determines the name and path of the CA-Clipper application
      in use.

   $NOTES$
      ■  Use the TOKEN() function to determine the name portion of a
         program within a path.

   $EXAMPLES$
      Determine if the name or path of an EXE file has changed:

      cOrigPath  :=  "C:\DATA\ADDRESS.EXE"
      IF ExecName() <> cOrigPath
         ? "Program name or directory have been changed!"
         QUIT
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      TOKEN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FILESFREE()
   $ONELINER$
      Specifies the number of files you can open
   $SYNTAX$
      FILESFREE() --> nFreeHandles

   $RETURNS$
      FILESFREE() returns the number of available handles.

   $DESCRIPTION$
      This function returns the number of available handles that correspond to
      the number of files you can open.  This enables you to avoid DOS error
      4.

   $NOTES$
      ■  Immediately after you start a CA-Clipper application, a value
         -- smaller than that of FileSMax() -- is returned.  This happens
         because the operating system and application itself is already using
         handles.

   $EXAMPLES$
      ■  Can I still open a file?

         IF FILESFREE() > 0                // At least 1 handle free?
            USE CUSTOMER                   // Open a file
         ENDIF

      ■  Be careful when you open multiple indexes at the same time!

         IF FILESFREE() > 1                // At least 2 handles free?
            USE CUSTOMER INDEX CUSTNR      // Open 2 files
         ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      FileSMax()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FileSMax()
   $ONELINER$
      Specifies the maximum number of files that can be open at one time
   $SYNTAX$
      FileSMax() --> nMaxHandles

   $RETURNS$
      FileSMax() returns the maximum number of files that can be open at once.

   $DESCRIPTION$
      The value set for FILES= within the CONFIG.SYS, and the number of
      available handles, influences the maximum number of files that can be
      open simultaneously.  The maximum number is determined by the smaller of
      the two values respectively.

   $NOTES$
      ■  The returned value is subtracted from the handles already
         occupied by the operating system.  This value is usually 5.

      ■  This function cannot determine if an additional operating
         system adaptation (Novell's SHELL.CFG) has been made under a Novell
         network.  These adaptations are only used for the current network
         drive under Novell.

   $EXAMPLES$
      How many files can be opened in the system?

      ? FileSMax()            // e.g. 100

   $PLATFORMS$
      DOS
   $SEEALSO$
      FILESFREE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETCOUNTRY()
   $ONELINER$
      Queries country setting for the operating system
   $SYNTAX$
      GETCOUNTRY() --> nDosCountryCode

      Warning!  This function requires DOS 3.1 or higher.

   $RETURNS$
      GETCOUNTRY() returns the current DOS country code setting.

   $DESCRIPTION$
      GETCOUNTRY() returns an integer that gives the current
      DOS COUNTRY code setting.  Returns a number that corresponds to the
      value set within CONFIG.SYS.

   $NOTES$
      ■  You can find a table of country codes in the section of the
         DOS manual that describes CONFIG.SYS construction.

   $EXAMPLES$
      Query the country code:

      CountryCode  :=  GETCOUNTRY()
      IF CountryCode = 49
         ? "The country code for Germany has been set!"
      ENDIF

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ISANSI()
   $ONELINER$
      Tests to see if the ANSI screen driver is installed
   $SYNTAX$
      ISANSI() --> lInstalledDriver

   $RETURNS$
      ISANSI() returns .T. when ANSI.SYS or a comparable driver has been
      loaded from CONFIG.SYS.

   $DESCRIPTION$
      ISANSI() determines if ANSI.SYS or another comparable driver has been
      loaded from CONFIG.SYS.  Some full-page displays require the ANSI
      driver.  If the driver is present, the display is fully operational.

   $NOTES$
      Warning!  You must implement DSETWINDOW(.F.) for ISANSI() to return
      a correct result.

   $EXAMPLES$
      If ANSI.SYS is present, output through DOS.  This allows a simple
      terminal emulation:

      IF ISANSI()                  // ANSI driver present?
         com_DosCon(dDate)         // Output via DOS
      ELSE
         *...                      // Individual ANSI handling
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      com_DosCon(), DSETWINDOW()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsAt()
   $ONELINER$
      Determines if a program is running on an AT
   $SYNTAX$
      IsAt() --> AT

   $RETURNS$
      IsAt() returns .T. value when the program is running on an
      AT-compatible system.

   $DESCRIPTION$
      IsAt() determines if your CA-Clipper application is running on an
      AT-class system.

   $NOTES$
      ■  The function also returns .T. for systems with an 80386 or
         80486 processor.

   $EXAMPLES$
      Since you can set the hardware clock on an AT (in contrast to an XT),
      use IsAt() to determine if SetDate() and SetTime() function properly:

      IF IsAt()
         ? "The internal clock can be changed."
      ELSE
         ? "Time and date will be lost after booting!"
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetDate(), SetTime()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IsMath()
   $ONELINER$
      Determines if a math coprocessor is installed
   $SYNTAX$
      IsMath() --> lCoprocessor

   $RETURNS$
      IsMath() returns .T. value when a math coprocessor is installed in the
      system.

   $DESCRIPTION$
      IsMath() determines if a math coprocessor is available to your CA-
      Clipper application.

   $EXAMPLES$
      Determine if a math coprocessor is available to the application:

      IF IsMath()
         ? "Coprocessor available."
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      CPUType()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      MEMSIZE()
   $ONELINER$
      Determines size of conventional or extended memory
   $SYNTAX$
      MEMSIZE([<lMode>]) --> nMemSize

   $ARGUMENTS$
      <lMode>  Designates whether you want to determine the size of the
      conventional memory (.F.) or extended memory (.T.).  The default value
      is conventional memory (.F.).

   $RETURNS$
      MEMSIZE() returns the size (in kBytes) of the designated memory type.

   $DESCRIPTION$
      MEMSIZE() determines how much working memory is available on your
      system.  It determines either the size of the conventional memory
      (0 to 640k) or extended memory (above 1 MB).

   $NOTES$
      ■  This function returns a value determined through the BIOS
         (which assumes compatibility).

   $EXAMPLES$
      ■  Show size of conventional memory:

         ? MEMSIZE()            // e.g. 512
         ? MEMSIZE(.F.)

      ■  Show size of extended memory:

         ? MEMSIZE()            // e.g. 384

   $PLATFORMS$
      DOS
   $SEEALSO$
      AlloFree()*
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NUMBUFFERS()
   $ONELINER$
      Determines the BUFFERS= setting
   $SYNTAX$
      NUMBUFFERS() --> nNumberBuffers

   $RETURNS$
      NUMBUFFERS() returns the number of buffers that are set in CONFIG.SYS
      (BUFFERS=nn).

   $DESCRIPTION$
      NUMBUFFERS() determines the BUFFERS setting in the CONFIG.SYS file.

   $NOTES$
      ■  The information is not read from the CONFIG.SYS file, but
         determined from an internal DOS table.  Therefore, the buffers
         setting in CONFIG.SYS may not contain the same value as numbuffers,
         if it has been changed since that most-recent system boot.

   $EXAMPLES$
      Query the BUFFERS setting:

      ? NUMBUFFERS()

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETCOUNTRY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NUMFILES()
   $ONELINER$
      Determines the maximum number of files you can open simultaneously
   $SYNTAX$
      NUMFILES() --> nNumber

   $RETURNS$
      NUMFILES() returns the maximum number of files you can open
      simultaneously in all active programs.

   $DESCRIPTION$
      NUMFILES() determines the number of files that can be open
      simultaneously under DOS.  This information corresponds to the FILES=
      setting in the CONFIG.SYS file.  However, it is read from an internal
      DOS table, not this file.  Therefore, the function operates with or
      without CONFIG.SYS, and returns more accurate system information.

   $NOTES$
      ■  The function cannot determine if an additional operating
         system adaptation (Novell's SHELL.CFG) has been made under a Novell.
         network.  These adaptations are only used for the current network
         drive under Novell.

   $EXAMPLES$
      Display the maximum number of files you can open:

      ? NUMFILES()         // e.g. 30

   $PLATFORMS$
      DOS
   $SEEALSO$
      NUMBUFFERS(), FileSMax(), FILESFREE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      OSVER()
   $ONELINER$
      Returns the DOS version number
   $SYNTAX$
      OSVER() --> cDosVersion

   $RETURNS$
      OSVER() returns a character string that contains the version number of
      the operating system in use.

   $DESCRIPTION$
      OSVER() returns the version number of the operating system in use.  The
      format picture clause is always "'9.99".  Use OSVER() to determine the
      DOS version your application uses.

   $EXAMPLES$
      Certain operations require particular DOS versions:

      IF OSVER() < "3.30"
         ? "COMMIT can not be used!"
      ENDIF

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PCType()
   $ONELINER$
      Returns the type of computer in use
   $SYNTAX$
      PCType() --> nPCType

   $RETURNS$
      PCType() returns a numeric code to identify the type of computer.

   $DESCRIPTION$
      This function differentiates between the different types of PC's.  The
      function determines the type of computer installed in the application
      The following codes apply:

      Table 12-5: Computer Type Coding
      <table>
          Value     Symb. constants   PC-Type

          255       PC_NORMAL         Normal PC
          254       PC_XT             PC-XT (w/hard disk)
          253       PC_JUNIOR         PC jr
          240       PC_MODEL30        Model 30
          251       PC_XT_2           XT/2
          249       PC_LAPTOP         Laptop
          252       PC_AT             AT/XT-286/Model 50/Model  60
          248       PC_MODEL80        Model 80
          45        PC_COMPAQP        COMPAQ Portable
          154       PC_COMPAQ         COMPAQ Portable Plus
         </table>

   $NOTES$
      ■  386 and 486 computers are often coded as AT's.

      ■  The values correspond to IBM BIOS codes.  An incompatible BIOS
         might return a different value.

   $EXAMPLES$
      What type of computer is installed?

      ? PCType()         // 252  an AT!

   $PLATFORMS$
      DOS
   $SEEALSO$
      CPUType(), SPEED()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SSETBREAK()
   $ONELINER$
      Sets and checks the DOS BREAK switch
   $SYNTAX$
      SSETBREAK([<lNewSwitch>]) --> lOldSwitch

   $ARGUMENTS$
      <lNewSwitch>  Designates the new setting for the DOS BREAK switch.

   $RETURNS$
      SSETBREAK() returns the current BREAK setting when no parameter is
      specified; otherwise, it returns the previous setting.

   $DESCRIPTION$
      Normally, DOS only checks screen and keyboard functions for the
      Ctrl-Break key combination.  If you want to check more frequently
      (i.e., during disk operations), use SSETBREAK() to turn on the BREAK
      switch.

   $NOTES$
      ■  You can also use BREAK= <ON|OFF> to set BREAK in DOS

   $EXAMPLES$
      Activate BREAK and save the old status:

      lOld_Break  :=  SSETBREAK(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      EnvParam()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SSETVERIFY()
   $ONELINER$
      Sets and checks the DOS VERIFY switch
   $SYNTAX$
      SSETVERIFY([<lNewSwitch>]) --> lOldSwitch

   $ARGUMENTS$
      <lNewSwitch>  Designates the new setting for the DOS VERIFY switch.

   $RETURNS$
      SSETVERIFY() returns the current VERIFY setting when no parameter is
      specified; otherwise, it returns the previous setting.

   $DESCRIPTION$
      Normally, DOS does not check to see if copied data arrives at the target
      error free.  The DOS VERIFY switch determines whether to check written
      data.  Of course, verification takes time.  To be safe, make critical
      copies with the switch set to on (.T.).

   $NOTES$
      ■  You can also use VERIFY= <ON|OFF> to set VERIFY in DOS.

   $EXAMPLES$
      Activate VERIFY and save old status:

      lOld_Verify:= SSETVERIFY(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      EnvParam()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Miscellaneous Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      Functions that do not belong in any other module are assembled in this
      group under the Miscellaneous heading.  However, this does not imply
      they are less useful.  For example, use KeyTime() or KeySec() to
      activate a CA-Clipper procedure at a specific time, after a delay of
      seconds, implement file saves, or control demo programs.

      This module enables you to determine complements, determine data types,
      and query keyboard scan codes.

      b>Passing Parameters by Reference</b>

      Finally, this chapter discusses functions that permit you to pass
      parameters by reference.  To find more information on this subject, see
      Chapter 4, String Manipulations.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      AlloFree()*
   $ONELINER$
      Determines the maximum memory size allocation
   $SYNTAX$
      AlloFree([<lMode>]) --> nFreeMemory

      *  This has been retained in CA-Clipper for compatibility purposes.
         Use the CA-Clipper Memory() function to develop future
         applications.

   $ARGUMENTS$
      <lMode>  If passed as .T., the total available memory size is
      returned.  The default value is the largest contiguous block (.F.).

   $RETURNS$
      AlloFree() returns the maximum possible size for a contiguous memory
      block or the total amount of free memory available.

   $DESCRIPTION$
      Use this function to help avoid "memory fault" error messages.  You can
      implement it in conjunction with other functions that use a string area
      as a buffer (as when you read files).

   $NOTES$
      ■  If there is not enough room on the stack, AlloFree(.T.)
         returns a value of -1.

   $EXAMPLES$
      ■  This is what can happen if you try to print a maximum-length
         string without enough free memory:

         Var  :=  Space(65520)

      ■  Make a string of the maximum-length possible:

         Var  := Space(AlloFree())           // Under no circumstances
                                             // call with .T.!
         ? Len(Var)                          // How long has it become?

      ■  Read in a file...

         FileStr("Bigfile", AlloFree())      // The largest possible buffer

      ■  Entire available memory:

         ? AlloFree(.T.)                     // Available memory

   $PLATFORMS$
      DOS
   $SEEALSO$
      STACKFREE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Blank()
   $ONELINER$
      Creates a blank value for each data type
   $SYNTAX$
      Blank([<expValue>], [<lMode>]) --> xBlank

   $ARGUMENTS$
      <expValue>[@]  Designates any valid expression; the type is not
      important.

      <lMode>  Designates whether or not the length of the <expValue> is
      to change in the event that <expValue> is a string.  If .T. is
      designated, the length is retained.  The default value is Change Length
      (.F.).

   $RETURNS$
      Blank() returns a blank value with the same data type as the <expValue>
      parameter.

   $DESCRIPTION$
      Blank() clears desired data fields with the variables.  Blank() returns
      the following results:

      Table 13-1: Data Type Blank Values
      <table>
          Argument            Returned Value

          Character string    Null string or blank string
          Numeric             Value of 0
          Logical             .F.
          Date                A blank date
         </table>

      The default for <lMode> is .F. and produces a null string when a
      character string is input.  However, if this parameter is designated as
      .T.., the string length is not changed.

   $NOTES$
      ■  SET DATE has no affect on how Blank() handles a date.  The
         blank date display is created in the format you select.

      ■  You can suppress the value this function returns by
         manipulating strings through CSetRef() implementation.  To save room
         in the working memory, designate <lMode> as .T..

   $EXAMPLES$
      Display blank values for data-type values:

      SET DATE AMERICAN
      ? Blank(Date())          // "  /  /  "
      ? Blank()                // .F.
      ? Blank(.T.)             // .F.
      ? Blank(99)              //  0
      ? Blank("abc")           // ""
      ? Blank("11:59:59")      // ""
      ? Blank("abc", .T.)      // "  " Blank string

   $PLATFORMS$
      DOS
   $SEEALSO$
      CSetRef()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Complement()
   $ONELINER$
      Forms the complement value of a data type
   $SYNTAX$
      Complement(<expValue>) --> xComplement

   $ARGUMENTS$
      <expValue>[@]  Designates any valid expression of any data type to
      form a complement value.  Complement() only allows a character string to
      be passed by reference.

   $RETURNS$
      Complement() returns the complement value that corresponds to the same
      data type for <expValue>.

   $DESCRIPTION$
      Complement() returns the respective opposite value of the <expValue>
      parameter.  In contrast to CharNot(), which only permits character
      strings, this function permits all data types.  The result is the same
      data type as the parameter.  For example, a date returns a date as a
      result.  It corresponds to the difference between the indicated date and
      12/31/2999.

   $NOTES$
      ■  Complement(Complement(<expValue>)) always returns <expValue>
         as output.

   $EXAMPLES$
      ■  The complement of a logical value corresponds to the use of
         .NOT.:

         ? Complement(.T.)                  // .F.
         ? Complement(.F.)                  // .T.

      ■  Numeric values change sign:

         ? Complement(99)                   // -99.00
         ? Complement(0)                    // 0
         ? Complement(-99)                  // 99.00
         ? Complement(-9.9)                 // 9.90
         ? Complement(9.9)                  // -9.9

      ■  With strings, the function works like CHARNOT:

         ? Complement("123ABCabc")          // "       <157><156>"

      ■  The difference between 1/1/1900 and 01/01/3000:

         SET CENTURY ON
         ? Complement(CToD("01/01/00"))     // 12/31/1099

      ■  An empty or invalid date gives the same result -- 01/01/3000:

         SET CENTURY ON
         ? Complement(CToD("  /  /  "))     // 01/01/3000
         ? Complement(CToD("77/77/77"))     // 01/01/3000

   $PLATFORMS$
      DOS
   $SEEALSO$
      Introduction
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DATATYPE()*
   $ONELINER$
      Determines the data type of a variable or UDF
   $SYNTAX$
      DATATYPE(<expValue>) --> nDataType

      *  This is retained in CA-Clipper for compatibility purposes.  Use the
         CA-Clipper ValType() function to develop future applications.

   $ARGUMENTS$
      <expValue>  Designates any valid CA-Clipper expression.

   $RETURNS$
      DATATYPE() returns a value that corresponds to the data type in
      <expValue>.

   $DESCRIPTION$
      DATATYPE() is similar to the CA-Clipper Type() function, but returns
      more extensive information in numeric value form.  The bits in the
      result correspond to specific data types.  Two bits can be set at the
      same time.  It is easy to recognize specific data types with the IsBit()
      function.  The following codes apply:

      Table 13-2: Data Type Coding
      <table>
          Value   Symb. Const.   Data Type

           0      TYPE_UNDEF     Undefined
           1      TYPE_STR       Character string
           2      TYPE_NUM       Numeric
           4      TYPE_LOG       Logical
           8      TYPE_DATE      Date
          16      TYPE_ALIAS     Alias
          64      TYPE_MEMO      Memo field
          128     TYPE_WORD      Word
          512     TYPE_ARRAY     Array
          4096    TYPE_BLOCK     Code block
         </table>

      In addition, DATATYPE() returns the respective data type for a
      CA-Clipper Tools function or one of your own UDF's.  This is impossible
      with Type().

   $NOTES$
      ■  An invalid <expValue> output results in a runtime error.

      ■  The function cannot determine if a parameter has passed to a
         function by reference (32 + type), because this information is no
         longer available in CA-Clipper.

   $EXAMPLES$
      Return values of DATATYPES() used for different data types:

      ? DATATYPE()                 //    0, undefined
      ? DATATYPE("XXX")            //    1, string
      ? DATATYPE(123)              //    2, numeric
      ? DATATYPE(DoY())            //    2, numeric result
      ? DATATYPE(.T.)              //    4, logical
      ? DATATYPE(3 > 2)            //    4, logical expression
      ? DATATYPE(Eof())            //    4, logical result
      ? DATATYPE(Date())           //    8, date
      ? DATATYPE(memofld)          //    1, memo field
      ? DATATYPE(@crlf)            //   33, reference to string
      ? DATATYPE(@array)           //  544, reference to array
      ? DATATYPE(array[1])         //    2, numeric element
      ? DATATYPE(array[2])         //    1, string element
      ? DATATYPE(myfunc())         //       type for your own UDF

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GETTIC()
   $ONELINER$
      Determines the number of timer ticks
   $SYNTAX$
      GETTIC() --> nTickCount

   $RETURNS$
      GETTIC() returns the number of timer ticks executed since the last
      SETTIC (.T.).

   $DESCRIPTION$
      Use this function in conjunction with SETTIC().  At any given time, it
      returns the number of completed timer ticks since the timer was set in
      motion (by calling SETTIC(.T.)).

   $EXAMPLES$
      An individual UDF is to be measured in ticks.  The tick rate counter is
      started with the SETTIC(.T.) call, then stopped after execution of the
      UDF (by passing .F. to SETTIC()) and the number of completed ticks is
      queried:

      SETTIC(.T.)
         MY_UDF(I)
      SETTIC(.F.)
      ? " Required ticks:", GETTIC()

   $PLATFORMS$
      DOS
   $SEEALSO$
      SETTIC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KBDDISABLE()
   $ONELINER$
      Locks/unlocks the keyboard
   $SYNTAX$
      KBDDISABLE(<lSwitch>) --> cNull

   $ARGUMENTS$
      <lSwitch>  Designates whether the keyboard is switched on (.T.) or
      off (.F.).

   $RETURNS$
      KBDDISABLE() always returns a null string.

   $DESCRIPTION$
      With the help of this function, the keyboard can be turned on or off.
      This allows you to prevent any user input for a specific time through
      program control (even Ctrl-Alt-Del).

   $NOTES$
      ■  Be sure the program reenables the keyboard and does not leave
         it locked when the program terminates.

   $EXAMPLES$
      Switch off the keyboard for 5 seconds:

      KBDDISABLE(.F.)        // Turn off keyboard
         Inkey(5)            // Can't be shortened by input!
      KBDDISABLE(.T.)        // Turn on keyboard

   $PLATFORMS$
      DOS
   $SEEALSO$
      KBDTYPE(), KbdStat(), KBDSPEED(), DSetKBIOS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KBDEMULATE()
   $ONELINER$
      Inserts characters into the BIOS keyboard buffer to emulate keyboard input
   $SYNTAX$
      KBDEMULATE(<cListKeyValue>) --> nValue

   $ARGUMENTS$
      <cListKeyValue>  Designates a keyboard input sequence to emulate.
      Use a maximum of 15 characters.

   $RETURNS$
      KBDEMULATE() returns the number of key codes it could not place in the
      BIOS buffer.

   $DESCRIPTION$
      KBDEMULATE() emulates keyboard input at a very low level.  This function
      uses the BIOS input buffer to emulate input.  This emulated input can
      then be used by another program.  For example, you might stuff the next
      DOS command prior to the end of the application.  Keyboard input for
      programs that use RUN() to be called is also feasible.  The buffer
      capacity is a maximum of 15 characters.  Some of the key codes may vary
      from keyboard to keyboard, but they still correspond to the values
      returned by SCANKEY().  Construct the codes as follows:

      Chr(ASCII code) + Chr(Scan code)

      As a rule, a scan code that is transmitted this way cannot be
      acknowledged by CA-Clipper or any subsequent program.  For example, a
      DOS command can be passed as a string with spaces at each even position.
      This emulation of a scan code with a value of 32, would only cause
      problems when a subsequent program also checks the scan code (see
      Examples on the next page).

   $NOTES$
      ■  You can find the symbolic constants for key codes in the
         include file CTSCAN.CH.

      ■  Problems may arise if you have incompatible hardware/BIOS, or
         programs that extend the keyboard buffer.

      ■  Even though these emulated inputs occur at a low level, the
         code translations defined with SetKXLat() still function.

   $EXAMPLES$
      ■  These two programs always call each other reciprocally.
         Before returning to DOS, each program wedges the keys necessary to
         execute the other program in the BIOS buffer:

         Program 1 (PROG1.EXE)
         CLEAR
            @ 10, 10 SAY "Here is program 1  !"
            Inkey(5)                                // Wait a while...
            KBDEMULATE("P R O G 2 " + Chr(13))      // Start PROG2 in DOS
         RETURN

         Program 2 (PROG2.EXE)
         CLEAR
            @ 10, 10 SAY "Here is program 2  !"
            Inkey(5)                                // Wait a while...
            KBDEMULATE("P R O G 1 " + Chr(13))      // Start PROG1 in DOS
         RETURN

      ■  This program returns to DOS and then re-calls itself.  In this
         case, the desired extra byte is created with the Expand() function.
         The last token in the full path is the EXE name which includes the
         file extension.  The first token is the file name:

         xeName  :=  TOKEN(ExeName(), ":\")
         ExeName  :=  TOKEN(ExeName, ".", 1)
         KBDEMULATE(Expand(ExeName + Chr(13)))      // Expansion with blanks
         QUIT

      ■  The correct way to implement Expand():

         * WRONG! No blank before Chr(13)
         KBDEMULATE(Expand("TEST") + Chr(13))
         * RIGHT! Blank before Chr(13)
         KBDEMULATE(Expand("TEST" + Chr(13)))

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumLow(), NumHigh(), SetKXLat(), KEYSEND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KBDSPEED()
   $ONELINER$
      Sets keyboard auto repeat speed
   $SYNTAX$
      KBDSPEED(<nDelay>,<nFrequency>) --> lAmended

      Warning!  Use AT keyboards only.

   $ARGUMENTS$
      <nDelay>  Designates the amount of delay before you begin auto
      repeat.  Possible values are from 0 to 3.  The default value is 1.

      <nFrequency>  Designates the number of times a character repeats per
      second.  Possible values are from 0 to 31.  The default value is 12.

   $RETURNS$
      KBDSPEED() returns .T. when a new repeat rate is set successfully.

   $DESCRIPTION$
      KBDSPEED() sets the auto repeat rate for AT keyboards.  Both the time
      delay and repeat rate for auto repeat can be set.  The table below
      provides the values, their corresponding times, and repeat rates:

      Table 13-3: Auto Repeat Time Delay
      <table>
          <nDelay>     Delay Time

          0            250 millisecond
          1            500 millisecond
          2            750 millisecond
          3            1000 millisecond
         </table>

      Table 13-4: Repeat Rate for Depressed Keys
      <table>
          <nFrequency>     Repeat Rate

          0                30 characters per second
          12               10 characters per second
          31               2 characters per second
         </table>

   $NOTES$
      ■  It is best to determine valid values experimentally.

   $EXAMPLES$
      The quickest setting possible:

      IF KBDTYPE() >0         // Only possible for AT's
         KBDSPEED(0, 0)
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      KBDTYPE(), KbdStat(), KBDDISABLE(), DSetKBIOS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KbdStat()
   $ONELINER$
      Tests for key shift state status, such as Ctrl and Shift
   $SYNTAX$
      KbdStat() --> nKeyStatus

   $RETURNS$
      KbdStat() returns a numeric code that corresponds to the status of
      certain keys.

   $DESCRIPTION$
      This function determines the status of all shift state keys (e.g., Ctrl,
      Shift or Alt, Scroll-Lock or Num-Lock).  The information KDBSTAT()
      returns depends on the keyboard itself.

      Table 13-5: Applies to all Keyboards
      <table>
          Bit     Key

          1       Right shift currently pressed
          2       Left shift currently pressed
          3       Ctrl currently pressed (left or right)
          4       Alt currently pressed (Alt or Shift-Alt)
          5       Scroll-Lock ON/OFF
          6       Num-Lock ON/OFF
          7       Caps-Lock ON/OFF
          8       Insert ON/OFF
         </table>

   $NOTES$
      ■  Since KbdStat() depends on the type of keyboard, use KBDTYPE()
         to determine whether or not the left and right Ctrl or Alt keys are
         valid return values.

   $EXAMPLES$
      This example tests the Alt key.  You could use it to display an
      additional prompt menu when the Alt key is depressed:

      IF IsBit(KBSTAT(), 4)
         * . . .
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      KBDTYPE(), KBDDISABLE(), KBDSPEED()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KBDTYPE()
   $ONELINER$
      Determines the type of keyboard in use
   $SYNTAX$
      KBDTYPE() --> nKeyboardType

   $RETURNS$
      KBDTYPE() returns a value that corresponds to the type of keyboard.

   $DESCRIPTION$
      KBDTYPE() determines the type of keyboard in use.  This lets you check
      if the keyboard has F11/F12 keys available (which the CA-Clipper Tools
      supports).  The possible keyboard values are:

      Table 13-7: Coding of Keyboard Types
      <table>
          Value   Keyboard Type

          0       PC keyboard
          1       AT keyboard
          2       Extended keyboard w/101/102 keys,  F11/F12
         </table>

   $NOTES$
      ■  This function has been thoroughly tested, but there may be
         problems with keyboards that are not fully compatible.

   $EXAMPLES$
      Query the keyboard:

      ? KBDTYPE()         // 2  Extended keyboard

   $PLATFORMS$
      DOS
   $SEEALSO$
      KbdStat(), KBDDISABLE(), KBDSPEED(), DSetKBIOS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KeySec()
   $ONELINER$
      Triggers a key trap after a time delay
   $SYNTAX$
      KeySec([<nKeyValue>,<nTime>, [<nCounter>],
         [<lMode>]]) --> lActivated

   $ARGUMENTS$
      <nKeyValue>  Designates the key code to place in the keyboard
      buffer.

      <nTime>  Designates the time, in seconds, after which the character
      is placed in the buffer.  Negative values correspond to multiples of
      1/18.2 seconds.

      <nCounter>  Designates the number of times the function occurs
      before it uninstalls itself.  A value of -1 indicates that KeySec() will
      continue until it is specifically uninstalled.  The default value is
      "Uninstall after the first call" (1).

      <lMode>  Designates whether the internal time counter restarts at
      the beginning (.T.) or not (.F.), after you press a desired key.  The
      default value is "No new start with key stroke" (.F.).

      ()  When called without parameters, the function is completely
      uninstalled.

   $RETURNS$
      KeySec() returns a value of .T. when installed correctly, so that the
      desired character will be placed in the keyboard buffer after the
      specified time.

   $DESCRIPTION$
      This function is useful in DEMO programs.  If used in conjunction with
      KEYSEND(), you can simulate any keyboard input with time delays.

      Use KeySec() in conjunction with CA-Clipper's SET KEY..TO, for key traps
      (just like KeyTime()).  For example, this makes it possible to
      automatically write data still in the DOS buffer, to the hard drive at
      specific intervals during a GET..READ.

      As soon as the character is placed in the keyboard buffer <nCounter>
      times, KeySec() uninstalls itself.

      If the <lMode> parameter is specified as .T., the elapsed time counter
      is reset when you press any key.

      If you want to specifically uninstall the function from the program,
      call it without parameters.

   $NOTES$
      Warning!  Always uninstall the function before you leave the program
      or use the CTUS.LIB Extended Drivers found in CA-Clipper Tools.  The
      function changes interrupt vectors, and if the previous status is not
      restored before you exit the program, the system will eventually crash.

      ■  Only one time delay can be active.  A new KeySec() deactivates
         the previous one.

      ■  You can use any symbols defined in the CA-Clipper file
         INKEY.CH.  You can set any other keys described in the CA-Clipper
         Tools header file CTSCAN.CH.

   $EXAMPLES$
      ■  Place Chr(7) in the keyboard buffer three times, every 5
         seconds:

         ? KeySec(7, 5, 3)             // (.T.)

      ■  Place Chr(255) in the keyboard buffer every 60 seconds until
         an uninstall occurs:

         ? KeySec(255, 60, -1)         // (.T.)

      ■  As soon as a key is pressed, the internal counter restarts
         from the beginning:

         ? KeySec(13, 60, -1, .T.)     // (.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      KeyTime(), LASTKLINE(), LASTKFUNC(), LASTKPROC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      KeyTime()
   $ONELINER$
      Triggers a key trap at a specific clock time
   $SYNTAX$
      KeyTime([<nKeyValue>,<cClocktime>]) --> lActivated

   $ARGUMENTS$
      <nKeyValue>  Designates the character to place in the keyboard
      buffer.

      <cClocktime>  Designates the specified time to place the character
      in the keyboard buffer.

      ()  When called without parameters, the function completely uninstalls.

   $RETURNS$
      KeyTime() returns a .T. to indicate the specified character was placed
      in the keyboard buffer at the desired time.

   $DESCRIPTION$
      Warning!  Use on AT-class systems only!

      KeyTime() executes a specific program at an indicated time.  To do this,
      the function places the desired key code in the keyboard buffer at the
      selected clock time.  If a procedure is established with
      SET KEY..TO, CA-Clipper calls the procedure if, or when, you are in a
      wait state.  This allows you to perform specific tasks at a particular
      time of day such as file backups.

      There is also a special variant over and above an exact time
      designation.  You can specify "99" for hours, minutes, or seconds, which
      modifies the interpretation of this portion of the time designation.  A
      time string of "10:99:00" instructs the function to trigger a key trap
      every minute between 10:00 and 10:59.

      If you want to specifically uninstall the function from the program,
      call it without specifying parameters.

   $NOTES$
      Warning!  Always uninstall the function before you leave the program
      or use the CTUS.LIB Extended Drivers found in CA-Clipper Tools.  This
      function changes the interrupt vectors, and if the previous status is
      not restored before you leave the program, a system crash will
      eventually occur.

      ■  Only one time monitor can be active at any given time.  A
         subsequent call to KeyTime() deactivates the previous one.

      ■  You can use any symbols defined in the CA-Clipper file
         INKEY.CH.   You can set any other keys described in the CA-Clipper
         Tools header file CTSCAN.CH.

   $EXAMPLES$
      ■  Place key code 7 in the keyboard buffer at 12:30:

         ? KeyTime(7, "12:30:00")      // .T.

      ■  Place key code 255 in the keyboard buffer at 2:00 PM:

         ? KeyTime(255, "2")           // .T.

      ■  Place key code 7 in the keyboard buffer at midnight:

         ? KeyTime(7, "00:00:00")      // .T.

      ■  Set a key trap every second, starting at 11:59 PM:

         ? KeyTime(7, "11:59:99")      // .T.

      ■  Set a key trap every full hour:

         ? KeyTime(7, "99:00:00")      // .T.

      ■  Call with an invalid time:

         ? KeyTime(7, "25:30:00")      // .F.

      ■  Uninstall KeyTime():

         ? KeyTime()                   // .F.

   $PLATFORMS$
      DOS
   $SEEALSO$
      KeySec(), LASTKLINE(), LASTKFUNC(), LASTKPROC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Millisec()
   $ONELINER$
      Time delay in milliseconds
   $SYNTAX$
      Millisec(<nDelay>) --> cNull

   $ARGUMENTS$
      <nDelay>  Designates the number of milliseconds the function waits.
      You can specify values between 1 and 65535.

   $RETURNS$
      The Millisec() function always returns a null string.

   $DESCRIPTION$
      This function allows you to designate a time delay in milliseconds.

   $EXAMPLES$
      Pause for different time delays:

      Millisec(1)                 // 1 millisecond time delay
      Millisec(100)               // 0.1 seconds
      Millisec(1000)              // 1 second

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Nul()
   $ONELINER$
      Converts the value returned by a function into a null string
   $SYNTAX$
      Nul(<expValue>) --> cNull

   $ARGUMENTS$
      <expValue>  Designates an expression or function that has a return
      value you want to suppress.

   $RETURNS$
      Nul() always returns a null string as a value.

   $DESCRIPTION$
      Nul() converts a function that returns a value into a function that
      returns a null string.  This suppresses the returned value for every
      function.

   $NOTES$
      ■  The function is not VOID.  It returns a value of a specific
         data type -- a (null) string.  Therefore, you cannot use this
         function to compare with other data types (see Examples).

   $EXAMPLES$
      ■  Wait for a key stroke:

         ? "Please press a key  :" + Nul(Inkey(0))

      ■  Show output that uses LIST and waits for a key stroke after 20
         lines:

         LIST Name, IF(RecNo() %20 = 0, Nul(Inkey(0)), "")

      ■  This leads to a TYPE MISMATCH:

         ? 3 = Nul(Inkey(5))         //  Error after 5 seconds
         ? 7 + Nul(Inkey())          //  Leads to error, like saying 7+""

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SCANKEY()
   $ONELINER$
      Queries scan code of keyboard input
   $SYNTAX$
      SCANKEY([<lMode>]) --> nKeyValue

      Warning!  Augmented from CA-Clipper Tools.  This is new optional
      parameter.

   $ARGUMENTS$
      <lMode>  Designates whether or not to ignore the additional keys on
      the European extended keyboard.

   $RETURNS$
      SCANKEY() returns the scan code for the key pressed.

   $DESCRIPTION$
      SCANKEY() returns an untranslated scan code for a key.  This allows you
      to differentiate between keys or key combinations that return the same
      Inkey() value.  SCANKEY() does not take the character out of the buffer.
      The function waits for a keyboard input and returns the scan code which
      corresponds.  The third example shows how a returned value is converted
      into something you can display, as in CTSCAN.CH by SCANKEY().  Although
      it depends on the keyboard, the scan codes may differ from those listed
      in CTSCAN.CH.

   $NOTES$
      ■  No key traps (including the CA-Clipper internal key traps),
         are acknowledged.

   $EXAMPLES$
      ■  Return with input of Ctrl-W:

         ? Inkey()                // 23
         ? SCANKEY()              // 4375
         ? NumLow(SCANKEY())      // 23
         ? NumHigh(SCANKEY())     // 17

      ■  When inputting Ctrl-End (numeric key pad), return:

         ? Inkey()                // 23
         ? SCANKEY()              // 29952
         ? NumLow(SCANKEY())      // 0
         ? NumHigh(SCANKEY())     // 117

      ■  Reuse codes with other functions:

         nCode  :=  SCANKEY()
         SetKXLat(Chr(NumLow(nCode)) * Chr(NumHigh(nCode)), -1)

   $PLATFORMS$
      DOS
   $SEEALSO$
      NumHigh(), DSetKBIOS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SETTIC()
   $ONELINER$
      Increases number of time ticks to produce a more precise time measurement
   $SYNTAX$
      SETTIC([<lAcceleration>]) --> lAccelerated

   $ARGUMENTS$
      <lAcceleration>  When this parameter is .T., the number of timer
      ticks is increased by a factor of 128.  The default is normal timer
      ticks (.F.).

      ()  With no arguments, SETTIC() returns the current status of the timer
      as a .T. when accelerated; .F. if it is not.

   $RETURNS$
      The SETTIC() function returns .T. when the timer is accelerated;
      otherwise, it returns .F..

   $DESCRIPTION$
      If the integrated timer in your computer uses SETTIC(.T.) to accelerate,
      then the number of ticks per second increases from 18.2 to around 2500.
      This makes time measurement more precise and allows you to compare the
      speed of different routines more accurately.

      The computer's clock time, which is also based on the timer tick,
      continues to operate correctly.

   $NOTES$
      Warning!  You must uninstall SETTIC() before you leave a program;
      otherwise, you will hang the system.  However, if the Extended Drivers
      CTUS.LIB is linked in, then SETTIC() uninstalls automatically when you
      exit the program.

      ■  As long as the timer is accelerated, you cannot implement the
         KeySec(), ShowTime(), and SHOWKEY() functions because they use the
         timer tick.  Therefore, you must uninstall these functions before you
         implement SETTIC(.T.).

      ■  Do not place (link) SETTIC() within an overlay, since an
         interrupt service routine can never be within an overlay.  Of course,
         you can call SETTIC() from an overlay.

      ■  Since each timer tick must call an interrupt service, your
         program's execution speed decreases.

   $EXAMPLES$
      Measure an individual UDF in ticks.  The tick rate increases first, and
      then decreases after UDF is executed and the number of resulting ticks
      is queried:

      SETTIC(.T.)
         MY_UDF(I)            // Needs to be measured...
      SETTIC()
      ? "Required ticks:", GETTIC()

   $PLATFORMS$
      DOS
   $SEEALSO$
      GETTIC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SHOWKEY()
   $ONELINER$
      Continuously displays the INSERT and LOCK status
   $SYNTAX$
      SHOWKEY([<cKey>, [[<nLine>], [<nColumn>], <cTextON>,
         <cTextOFF>, [<cAttrON|nAttrON>],
         [<cAttrOFF|nAttrOFF>]]]) --> cNull

   $ARGUMENTS$
      <cKey>  Designates which key to monitor in the form of a letter
      ("C", "N", "S", or "I").  If <cKey> is the only parameter in SHOWKEY()
       (C, N, S, or I), the respective key monitoring is uninstalled.

      <Line>  Designates the line where the display occurs.

      <nColumn>  Designates the column where the display occurs.

      <cTextON>  Designates text for the active status.  A maximum length
      of 15 characters is allowed.

      <cTextOFF>  Designates text for the inactive status. There is a
      maximum of 15 characters and it must have the same length as <cTextON>.

      <cAttrON|nAttrON>  Designates the color attribute for the active
      status.  The default value is 7/0.

      <cAttrOFF|nAttrOFF>  Designates the color attribute for the inactive
      status.  The default value is the same as in <cAttrON|nAttrON>.

      ()  If you call SHOWKEY() without parameters, it uninstalls.

   $RETURNS$
      The SHOWKEY() function always returns a null string.

   $DESCRIPTION$
      SHOWKEY() is an extremely versatile system that can be used to monitor
      the NUM-LOCK, SCROLL-LOCK, CAPS-LOCK, and INSERT keys.  After it is
      installed, you can display an indicator for each key, the desired screen
      position, and a color attribute (without concerning the CA-Clipper
      program).  You can establish a display for both the active and inactive
      status with individual color attributes.  However, both these strings
      must have the same length.

      Since the system INSERT status is handled separately from the
      CA-Clipper INSERT status, this monitoring can only be implemented from
      within a READ.  An indicator display, in so far as it has been
      activated, is refreshed in intervals of approximately 200 milliseconds.
      Therefore, when you clear a portion or the complete screen, do not
      concern yourself with restoring this display.

   $NOTES$
      Warning!  Always uninstall this function before you leave a program
      or use the Extended Drivers provided with this CA-Clipper Tools.  The
      function changes interrupt vectors.  You may cause a system crash, if
      the old status is not restored before you exit the program!  Use the
      enclosed INTSAVE program to avoid this problem.

   $EXAMPLES$
      ■  Display "CAPS" if CAPS-LOCK is on: CAPS-LOCK for off: "    ",
         in line 24, column 50.  The default value for on and off is "7/0"

         SHOWKEY("C", 24, 50, "CAPS", "    ")

      ■  Attributes can be numeric and or designated as in CA-Clipper:

         SHOWKEY("N", 24, 60, "NUM ON", "NUMOFF", 112, "W/R")

      ■  Inverse the display for on and off:

         SHOWKEY("S", 24, 70, "SCRL", "  ", "0/7")

      ■  Uninstall the NUM-LOCK display:

         SHOWKEY("N")

      ■  Uninstall the function:

         SHOWKEY()

   $PLATFORMS$
      DOS
   $SEEALSO$
      ShowTime()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SOUND()
   $ONELINER$
      Creates tones (melodies) by designating frequency and duration
   $SYNTAX$
      SOUND(<nFrequency>,<nDuration>,[<lTimer>]) --> cNull

      or:

      SOUND(<cToneSequence>,[<lTimer>]) --> cNull

   $ARGUMENTS$
      <nFrequency>  Designates the tone frequency in hertz.

      <nDuration>  Designates the duration of the tones in 1/100ths
      seconds; or when <lTimer> is set at .T., in intervals of 1/18.2 seconds.

      <lTimer>  Designates whether the tones designated as values are
      created on a basis of 1/100ths seconds (.F.); or 1/18.2 seconds (.T.).
      The default value is 1/100th seconds (.F.).

      or:

      <cToneSequence>  Designates a character string that contains an
      entire melody.  Use the CA-Clipper I2Bin() function to produce 2-byte
      values for frequency and duration.  The string format assumes 2 bytes
      for frequency and 2 bytes for duration, which are alternated until the
      melody is defined.

      <lTimer>  Designates if you want the designated tones values created
      on a basis of 1/100ths seconds (.F.) or 1/18.2 seconds (.T.).  The
      default value is 1/100th seconds (.F.).

   $RETURNS$
      SOUND() always returns a null string as a value.

   $DESCRIPTION$
      Use SOUND() to create tones at intervals of 1/100th seconds, in the
      range of 21 to 65535 hertz, for a maximum of 655.36 seconds.

      To make it compatible with parameters for the CA-Clipper Tone() function
      or various other programming language functions, select the 1/18.2-
      seconds interval.  To achieve this, designate the last parameter as .T..

      The table below shows tones and their frequencies for three octaves at
      1/100th second intervals.  To go one octave higher, double the frequency
      value.

      Table 13-8: Tones and their Frequencies
      <table>
          Tone    Freq.     Tone    Freq.     Tone    Freq.

          C 3     131       C 4     262       C 5     523
          C#      139       C#      277       C#      554
          D       147       D       294       D       587
          D#      156       D#      311       D#      622
          E       165       E       330       E       659
          F       175       F       349       F       698
          F#      185       F#      370       F#      740
          G       196       G       392       G       784
          G#      208       G#      415       G#      831
          A       220       A       440       A       880
          A#      233       A#      466       A#      932
          B       247       B       494       B       988
         </table>

      Frequency values that lie below 21 hertz, are not perceived by the human
      ear.  You can use them as pauses.

   $NOTES$
      ■  You can find additional uses for SOUND() in the sample file
         Melodies.prg.

   $EXAMPLES$
      ■  Show the tonal scale:

         SOUND(262, 40)
         SOUND(294, 40)
         SOUND(330, 40)
         SOUND(349, 40)
         SOUND(392, 40)
         SOUND(440, 40)
         SOUND(494, 40)
         SOUND(523, 40)

      ■  Call with a string parameter:

         cVar := I2Bin(262) + I2Bin(40) + I2Bin(294) + I2Bin(40)
         SOUND(cVar)

      ■  Pause for one-half second:

         SOUND(0, 50)

   $PLATFORMS$
      DOS
   $SEEALSO$
      Millisec()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPEED()
   $ONELINER$
      A comparison value used to determine the processor speed
   $SYNTAX$
      SPEED([<lMode>]) --> nCPUSpeed

   $ARGUMENTS$
      <lMode>  If designated as .T., causes all interrupts, with the
      exception of the clock, to switch off..  The default value is "Leave
      interrupts on" (.F.).

   $RETURNS$
      SPEED() returns a percentage value to compare to a normal 4.77 MHz PC-
      XT, which corresponds to 100%.

   $DESCRIPTION$
      The function determines, in a precise fashion, the speed to compare to a
      4.77 MHz PC.  To make the measurement more precise, switch the
      interrupts off.  The only exceptions are the timer interrupts that
      refresh  working memory.

   $NOTES$
      Warning!  When you use the optional parameters to shut off all
      interrupts (with the exception of the timer interrupts) you cannot work
      simultaneously with the serial interface.  After you take the
      measurement, you can restore all interrupts.

   $EXAMPLES$
      ■  For a normal AT:

         ? SPEED(.T.)         // 470  4.7 times PC

      ■  Switch off interrupts in the same system:

         ? SPEED(.T.)         // 480  4.8 times PC

   $PLATFORMS$
      DOS
   $SEEALSO$
      CPUType(), PCType()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      STACKFREE()
   $ONELINER$
      Determines the remaining stack space
   $SYNTAX$
      STACKFREE() --> nFreeByte

   $RETURNS$
      STACKFREE() returns the number of bytes available on the stack.

   $DESCRIPTION$
      This function helps avoid system crashes.  If the returned value falls
      below 100, do not permit deeper branching.  Either change the program so
      that a large nesting depth cannot be reached, or increase the stack size
      when linking.

   $NOTES$
      ■  The stack is a low-level system area.  Each DO requires some
         memory bytes, before a RETURN can ensue.

   $EXAMPLES$
      ■  Query the stack size:

         ? STACKFREE()               // < 100 ??

      ■  Link the application within increased stack size:

         RTLINK FI Test /ST:8000

   $PLATFORMS$
      DOS
   $SEEALSO$
      AlloFree()*
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ToolVer()
   $ONELINER$
      Queries the version number of the CA-Clipper Tools in use
   $SYNTAX$
      ToolVer(<lCheckDriver>) --> cVersion

   $ARGUMENTS$
      <lCheckDriver>  When passed as .T., the function checks if the
      Extended Drivers correspond to the library.  If not, the function
      returns "0.00".

   $RETURNS$
      ToolVer() returns CA-Clipper Tools as a string in the "n.nn" format; or
      "0.00", if the Extended Drivers does not correspond to the library.

   $DESCRIPTION$
      This function determines the current CA-Clipper Tools version.  It also
      allows you to check if the CT.LIB and the Extended Drivers CTUS.OBJ
      agree.  This agreement is essential.  If they do not agree, the function
      returns "0.00".

   $EXAMPLES$
      ■  Query the CA-Clipper Tools version:

         ? ToolVer()               // e.g. "5.01"

      ■  Verify the driver version:

         IF ToolVer() <> ToolVer(.T.)
            ? "Wrong driver or driver not linked in..."
         ENDIF

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      XToC()
   $ONELINER$
      Converts an expression of any data type into a string
   $SYNTAX$
      XToC(<expValue>) --> cValue

   $ARGUMENTS$
      <expValue>  Designates an expression of any desired data type.

   $RETURNS$
      XToC() returns a character string version of the <expValue> parameter.

   $DESCRIPTION$
      At first glance, the XToC() function does not appear to accomplish
      anything that cannot be done with the other functions.  However, the
      advantage lies in the fact that you do not have to pay attention to the
      input data types.  For example, you can convert the data in every field
      within a loop into a string.  You could then link these into a longer
      string and use them to index or for comparisons.

      Each data type always returns a string with a particular fixed length:

      Table 13-9: Resulting String
      <table>
          Data Type    Result Length

          Numeric      8
          Logical      1
          Date         8
          String       Unchanged
         </table>

   $NOTES$
      ■  The index string cannot be longer than 256 characters.

   $EXAMPLES$
      ■  In the case of logical parameters, XToC() works like LToC():

         ? XToC(.T.)                              // "T"
         ? XToC(.F.)                              // "F"

      ■  Numeric values always return an 8-byte string:

         ? XToC(0)                                // Length 8
         ? XToC(9.9)                              // Ditto
         ? XToC(-9.9)                             // Ditto
         ? XToC(99)                               // Ditto
         ? XToC(-99)                              // Ditto

      ■  A string returns the same string:

         ? XToC("123ABCabc")                      // "123ABCabc"

      ■  A date returns the ANSI date:

         ? XToC(CToD("12/31/99"))                 // "19991231"
         ? XToC(CToD("01/01/00")                  // "19000101"

      ■  An empty or false date returns an empty string rather than a
         null string:

         ? XToC(CToD("  /  /  ")                  // "        "
         ? XToC(CToD("77/77/77")                  // "        "

      ■  Show a function where all the fields in a database are
         combined into one string.  This way, you can do a complete comparison
         of the two data strings:

         FUNCTION STRINGREC
            PRIVATE nI, nFieldNo, cField, cStringRec
            cStringRec := ""
            nFieldNo   := FCount()                // Number of fields
            FOR nI = 1 to nFieldNo
              cField          := Field(nI)        //  Field name
              cStringRec := cStringRec + XToC(&cField)
            NEXT nI
            RETURN (cStringRec)

   $PLATFORMS$
      DOS
   $SEEALSO$
      CToF()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Mathematical Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      This chapter offers an array of interesting mathematical functions to
      implement in CA-Clipper.  It includes trigonometric functions, finance-
      oriented math computations, and functions to determine the factorial,
      sign, or the next-largest integer of a value.

      SetPrec() is important for trigonometric functions.  With this function
      you can specify the precision as a number of places to the right of the
      decimal.  However, if it is less accurate, the speed is greater.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Acos()
   $ONELINER$
      Computes the cosine arc
   $SYNTAX$
      Acos(<nCosine>) --> nCosArc

   $ARGUMENTS$
      <nCosine>  Designates the cosine value for an angle where the
      response is determined in radians.  The value is in the range of -1 to
      +1 (inclusive).

   $RETURNS$
      Acos() returns the cosine arc for <nCosine>.

   $DESCRIPTION$
      Acos() determines an angle size in radians for a cosine value.  The
      returned value is in the range of 0 to pi.

   $NOTES$
      ■  The precision of the result can be influenced by the SetPrec()
         function.

   $EXAMPLES$
      Compute the cosine arc:

      ? Str(Acos(0.7), 18, 15)      // 0.795398830184144

   $PLATFORMS$
      DOS
   $SEEALSO$
      Asin(), Atan(), Atn2(), DToR(), RToD(), SetPrec(), Sin(), Tan()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Asin()
   $ONELINER$
      Computes the sine arc
   $SYNTAX$
      Asin(<nSine>) --> nSineArc

   $ARGUMENTS$
      <nSine>  Designates the angle sine value for which you want the
      response determined in radians.  The value can be in the range of -1 to
      +1 (inclusive).

   $RETURNS$
      Asin() returns the arc sine for <nSine>.

   $DESCRIPTION$
      Asin() determines an angle size in radians for a sine value.  The return
      value is in the range of -pi/2 to +pi/2.

   $NOTES$
      ■  The SetPrec() function can influence the result.

   $EXAMPLES$
      Compute the sine arc:

      ? Str(Asin(0.5), 18, 15)      // 0.523598775598299

   $PLATFORMS$
      DOS
   $SEEALSO$
      Acos(), Atan(), Atn2(), DToR(), RToD(), SetPrec(), Sin(), Tan()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Atan()
   $ONELINER$
      Computes the tangent arc
   $SYNTAX$
      Atan(<nTangent>) --> nArcTan

   $ARGUMENTS$
      <nTangent>  Designates the angle tangent value for which you want
      the response determined in radians.

   $RETURNS$
      Atan() returns the tangent arc for <nTangent>.

   $DESCRIPTION$
      Atan() determines an angle size in radians for a tangent value.

   $NOTES$
      ■  The SetPrec() function can influence the precision of the
         result.

   $EXAMPLES$
      Compute the arc of the tangent :

      ? Str(Atan(Pi()/4), 18, 15)      // 0.665773750028354

   $PLATFORMS$
      DOS
   $SEEALSO$
      Asin(), Acos(), Atn2(), DToR(), RToD(), SetPrec(), Sin(), Tan()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Atn2()
   $ONELINER$
      Computes the angle size from the sine and cosine
   $SYNTAX$
      Atn2(<nSine>,<nCosine>) --> nArc

   $ARGUMENTS$
      <nSine>  Designates the sine value for an angle.

      <nCosine>  Designates the cosine value for an angle.

   $RETURNS$
      Atn2() returns the angle sine in radians.

   $DESCRIPTION$
      Atn2() returns the angle sine in radians, where the sine and the cosine
      of a given point have been specified.  The function returns results for
      all four quadrants and corresponds to a call of Atan(x/y).  One
      advantage of the Atn2() function is that no "divide by zero" error can
      occur.  The returned value is in the range of -pi to +pi.

   $NOTES$
      ■  The SetPrec() function can influence the precision of the
         result.

   $EXAMPLES$
      ■  Compute the sine and cosine of 30 degrees.  DToR() is then
         used to convert these into the radian value:

         SET DECIMALS TO 4
         X  :=  Sin(DToR(30))
         Y  :=  Cos(DToR(30))

      ■  Use RToD() to compute the result in degrees:

         ? RToD(Atn2(x, y))         // 30.0000

   $PLATFORMS$
      DOS
   $SEEALSO$
      Asin(), Acos(), Atan(), DToR(), RToD(), SetPrec(), Sin(), Tan()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Ceiling()
   $ONELINER$
      Rounds up to the next integer
   $SYNTAX$
      Ceiling(<nValue>) --> nLargerInteger

   $ARGUMENTS$
      <nValue>  Designates the number for which the next-largest integer
      is determined.

   $RETURNS$
      Ceiling() returns the next-largest integer to the one that is passed as
      a parameter.

   $DESCRIPTION$
      Ceiling() returns the next-largest integer to the one passed as a
      parameter.  This applies to positive and negative numbers.

   $EXAMPLES$
      Show the next-largest integer (including positive and negative numbers):

      ? Ceiling(1.9)            // Result:   2
      ? Ceiling(1.1)            // Result:   2
      ? Ceiling(0.9)            // Result:   1
      ? Ceiling(-0.1)           // Result:   0
      ? Ceiling(-0.9)           // Result:   0
      ? Ceiling(-1.1)           // Result:-1

   $PLATFORMS$
      DOS
   $SEEALSO$
      Floor()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Cos()
   $ONELINER$
      Computes the cosine
   $SYNTAX$
      Cos(<nArc>) --> nCosine

   $ARGUMENTS$
      <nArc>  Designates a radian value for which the cosine is
      determined.

   $RETURNS$
      Cos() returns the cosine value specified in <nArc>.

   $DESCRIPTION$
      Cos() computes the angle cosine measured in radians.

   $NOTES$
      ■  If you want the values specified in degrees, you can convert
         them with the DToR() function.

   $EXAMPLES$
      Compute the cosine:

      ? Str(Cos(0), 18, 15)               // 1.000000000000000
      ? Str(Cos(Pi() /4), 18, 15)         // 0.707106781186548
      ? Str(Cos(Pi() /2), 18, 15)         // 0.000000000000000
      ? Str(Cos(Pi() *99.5), 18, 15)      // 0.000000000000000
      ? Str(Cos(Pi() /9), 18, 15)         // 0.939692620785908

   $PLATFORMS$
      DOS
   $SEEALSO$
      Sin(), Tan(), Cot(), DToR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Cot()
   $ONELINER$
      Computes the cotangent
   $SYNTAX$
      Cot(<nArc>) --> nCoTangent

   $ARGUMENTS$
      <nArc>  Designates a radian value for which the cotangent is
      determined.

   $RETURNS$
      Cot() returns the cotangent of the value specified in <nArc>.

   $DESCRIPTION$
      Cot() computes the cotangent of an angle measured in radians.

   $NOTES$
      ■  If the values are specified in degrees, use the DToR()
         function to convert them.

   $EXAMPLES$
      Computes the cotangent:

      ? Str(Cot(Pi() /4), 18, 15)      // 1.000000000000000
      ? Str(Cot(Pi() /2), 18, 15)      // 0.000000000000000
      ? Str(Cot(Pi() /9), 18, 15)      // 2.747477419454622

   $PLATFORMS$
      DOS
   $SEEALSO$
      Sin(), Cos(), Tan(), DToR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      DToR()
   $ONELINER$
      Converts from a degree to radian measure
   $SYNTAX$
      DToR(<nAngle>) --> nArc

   $ARGUMENTS$
      <Angle>  Designates a valid angle measurement in degrees.

   $RETURNS$
      DToR() returns the radian of the specified value.

   $DESCRIPTION$
      In addition to expressing angle measurements in degrees, you may also
      need to express an angle in radians.  With DToR(), you can convert
      degree measurements into radians.

   $EXAMPLES$
      Show some calculations accurate to 15th place:

      ? Str(DToR(360), 18, 15)     // Result: 6.283185307179588
      ? Str(DToR(180), 18, 15)     // Result: 3.141592653589794
      ? Str(DToR(180.5), 18, 15)   // Result: 3.150319299849766
      ? Str(DToR(720), 18, 15)     // Result: 12.566370614359180
      ? Str(DToR(-180), 18, 15)    // Result:-3.141592653589794

   $PLATFORMS$
      DOS
   $SEEALSO$
      RToD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Fact()
   $ONELINER$
      Computes the factorial
   $SYNTAX$
      Fact(<nValue>) --> nFactorial

   $ARGUMENTS$
      <nValue>  Designates a value between 0 and 21.

   $RETURNS$
      Fact() returns the factorial of the specified value.

   $DESCRIPTION$
      Fact() computes the factorial of a value in the range of 0 to 21.  Since
      results for factorials over 21 are too large, the function returns -1 to
      indicate an error.

   $EXAMPLES$
      Show some factorials:

      ? Fact(1)         // Result: 1
      ? Fact(5)         // Result: 120
      ? Fact(21)        // Result: 51090942171709440000
      ? Fact(25)        // Result: -1 (Value too large !)
      ? Fact(0)         // Function returns 1

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Floor()
   $ONELINER$
      Rounds down to the next integer
   $SYNTAX$
      Floor(<nValue>) --> nSmallerInteger

   $ARGUMENTS$
      <nValue>  Designates the number for which the next-smaller integer
      is determined.

   $RETURNS$
      Floor() returns the next-smaller integer of the one passed as a
      parameter.

   $DESCRIPTION$
      Floor() always returns the next-smaller integer of the one passed as a
      parameter.  This applies to positive and negative numbers.

   $EXAMPLES$
      Show the next-smaller integer for positive and negative numbers:

      ? Floor(1.9)       // Result:  1
      ? Floor(1.1)       // Result:  1
      ? Floor(0.9)       // Result:  0
      ? Floor(-0.1)      // Result: -1
      ? Floor(-0.9)      // Result: -1
      ? Floor(-1.1)      // Result: -2

   $PLATFORMS$
      DOS
   $SEEALSO$
      Ceiling()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      FV()
   $ONELINER$
      Computes future value of capital
   $SYNTAX$
      FV(<nInstall>,<nInterestRate>,<nNumberofPayments>)
          --> nCapital

   $ARGUMENTS$
      <nInstall>  Designates the installment amount to pay for the period.

      <nInterestRate>  Designates the interest rate calculated for the
      payment period.  1 corresponds to 100%.

      <nNumberofPayments>  Designates the number of payments.

   $RETURNS$
      FV() returns the future capital value of the total deposits, plus the
      interest generated.

   $DESCRIPTION$
      FUTURE VALUE
      FV() returns the capital available after the <nNumberofPayments> total
      installments at <nInstall> payment, at an <nInterestRate> interest
      charge for the period.

   $EXAMPLES$
      What amount would you save, if you pay $150.00 per month for 3 years
      into a fund that pays an annual interest rate of 6%?

      nRate  :  0.06/12         // Monthly interest rate
      ? FV(150, nRate, 36)      // Result: 5900.42

   $PLATFORMS$
      DOS
   $SEEALSO$
      Payment(), PV(), Rate(), Periods()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetPrec()
   $ONELINER$
      Determines the level of precision that is set
   $RETURNS$
      GetPrec() returns the level of precision currently installed for
      CA-Clipper Tools trigonometric functions.  The value corresponds to the
      number of digits to the right of the decimal in the range of 1 to 16.

   $DESCRIPTION$
      GET PRECISION
      GetPrec() queries the currently installed precision level for CA-Clipper
      Tools trigonometric functions.  The returned value corresponds to the
      number of digits to the right of the decimal, that are being worked
      with.  Although the default is 16, you can change this value with
      SetPrec().

   $EXAMPLES$
      What precision has been set?

      ? GetPrec()      //  e.g. 10

   $PLATFORMS$
      DOS
   $SEEALSO$
      SetPrec()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Log10()
   $ONELINER$
      Computes the common logarithm
   $SYNTAX$
      Log10(<nValue>) --> nLog10

   $ARGUMENTS$
      <nValue>  Designates a number for which the base 10 logarithm is
      determined.

   $RETURNS$
      Log10() returns the base 10 logarithm for the <nValue> number.

   $DESCRIPTION$
      Log10() determines the common logarithm for a number.

   $NOTES$
      ■  For non-mathematicians, look at it this way:  to what power
         must 10 be raised (10n) so that <nValue> results?

   $EXAMPLES$
      Display common logarithm values:

      ? Log10(0.01)            // -2.00
      ? Log10(2)               //  0.30
      ? Log10(100)             //  2.00
      ? Log10(Infinity())      //  308.25

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Payment()
   $ONELINER$
      Computes the periodic payment amount
   $SYNTAX$
      Payment(<nCapital>,<nInterestRate>,<nNumberpayments>,)
          --> nPayment

   $ARGUMENTS$
      <nCapital>  Designates the loan amount.

      <nInterestRate>  Designates the periodic interest rate.  1
      corresponds to 100%.

      <nNumberPayments>  Designates the number of payments on the loan
      within the payment period.

   $RETURNS$
      Payment() returns the payment to make for each payment period.

   $DESCRIPTION$
      Payment() computes the payment for each period where loan interest
      applies.  The determined amount relates to a loan amount <nCapital> that
      is repaid over <nNumberPayments>, at an interest rate of
      <nInterestRate>.

   $EXAMPLES$
      How high does the monthly annuity amount have to be, if you want to
      repay a $2,000.00 loan within 24 months at an annual interest rate of
      10%:

      nRate  :=  0.1/12              // The monthly rate
      ? Payment(2000, Rate, 24)      // 92.29 per month

   $PLATFORMS$
      DOS
   $SEEALSO$
      PV(), FV(), Rate(), Periods()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Periods()
   $ONELINER$
      Computes the number of payment periods necessary to repay a loan
   $SYNTAX$
      Periods(<nCapital>,<nPayment>,<nInterestRate>)
         --> nNumberPayments

   $ARGUMENTS$
      <nCapital>  Designates the loan amount.

      <nPayment>  Designates the amount of the scheduled periodic payment.

      <nInterestRate>  Designates the periodic interest rate.  1
      corresponds to 100%.

   $RETURNS$
      Periods() returns the number of payments required to repay the
      <nCapital> amount.

   $DESCRIPTION$
      Periods() computes how often you must make a payment <nPayment> to reach
      the <nCapital> amount at the <nInterestRate> interest rate.

   $NOTES$
      ■  If the installment payment is smaller than the interest
         amount, repayment lasts forever.  In this case, the function returns
         a value
         of -1.

   $EXAMPLES$
      How many months do you need to pay back a $4000 loan at an annual
      interest rate of 9.5%, if you want the $200 monthly payments?

      nRate  :=  0.095/12             // Monthly rate
      ? Periods(4000, 200, Rate)      // Number of periods

   $PLATFORMS$
      DOS
   $SEEALSO$
      Payment(), PV(), FV(), Rate()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Pi()
   $ONELINER$
      Returns pi with the highest degree of accuracy
   $SYNTAX$
      Pi() --> nPI

   $RETURNS$
      Pi() returns the pi value with the highest degree of accuracy.

   $DESCRIPTION$
      This function simplifies calculations when the most accurate pi value is
      required.

   $EXAMPLES$
      Show the accurate display for the pi value:

      ? Str(Pi(), 18, 15)      // Result:  3.141592653589793

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PV()
   $ONELINER$
      Computes the cash present value after interest charges
   $SYNTAX$
      PV(<nPayments>,<nInterestRate>,<nNumberPayments>)
         --> nCapital

   $ARGUMENTS$
      <nPayment>  Designates the amount of the scheduled periodic payment.

      <nInterestRate>  Designates the periodic interest rate.  1
      corresponds to 100%.

      <nNumberPayments>  Designates the number of anticipated payment
      periods.

   $RETURNS$
      PV() returns the cash value of an interest yield.

   $DESCRIPTION$
      PRESENT VALUE
      The function computes the cash value of regular equal payments
      <nNumberPayments> at an <nInterestRate> interest rate over
      <nNumberPayments> payment periods.

   $EXAMPLES$
      ■  How high can a loan be if you pay $175 for 24 months, at an
         annual fixed interest rate of 9.5%?  Since payments are monthly, the
         annual percentage rate is divided by 12:

         nRate  :=  0.095/12
         ? PV(175, nRate, 24)     // $3811.43

      ■  Annual payments over 2 years at 9.5% per annum:

         ? PV(175, 0.095, 2)      // $305.77

   $PLATFORMS$
      DOS
   $SEEALSO$
      Payment(), Rate(), Periods(), FV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Rate()
   $ONELINER$
      Computes the interest rate for a loan
   $SYNTAX$
      Rate(<nCapital>,<nPayment>,<nNumberPayments>)
         --> nInterestRate

   $ARGUMENTS$
      <nCapital>  Designates the amount of the loan.

      <nPayment>  Designates the payment per installment.

      <NumberPayments>  Designates the number of the planned payment
      periods.

   $RETURNS$
      Rate() returns the loan interest rate.

   $DESCRIPTION$
      Rate() determines the annual interest rate for a loan <nCapital> in the
      <nNumberPayments> period at the specified <nPayment> installment.  The
      calculated interest rate is based on a Newtonian iterative solution
      procedure:

          lk+1=ik - f(ik)/f(ik)

      where:

          f(i)=(1-(l + i)^-n)/i - PV/PMT

      The initial value for i is selected as follows:

          -io = PMT/PV - PV/n^2PMT

   $NOTES$
      ■  This function allows a maximum value for the payment period of
         1020.

   $EXAMPLES$
      For a $2500 loan, you pay $86.67 per month for 3 years.  What is the
      effective annual interest rate?

      nLoan     :=  2500
      nPayment  :=  86.67
      nPeriod   :=  36

      ? Rate(nLoan, nPayment, nPeriod) * 12      // 0.1501 (15.01%)

   $PLATFORMS$
      DOS
   $SEEALSO$
      Payment(), PV(), FV(), Periods()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RToD()
   $ONELINER$
      Converts from a radian to degree measure
   $SYNTAX$
      RToD(<nArc>) --> nAngle

   $ARGUMENTS$
      <nArc>  Designates a valid angle measurement in radians.

   $RETURNS$
      RToD() returns the value of the designated parameter in degrees.

   $DESCRIPTION$
      In addition to expressing an angle measurement in degrees, it is often
      useful to express an angle in radians.  RToD() converts a radian
      measurement into degrees.

   $EXAMPLES$
      Show some conversions:

      ? RToD( Pi() )        // Result:  180
      ? RToD(2 * Pi())      // Result:  360
      ? RToD(4 * Pi())      // Result:  720
      ? RToD( -Pi() )       // Result: -180

   $PLATFORMS$
      DOS
   $SEEALSO$
      DToR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SetPrec()
   $ONELINER$
      Sets the precision level for trigonometric functions
   $SYNTAX$
      SetPrec(<nPrecision>) --> cNull

   $ARGUMENTS$
      <nPrecision>  Designates the number of places for computational
      precision in the range of 1 to 16.  The default value is 16.

   $RETURNS$
      SetPrec() always returns a null string.

   $DESCRIPTION$
      SET PRECISION
      CA-Clipper Tools works with the default precision set at 16 places to
      the right of the decimal for trigonometric functions.  If you do not
      want this precision level, or you want a faster execution speed, reduce
      the number of places accordingly.  The following functions are affected:

      Sin()  Cos()  Tan()  Cot()  Asin()  Acos()  Atan()  Atn2()

   $EXAMPLES$
      Set a precision level of 10 places:

      SetPrec(10)         // Always returns a null string

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetPrec(), Sin(), Cos(), Tan(), Cot(), Asin(), Acos()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Sign()
   $ONELINER$
      Determines the mathematical sign of a number
   $SYNTAX$
      Sign(<nValue>) --> nSign

   $ARGUMENTS$
      <nValue>  Designates the number to determine as a mathematical sign.

   $RETURNS$
      Sign() returns 1, 0, or -1, based on whether the number passed as a
      parameter is positive, null, or negative.

   $DESCRIPTION$
      This function simplifies mathematical expressions.  If constructions or
      functions become unnecessary.  Sign() returns three different values, in
      accordance with the specified parameter:

         1        positive numbers
         0        the number 0
        -1        negative numbers

   $EXAMPLES$
      ■  Show a positive number:

         ? Sign(48335)      // Result: 1

      ■  Show a negative number:

         ? Sign(-258)       // Result: -1

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Sin()
   $ONELINER$
      Computes the sine of a radian value
   $SYNTAX$
      Sin(<nArc>) --> nSine

   $ARGUMENTS$
      <nArc>  Designates the radian value to determine as a sine.

   $RETURNS$
      Sin() returns the sine for the <nArc> specified value.

   $DESCRIPTION$
      Sin() determines the sine of a a specified radian value.

   $EXAMPLES$
      Show some sine calculations:

      ? Str(Sin(Pi() /4), 18, 15)         // 0.707106781186548
      ? Str(Sin(Pi() /2), 18, 15)         // 1.000000000000000
      ? Str(Sin(Pi() *99.5), 18, 15)      //-1.000000000000000
      ? Str(Sin(Pi() /9), 18, 15)         // 0.342020143325669

   $PLATFORMS$
      DOS
   $SEEALSO$
      Cos(), Tan(), Cot(), DToR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Tan()
   $ONELINER$
      Computes the tangent of a radian value
   $SYNTAX$
      Tan(<nArc>) --> nTangent

   $ARGUMENTS$
      <nArc>  Designates the radian value to determine as a tangent.

   $RETURNS$
      Tan() returns the tangent for the <nArc> specified value.

   $DESCRIPTION$
      Tan() determines the tangent of a value specified in radians.

   $NOTES$
      ■  If you want to represent the value in degrees, convert it with
         the DToR() function.

   $EXAMPLES$
      Some tangent calculations:

      ? Str(Tan(0), 18, 15)            //  1.000000000000000
      ? Str(Tan(Pi() /4), 18, 15)      //  1.000000000000000
      ? Str(Tan(Pi() /9), 18, 15)      //  0.363970234266202

   $PLATFORMS$
      DOS
   $SEEALSO$
      Sin(), Cos(), Cot(), DToR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Peek / Poke Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      Despite the many capabilities of CA-Clipper Tools, there are times when
      direct port or memory access is needed.  The functions in this chapter
      serve this purpose.  For example, you can read memory regions by byte,
      word, or as a string through the PEEK function.  POKE functions enable
      you to write a byte or word to working memory, but not a string.

      Warning!  POKE functions can be very dangerous.  If you write to the
      wrong area in memory it can cause a lot of problems you may not foresee.
      Use POKE functions ONLY if you have extensive system knowledge.

      This also applies to all the IN/OUT functions in this chapter, which
      allow you to directly manipulate a port.  For example, if you address a
      disk controller improperly, the result may lead to data loss.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      INBYTE()
   $ONELINER$
      Reads an 8 byte from a port
   $SYNTAX$
      INBYTE(<nPort|cHexPort>) --> nByte

   $ARGUMENTS$
      <nPort|cHexPort>  Designates a port address from which a byte is
      read.  This value can be a decimal integer or hexadecimal string.

   $RETURNS$
      INBYTE() returns the byte read from the specified port; or a value of -
      1, if a parameter error occurs.

   $DESCRIPTION$
      CA-Clipper Tools always attempts to offer finished solutions at the
      highest-possible level for such standared hardware as a serial interface
      port.  However, if you read a highly specialized systems and their ports
      from CA-Clipper, use INBYTE() or INWORD().

   $NOTES$
      ■  A random return value is produced for a nonexistent port or
         one that cannot be read.

   $EXAMPLES$
      These examples read the first port address of the first serial interface
      port.  This is only an example, since the CA-Clipper Tools contains
      special port functions.

      ■  With a decimal parameter:

         ? INBYTE(1016)       // 1st Port (COM1)

      ■  With a hexadecimal parameter:

         ? INBYTE("3F8")      // Also 1st Port (COM1)

   $PLATFORMS$
      DOS
   $SEEALSO$
      INWORD(), OUTBYTE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      INWORD()
   $ONELINER$
      Reads in a 16-bit word from a port
   $SYNTAX$
      INWORD(<nPort|cHexPort>) --> nWord

   $ARGUMENTS$
      <nPort|cHexPort>  Designates a port address from which a word with a
      16-bit value is read.  This value can be a decimal integer or
      hexadecimal string.

   $RETURNS$
      INWORD() returns the word read from the designated port, or a value of -
      1 when an error occurs.

   $DESCRIPTION$
      CA-Clipper Tools always attempts to offer finished solutions at the
      highest-possible level for such standard hardware as a serial interface
      port.  However, if you read highly specialized systems and their ports
      from CA-Clipper, use INBYTE() or INWORD().  INWORD() allows you to read
      from interfaces that return the data from a port as a 16-bit value.

   $NOTES$
      ■  A returns random value for a nonexistent port or one that
         cannot be read.

   $EXAMPLES$
      Show a read from a 16-bit port:

      ■  With a decimal parameter:

         ? INWORD(512)           // Read from an additional device

      ■  With a hexadecimal parameter:

         ? INWORD("200")         // The same port address

   $PLATFORMS$
      DOS
   $SEEALSO$
      INBYTE(), OUTWORD(), NumHigh(), NumLow()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      OUTBYTE()
   $ONELINER$
      Sends a byte to a port
   $SYNTAX$
      OUTBYTE(<nPort|cHexPort>,<nOutByte|cHexOutByte>)
          --> lSuccessful

   $ARGUMENTS$
      <nPort|cHexPort>  Designates a port address to which you can pass a
      byte.  This value can be a decimal integer or hexadecimal string.

      <nOutByte|cHexOutByte>  Designates the byte passed to the specified
      port.  This value can be a decimal integer or hexadecimal string.

   $RETURNS$
      OUTBYTE() returns .T. when the operation is successfully completed.  A
      return value of .F. indicates a parameter error.

   $DESCRIPTION$
      CA-Clipper Tools always attempts to offer finished solutions at the
      highest-possible level for such standard hardware as a serial interface
      port..  However, if highly specialized systems and their ports are to
      receive data from CA-Clipper, use OUTBYTE() or OUTWORD().

   $NOTES$
      ■  The function does not determine if a port is available, or if
         you cannot write to it.

   $EXAMPLES$
      Transfer a byte to the fifth port address of the first serial interface
      port.  This is only an example, since CA-Clipper Tools has special
      serial interface port functions.

      ■  With a decimal parameter:

         ? OUTBYTE(1020, 1)          // 5th port COM1, DTR On

      ■  With a hexadecimal parameter:

         ? OUTBYTE("3FC", 0)         // 5th port COM1, DTR Off

   $PLATFORMS$
      DOS
   $SEEALSO$
      INBYTE(), OUTWORD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      OUTWORD()
   $ONELINER$
      Sends a 16-bit word to a port
   $SYNTAX$
      OUTWORD(<nPort|<cHexPort>,<nOutWord|cHexOutWord>)
          --> lSuccessful

   $ARGUMENTS$
      <nPort|HexPort>  Designates a port address to which a word with a 16-
      bit value is passed.  This value can be a decimal integer or hexadecimal
      (sedecimal) string.  The maximum is 65520 ("FFF0" Hex).

      <nOutWord|cHexOutWord>  Designates the word passed to the specified
      port.  This value can be designated as a decimal integer or hexadecimal
      (sedecimal) string.  The maximum is 65536 ("FFFF" Hex).

   $RETURNS$
      OUTWORD() returns .T. when the operation is successfully completed.  A
      return value of .F. indicates a parameter error.

   $DESCRIPTION$
      CA-Clipper Tools always attempts to offer finished solutions at the
      highest-possible level for such standard hardware as the serial
      interface port..  However, if, highly specialized systems and their
      ports are to receive data from CA-Clipper, use OUTBYTE() or OUTWORD().

   $NOTES$
      ■  The function does not determine if a port is open or if you
         cannot write to it.

   $EXAMPLES$
      Output to a 16-bit port.

      ■  With a decimal parameter:

         ? OUTWORD(512, 32)          // Write word to an additional device

      ■  With a hexadecimal parameter:

         ? OUTWORD("200", "20")      // Same port, same value

   $PLATFORMS$
      DOS
   $SEEALSO$
      INWORD(), OUTBYTE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PEEKBYTE()
   $ONELINER$
      Reads a byte from memory
   $SYNTAX$
      PEEKBYTE(<nSegment|cHexSegment>,<nOffset|cHexOffset>)
          --> nByte

   $ARGUMENTS$
      <nSegment|cHexSegment>  Designates the segment address from which
      the byte is read.  This value can be a decimal integer or hexadecimal
      string.  The maximum is 65520 ("FFF0" Hex).

      <nOffset|cHexOffset>  Designates the offset address within the
      segment specified by <nSegment|cHexSegment>.  This value can be a
      decimal integer or hexadecimal string.  The maximum is 65535 ("FFFF"
      Hex).

   $RETURNS$
      PEEKBYTE() returns the byte to be read or a value of -1, if there is an
      error.

   $DESCRIPTION$
      PEEKBYTE() reads a byte from a desired memory region within conventional
      memory.  You must specify the segment address and offset.

   $EXAMPLES$
      ■  Show a decimal parameter:

         ? PEEKBYTE(1000, 2000)       // Segment 1000d, Offset 2000d

      ■  Show a hexadecimal parameter:

         ? PEEKBYTE("F000", "8000")   // The byte at address F800h

   $PLATFORMS$
      DOS
   $SEEALSO$
      PEEKWORD(), POKEBYTE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PEEKSTR()
   $ONELINER$
      Reads a byte sequence from memory
   $SYNTAX$
      PEEKSTR(<nSegment|cHexSegment>, <nOffset|cHexOffset>,
         [<nLength|cHexLength>]) --> cCharacterString

   $ARGUMENTS$
      <nSegment|cHex>  Designates the segment address from which the
      character sequence string is read.  This value can be a decimal integer
      or hexadecimal string.

      <nOffset|cHexOffset>  Designates the offset address within the
      segment specified by <nSegment|cHexSegment>.  This value can be a
      decimal integer or hexadecimal string.

      <nLength|cHexLength>   Designates the string length to read, up to a
      maximum of 65520.  This value can be a decimal integer or a hexadecimal
      string.  The default, PEEKSTR(), reads to the first Chr(0).

   $RETURNS$
      PEEKSTR() returns the character string read from memory.

   $DESCRIPTION$
      PEEKSTR() reads an area of memory and returns it as a string.  The
      function reads to the first Chr(0) or the length specified through
      <nLength|cHexLength>.

   $EXAMPLES$
      The AT BIOS copyright is found at the F000:0h address.  Therefore, each
      byte is repeated and CharOdd() is used to display it.  It reads to the
      first Chr(0):

      ? CharOdd(PEEKSTR("F000", 0))      // "19xx, 19xx Copyright...."

   $PLATFORMS$
      DOS
   $SEEALSO$
      PEEKBYTE(), PEEKWORD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PEEKWORD()
   $ONELINER$
      Reads a 16-bit word from memory
   $SYNTAX$
      PEEKWORD(<nSegment|cHexSegment>,<nOffset|cHexOffset>)
          --> nWord

   $ARGUMENTS$
      <nSegment|cHex>  Designates the segment address from which a word is
      read.  This value can be a decimal integer or a hexadecimal string.

      <nOffset|cHexOffset>  Designates the offset address within the
      segment specified by <nSegment|cHexSegment>.  This value can be a
      decimal integer or hexadecimal string.  The maximum is ("FFFE").

   $RETURNS$
      PEEKWORD() returns the word that is read in or a value of -1, if an
      error occurs.

   $DESCRIPTION$
      In contrast to PEEKBYTE(), this function reads 16 bits from memory.  In
      this way, WORDS (16-bit integers) are read directly out of two memory
      regions within conventional memory.  Therefore, you must specify a value
      for the segment address and offset.

   $NOTES$
      ■  PEEKWORD() assumes that a 16-bit value is presented in the low-
         byte/high-byte sequence.

   $EXAMPLES$
      ■  Peek a word using a hexadecimal parameters:

         ? PEEKWORD("F000", "8000")      // The WORD at address F8000h

      ■  Store a value in memory and then retrieve it:

         POKEBYTE("9000", "F000", 1)     // 1 stored-9F000h (low byte)
         POKEBYTE("9000", "F001", 2)     // 2 stored-9F001h (high byte)
         ? PEEKWORD("9000", "F000")      // Word at 9F000h  513

   $PLATFORMS$
      DOS
   $SEEALSO$
      PEEKBYTE(), POKEBYTE(), POKEWORD(), NumHigh(), NumLow()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      POKEBYTE()
   $ONELINER$
      Writes a byte to memory
   $SYNTAX$
      POKEBYTE(<nSegment|cHexSegment>,<nOffset|cHexOffset>,
          <nByte|cHexByte>) --> lSuccessful

   $ARGUMENTS$
      <nSegment|cHexSegment>  Designates the segment address in which a
      byte is stored.  This value can be a decimal integer or hexadecimal
      string.  The maximum is 65520 ("FFF0").

      <nOffset|cHexOffset>  Designates the offset address within the
      segment specified by <nSegment|cHexSegment>.  This value can be a
      decimal integer or hexadecimal string.  The maximum is 65535 ("FFFF").

      <nByte|cHexByte>  Designates the byte to store in memory.  This
      value can be a decimal integer or hexadecimal string.  The maximum is
      255 ("FF").

   $RETURNS$
      POKEBYTE() returns .T., if the operation is successfully completed.  A
      return value of .F. indicates a parameter error.

   $DESCRIPTION$
      POKEBYTE() writes a byte to a desired memory area within conventional
      memory.  The segment address and offset are required.

      Warning!  Be aware that this is not always safe.  If you
      inadvertently manipulate the wrong memory location, there may be serious
      consequences.  Use POKEBYTE() ONLY when you have a thorough knowledge of
      the system environment and there is no other solution than to directly
      alter a memory location.

   $NOTES$
      ■  The function does not check if you can store the byte in
         memory.

   $EXAMPLES$
      ■  Poke a byte using decimal parameters:

         ? POKEBYTE(32768, 1000, 65)           // Can be dangerous!

      ■  Poke a byte using hexadecimal parameters:

         ? POKEBYTE("F000", "8000", "41")      // Impossible, ROM area

   $PLATFORMS$
      DOS
   $SEEALSO$
      PEEKBYTE(), POKEWORD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      POKEWORD()
   $ONELINER$
      Writes a 16-bit word to memory
   $SYNTAX$
      POKEWORD(<nSegment|cHexSegment>,<nOffset|cHexOffset>,
         <nWord|cHexWord>) --> lSuccessful

   $ARGUMENTS$
      <nSegment|cHex>  Designates the segment address where a word is
      stored.  This value can be a decimal integer or hexadecimal string.  The
      maximum is 65520 ("FFF0").

      <nOffset|cHexOffset>  Designates the offset address within the
      segment specified by <nSegment|cHexSegment>.  This value can be a
      decimal integer or hexadecimal string.  The maximum is 65534 ("FFFE").

      <nWord|cHexWord>  Designates the word to be stored in memory.  This
      value can be a decimal integer or  hexadecimal string.  The maximum is
      65535 ("FFFF").

   $RETURNS$
      POKEWORD() returns .T. when the operation is successfully completed.  A
      return value of .F. indicates an error.

   $DESCRIPTION$
      POKEWORD() writes a word to a desired memory area within the
      conventional memory.  The segment address and offset are required.

      Warning!  Be aware that this is not always safe.  If you
      inadvertently manipulate the wrong memory location, there may be serious
      consequences.  Use POKEWORD() ONLY when you have a thorough knowledge of
      the system environment and there is no other solution than to directly
      alter a memory location.

   $NOTES$
      ■  The function does not test whether the word is stored in
         memory.

      ■  POKEWORD() stores the <nWord|cHexWord> word in memory in the
         low-byte/high-byte sequence.

   $EXAMPLES$
      ■  Poke a word using decimal parameters:

         ? POKEWORD(32768, 1000, 65535)          // Can be dangerous!

      ■  Poke a word using hexadecimal parameters:

         ? POKEWORD("F000", "8000", "FFFF")      // Impossible, ROM area

   $PLATFORMS$
      DOS
   $SEEALSO$
      PEEKWORD(), POKEBYTE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Get / Read Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      CA-Clipper enables you to program nested  GET/READ masks.  The functions
      in this chapter are retained in CA-Clipper Tools for compatibility
      reasons and to make them easy to use.

      The active GET is saved with the help of a character string and restored
      through this string later.  This allows you to newly query inputs
      without losing your main input mask.  You can save KEYTRAP() definitions
      the same way and redefine them as you wish.

      Important!  It is impossible to use the saved information any longer
      that the runtime of an application.  The character string that results
      cannot be saved to a file and reloaded later.

      Other functions in this chapter return information about GET fields,
      such as screen position, the names of the accompanying variables, or
      information about whether a field is currently active.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CountGets()
   $ONELINER$
      Determines the number of posted GET fields
   $SYNTAX$
      CountGets() --> nFields

   $RETURNS$
      CountGets() returns the number of currently posted fields within a READ.

   $DESCRIPTION$
      CountGets() determines how many GET fields are currently open in a VALID
      UDF or within a KEYTRAP procedure.  Posted means the GET fields have
      been recently defined before with @ ...GET ...

   $EXAMPLES$
      ■  Display the number of GET fields that are currently posted
         from within a valid UDF:

            @ 10, 10 GET Field1
            @ 10, 20 GET Field2 VALID MYFUNC()
            @ 10, 30 GET Field3
         READ
         RETURN

      ■  Returns CountGets() within the UDF:

         FUNCTION MYFUNC
            ? CountGets()          // Result: 3
            RETURN(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      CurrentGet()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CurrentGet()
   $ONELINER$
      Determines the number of the currently active GET field
   $SYNTAX$
      CurrentGet() --> nField

   $RETURNS$
      CurrentGet() returns the number of the currently active GET field.

   $DESCRIPTION$
      CurrentGet() determines the number of the currently active GET fields.
      This information is useful in functions called through VALID.

   $EXAMPLES$
      Pass the number of the active GET fields as a parameter:

      @@ XX,YY GET field  VALID MYFUNC(CurrentGet())

   $PLATFORMS$
      DOS
   $SEEALSO$
      CountGets(), GetFldRow(), GetFldCol()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetFldCol()
   $ONELINER$
      Determines the screen column of a GET field
   $SYNTAX$
      GetFldCol([<nField>]) --> nColumn

   $ARGUMENTS$
      <nField>  Designates the number of the GET field for which the
      screen column is determined.  The default is the currently active field.

   $RETURNS$
      GetFldCol() returns the screen column for the first position of the
      currently active or the specified field.  If there is an invalid
      parameter, a value of -1 is returned.

   $DESCRIPTION$
      GET FIELD COLUMN
      This function determines the first column of an input field.  If the
      <nField> parameter is not specified, the function returns the column for
      the currently active field.  With an invalid field number or in a
      situation where there is no active field, a value of -1 is returned.

   $EXAMPLES$
      ■  Display the screen column for the second posted GET:

         @ 10, 10 GET....
         @ 10, 20 GET....
         @ 10, 30 GET.....

         ? GetFldCol(2)            // Result: 20

      ■  Display the column for the currently active GET field:

         READ                      // Assuming field 1 is active
         Within a UDF or KEYTRAP procedure:
         ? GetFldCol()             // Result: 10

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetFldRow(), CurrentGet(), CountGets()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetFldRow()
   $ONELINER$
      Determines the row of a GET field on the screen
   $SYNTAX$
      GetFldRow([<nField>]) --> nRow

   $ARGUMENTS$
      <nField>  Designates the number of the GET field for which the
      screen is determined.  The default is the currently active field.

   $RETURNS$
      GetFldRow() returns the screen row for the first position of the
      currently active or specified field.  If there is an invalid parameter a
      value of -1 is returned.

   $DESCRIPTION$
      GET FIELD ROW
      This function determines the first row of an input field.  If the
      <nField> parameter is not specified, the function returns the row for
      the currently active field.  When <nField> is an invalid field number or
      if there are no active GET fields, a value of -1 is returned.

   $EXAMPLES$
      ■  Display the row for the second posted GET:

         @ 10, 10 GET....
         @ 11, 20 GET....
         @ 12, 30 GET.....

         ? GetFldRow(2)            // Result: 11
         READ                      // Assuming field 1 is active
         ? GetFldRow()             // Result: 10

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetFldCol(), CurrentGet(), CountGets()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetFldVar()
   $ONELINER$
      Determines the name of a GET field
   $SYNTAX$
      GetFldVar([<nField>]) --> cField

   $ARGUMENTS$
      <nField>  Designates for which number of the GET field to determine
      the name of the accompanying variable.  The default is the currently
      active field.

   $RETURNS$
      GetFldVar() returns the name for the first position of the currently
      active or specified field.  If there is an invalid parameter, a value of
      -1 is returned.

   $DESCRIPTION$
      GET FIELD VARIABLE
      This function determines the name of an input field.  If the <nField>
      parameter is not specified, the function returns the name for the
      currently active field.  With an invalid field number or if there is on
      active field, a value of -1 is returned

   $EXAMPLES$
      ■  Display the name of the variable associated with the second
         posted GET:

         @ 10, 10 GET VAR1
         @ 10, 20 GET VAR2
         @ 10, 30 GET VAR3

         ? GetFldVar(2)               //  "VAR2"

      ■  Display the name for the active field:

         READ                         // Assuming field 1 is active
         ? GetFldVar()                // "VAR1"

      ■  Within a UDF or KEYTRAP procedure:

         ? GetFldVar()                // "VAR1"

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetFldRow(), CurrentGet(), CountGets()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetInput()
   $ONELINER$
      Keyboard input function similar to a GET field
   $SYNTAX$
      GetInput(<cDefault>,[<nRow>],[<nColumn>],[<lSAY>],
         [<cPrompt>]) --> cInput

   $ARGUMENTS$
      <cDefault>  Designates the content and length of the input field.

      <nRow>  Designates the row in which the input occurs.  The default
      is the current cursor position.

      <nColumn>  Designates the column in which the input occurs.  The
      default is the current cursor position.

      <lSAY>  When you specify .T. and close GetInput(), the actual data
      input is displayed with the standard color attribute.

      <cPrompt>  Designates text to display in front of the input field at
      the selected coordinates.  The default is no prompt text.

   $RETURNS$
      GetInput() returns the input string.

   $DESCRIPTION$
      If you call this function, a simple input field is made available.  All
      control keys are interpreted exactly as in a CA-Clipper GET mask.  The
      length and default for the string are specified in the <cDefault>
      parameter.  This allows you to portray a normal input field with VAR=
      Space(length).  The input field starts at the current cursor position or
      at the designated row and column.  Similar to @ ... SAY...GET,  you can
      also display text just before the input text.  The field starting
      position is moved accordingly.

      In the CA-Clipper SET COLOR TO command, the first color you designate
      stands for screen output; the second for input fields. GetInput() uses
      these color designators exactly like CA-Clipper.  If you designate the
      <lSAY> parameter as .T., you can determine (as with a SAY), whether to
      redisplay the data in its amended form at the point of input.  After
      data input is complete, the data displayed on the screen is the same as
      the values returned by the function.  This is useful when an input
      breaks off due to an ESC.  For example, the data is "the quick brown
      fox" and you change it to "the slow brown fox".  If <lSAY> is .T. and
      you press escape, the original data (the quick brown fox) is restored.
      The affected area also contains the default color attribute.

   $NOTES$
      ■  GetInput() uses the CA-Clipper console input internal routines
         and supports the INS display in SCOREBOARD.  In addition, the SET
         ESCAPE, SET BELL, SET INTENSITY, SET DELIMITERS, and SET CONFIRM
         switches are acknowledged.

      ■  Key traps may occur within GetInput() when the cursor position
         within a field is saved.  GetInput() is then called recursively, as
         long as sufficient stack memory is available.

   $EXAMPLES$
      ■  Input at the current cursor position:

         cVar := Space(20)           // 20 position input field
         cVar := GetInput(cVar)      // Retain input attribute

      ■  Input a 10 space field, row 10, column 20:

         cVar := GetInput(Space(10), 10, 20)

      ■  After input is finished, the actual data input is redisplayed
         on the screen.  This area contains the standard color attribute.  The
         input is moved by the text preceding the input field:

         SET CONFIRM ON              //  Close with RETURN
         cVAR := "Default text"
         GetInput(cVar, 10, 20, .T., "Please input: ")

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetSecret()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      GetSecret()
   $ONELINER$
      Keyboard input function for hidden input (similar to a GET field)
   $SYNTAX$
      GetSecret(<cDefault>,[<nRow>],[<nColumn>],[<lSAY>],
         [<cPrompt>]) --> cInput

   $ARGUMENTS$
      <cDefault>  Designates the length and contents of the input field.

      <nRow>  Designates the row in which the input occurs.  The default
      is the current cursor position.

      <nColumn>  Designates the column in which the input occurs.  The
      default is the current cursor position.

      <lSAY>  When you specify .T. and close GetSecret(), the actual data
      input is displayed with the default color attribute.

      <cPrompt>  Designates the text to display in front of the input
      field at the selected coordinates.

   $RETURNS$
      GetSecret() returns the input string.

   $DESCRIPTION$
      If you call this function, a simple input field is made available.  All
      characters input are displayed as asterisks (*) to hide the actual
      input.  All control keys are interpreted exactly as in a CA-Clipper GET
      mask.

      The length and default for the string are specified in the <cDefault>
      parameter.  This allows a normal input field to be portrayed with VAR =
      Space(length).  The input field starts at the current cursor position or
      at the designated row and column.

      Similar to @ ... SAY ... GET, you can also display text just before the
      input field.  The field starting position is moved accordingly

      In the CA-Clipper SET COLOR TO command, the first color you designate is
      used for screen output; the second for input fields. GetSecret() uses
      these color designators exactly like CA- Clipper.  If you designate the
      <lSAY> parameter as .T., you can determine (as with a SAY), whether the
      data is redisplayed in its amended form at the point of input.  However,
      GetSecret() only displays asterisks to hide this data.  This is useful
      when input breaks off due to an ESC, because at least the correct number
      of asterisks is displayed.  The affected area also contains the standard
      color attribute.

   $NOTES$
      ■  GetSecret() uses the CA-Clipper console input internal
         routines and supports the INS display in SCOREBOARD.  In addition,
         the SET ESCAPE, SET BELL, SET INTENSITY, SET DELIMITERS, and SET
         CONFIRM switches are acknowledged.

      ■  Key traps may occur with GetSecret() when the cursor position
         within a field is saved.  You can then call GetSecret() recursively,
         as long as sufficient stack memory is available.

   $EXAMPLES$
      ■  Show the secret field at the current cursor position:

         cVar:= Space(20)            // 20 position secret field
         cVar:= GetSecret(cVar)      // Retain input attribute

      ■  Show the secret a 10-space field,  row 10, column 20:

         cVar:= GetSecret(Space(10), 10, 20)

      ■  After input is finished, the actual data input is redisplayed
         on the screen.  This area contains the standard color attribute.  The
         input is moved by the text preceding the input field:

         SET CONFIRM ON              //  Close with RETURN
         cVar:= "Default text"
         GetSecret(cVar, 10, 20, .T., "Please input: ")

   $PLATFORMS$
      DOS
   $SEEALSO$
      GetInput()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RestGets()
   $ONELINER$
      Restores GET settings from an array
   $SYNTAX$
      RestGets(<aSavedGets>) --> lRestored

   $ARGUMENTS$
      <aSavedGets>  Designates a variable previously created by the
      SaveGets() function.

   $RETURNS$
      RestGets() returns .T. when the GET settings are successfully restored.

   $DESCRIPTION$
      This function restores the information previously saved to an array with
      SaveGets().  This reactivates a previously active GET mask.

   $NOTES$
      Important!  Never use the CA-Clipper CLEAR GETS commands within the
      SaveGets()/RestGets() construction.

   $EXAMPLES$
      F1 is used to activate the HELP procedure from an input mask.  The
      active GET is saved and then newly opened.  Both GET masks use different
      PICTURE definitions like different VALID UDF's:

        CLEAR
         SET KEY 28 TO HELP            // KEYTRAP definition
         cFirstname  :=  Space(10)
         cLastname   :=  Space(10)
         @ 10, 10 GET cFirstname PICTURE "@!"
         @ 11, 10 GET cLastname PICTURE "@!" VALID MAINFUNC()
         READ
      *
      * HELP procedure opens new GET
      *

      PROCEDURE HELP (A, B, C)
         LOCAL aOldGets
         aOldGets := SaveGets()        // Save GETS
         WOpen(4, 30, 20, 76)          // Open window
         WBox()                        // Window border
         cHelp1  :=  Space(10)
         cHelp2  :=  Space(10)
         @ 10, 10 GET cHelp1 PICTURE "@A"
         @ 11, 10 GET cHelp2 PICTURE "@A" VALID HELPFUNC()
         READ

         RestGets(aOldGets)            // Recreate GETS
         WClose()                      // Close window
         RETURN

      FUNCTION MAINFUNC
         SOUND(1000, 10)               //  Short beep
         RETURN(.T.)

      FUNCTION HELPFUNC
         SOUND(1000, 100)              // One long beep
         RETURN(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      SaveGets()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      RestSetKey()
   $ONELINER$
      Restores SET KEY..TO settings from an array
   $SYNTAX$
      RestSetKey(<aSavedTraps>) --> lRestored

   $ARGUMENTS$
      <aSavedTraps>  Designates an array previously created by
      SaveSetKey().

   $RETURNS$
      RestSetKey() returns .T. when you can restore the <aSavedTraps> SET
      KEY..TO settings.

   $DESCRIPTION$
      RESTORE "SET KEY..TO" SETTING
      RestSetKey() restores SET KEY..TO settings previously saved to an array
      with SaveSetKey().

      Important!  It is impossible to use the saved information any longer
      that the runtime of an application.  The character string that results
      cannot be saved to a file and reloaded later.

   $EXAMPLES$
      A key trap definition for the F1 key is changed within a nested input:

      CLEAR
         SET KEY 28 TO HELP1          // First def. for F1
         cFirstname := Space(10)
         cLastname  := Space(10)
         @ 10, 10 GET cFirstname
         @ 11, 10 GET cLastname
      READ

      PROCEDURE HELP1 ( A, B, C)

         WOpen(4, 4, 20, 76)          // Open window
         WBox()                       // Window borders
         aOldKey := SaveSetKey()      // Save SET KEY def.
         aOldGet := SaveGets()        // Save GET def.
         SET KEY 28 TO HELP2          // New def. F1
         cHelp1 := Space(10)          // New GET
      cHelp2 := Space(10)             // ...e.g. help index
         @ 10, 10 GET cFirstname
         @ 11, 10 GET cLastname
         READ
         RestGets(aOldGet)            // Recreate old GET
         RestSetKey(aOldKey)          // Return .T. if OK
         WClose()                     // Close window
         RETURN

      PROCEDURE HELP2 ( A, B, C)      // 2nd help procedure
         * e.g. a second help environment - key layout etc.
         RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      SaveSetKey()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SaveGets()
   $ONELINER$
      Saves the GET settings of the active environment
   $SYNTAX$
      SaveGets() --> aSavedGets

   $RETURNS$
      SaveGets() returns an array that contains all information necessary to
      save the active GET environment.

   $DESCRIPTION$
      SaveGets() only returns the array with the current GET object.  This
      allows you to save it to a LOCAL variable and restore it later to the
      previous GET settings through RestGets().  This way, it is also possible
      to newly open a GET mask or VALID UDF from within a KEYTRAP procedure
      without losing the previous one.

   $NOTES$
      Important!  Never use the CA-Clipper CLEAR or CLEAR GETS commands
      within the SaveGets()/RestGets() construction.

      ■  The array returned by SaveGets() is valid only during the
         current program run.  Therefore, it is not useful to save this data
         in the file.

      ■  Effective with CA-Clipper, the cursor position is always saved
         when you leave an input field.  If you do not want to do this, place
         the key code for Pos1 in the keyboard buffer through KEYSEND at the
         end of the trap procedure.

   $EXAMPLES$
      F1 activates the HELP procedure from an input mask.  The active GET is
      saved there and then newly opened.  Both GET masks use different PICTURE
      definitions like different VALID UDF's:

        CLEAR
         SET KEY 28 TO HELP            // KEYTRAP definition
         cFirstname  :=  Space(10)
         cLastname   :=  Space(10)
         @ 10, 10 GET cFirstname PICTURE "@!"
         @ 11, 10 GET cLastname PICTURE "@!" VALID MAINFUNC()
         READ
      *
      * HELP procedure opens new GET
      *
      PROCEDURE HELP (A, B, C)
         LOCAL aOldGets
         aOldGets := SaveGets()        // Save GETS
      WOpen(4, 30, 20, 76)             // Open window
         WBox()                        // Window border
         cHelp1  :=  Space(10)
         cHelp2  :=  Space(10)
         @ 10, 10 GET cHelp1 PICTURE "@A"
         @ 11, 10 GET cHelp2 PICTURE "@A" VALID HELPFUNC()
         READ
         RestGets(aOldGets)            // Recreate GETS
         WClose()                      // Close window
         RETURN

      FUNCTION MAINFUNC
         SOUND(1000, 10)               // Short beep
         RETURN(.T.)

      FUNCTION HELPFUNC
         SOUND(1000, 100)              // One long beep
         RETURN(.T.)

   $PLATFORMS$
      DOS
   $SEEALSO$
      RestGets()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SaveSetKey()
   $ONELINER$
      Saves SET KEY..TO settings in an array
   $SYNTAX$
      SaveSetKey() --> aSavedTraps

   $RETURNS$
      SaveSetKey() returns an array within which information for the current
      SET KEY..TO settings are saved.

   $DESCRIPTION$
      SAVE SET KEY..TO SETTINGS
      SaveSetKey() saves the current SET KEY..TO settings in an array.  This
      makes it possible to redefine function keys already assigned, and to
      later restore the old settings with RestSetKey().

   $NOTES$
      ■  The array you create is valid only for the current program
         run.  Therefore, is not useful to save this data in the file.

   $EXAMPLES$
      A key trap definition for the F1 key is changed within a nested input:

        CLEAR
         SET KEY 28 TO HELP1         // First def. for F1
         cFirstname := Space(10)
         cLastname  := Space(10)
         @ 10, 10 GET cFirstname
         @ 11, 10 GET cLastname
         READ

      PROCEDURE HELP1 ( A, B, C)
         WOpen(4, 4, 20, 76)         // Open window^n   WBox()
         // Window borders
         aOldKey := SaveSetKey()     // Save SET KEY def.
         aOldGet := SaveGets()       // Save GET def.
         SET KEY 28 TO HELP2         // New def. F1
         cHelp1 := Space(10)         // New GET
         cHelp2 := Space(10)         // ...e.g. help index
         @ 10, 10 GET cFirstname
         @ 11, 10 GET cLastname
         READ
         RestGets(aOldGet)            // Recreate old GET
         RestSetKey(aOldKey)          // Return .T. if OK
         WClose()                     // Close window
         RETURN

      PROCEDURE HELP2 ( A, B, C)      // 2nd help procedure
         * e.g. a second help environment - key layout etc.
         RETURN

   $PLATFORMS$
      DOS
   $SEEALSO$
      RestSetKey(), SaveGets()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Functions For IBM PC-LAN
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      This chapter includes network functions for IBM PC LAN/Microsoft MS-NET
      software.

      b>PC LAN/MS-NET</b>

      PC LAN/MS-NET is software that has been offered for networks by IBM and
      Microsoft.  Both programs are based upon the NETBIOS protocol;
      CA-Clipper does not directly affect the NETBIOS protocol.  All internal
      function calls to the network software occur under DOS, which requires
      version 3.1 or higher.  The functions in this group are in the format
      NETXXX().

      An exception is the NetDisk() function.  It can also determine whether a
      drive is local or remote under other network software.  This assumes
      that the network software properly supports DOS in the background.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NetCancel()
   $ONELINER$
      Releases the redirection of a local device
   $SYNTAX$
      NetCancel(<cLocalDevice>) --> lReleased

   $ARGUMENTS$
      <cLocalDevice>  Designates the name for the local device, for which
      an existing redirection in the network is released.

   $RETURNS$
      NetCancel() returns .T. when a redirection existed for the designated
      device and it was released.

   $DESCRIPTION$
      NETWORK CANCEL REDIRECTION
      With NetCancel(), an existing redirection for a local device can be
      released.  You call the function by simply specifying the device name,
      d: or LPTn:.

      If the return value is .F., the device did not exist or was not
      previously redirected.

   $NOTES$
      WARNING!  Make sure that no drive on which files are still open is
      rendered invalid when you use NetCancel().  This situation leads to
      problems, and under certain circumstances, to data loss.

   $EXAMPLES$
      Make all redirected printer devices local

      nCounter    :=  0
      cLocalName  :=  NETLOCNAME(nCounter)
      DO WHILE .NOT. Empty(cLocalName)
         IF cLocalName $"LPT1:LPT2:LPT3:PRN:"   // Is device a printer?
            NetCancel(cLocalName)
         ENDIF
         nCounter    := nCounter +1
         cLocalName  := NETLOCNAME(nCounter)
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NetRedir(), NETLOCNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NetDisk()
   $ONELINER$
      Determines whether a drive is local or resident on the server
   $SYNTAX$
      NetDisk(<cDrive>) --> lServerDrive

   $ARGUMENTS$
      <cDrive>  Designates the drive that is tested in a range from A to
      Z.

   $RETURNS$
      NetDisk() returns .T. when the specified drive is a network drive.

   $DESCRIPTION$
      NETWORK DISK
      This function allows you to determine if a drive in the range of A: to
      Z: is local or remote.  Remote means that a drive is actually resident
      on a file server and that the local device address has been redirected
      through DOS.

   $NOTES$
      ■  Since this is DOS information, this function works correctly
         with those networks that support DOS.

   $EXAMPLES$
      Test all drives to determine if they are local or resident on the
      server:

      FOR I = Asc("A") TO Asc("Z")
         ? NetDisk(Chr(I))
      NEXT I
   $PLATFORMS$
      DOS
   $SEEALSO$
      NetRedir()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NETLOCNAME()
   $ONELINER$
      Determines the name of a local redirected device
   $SYNTAX$
      NETLOCNAME(<nDevice>) --> cDeviceName

   $ARGUMENTS$
      <nDevice>  Designates the location within the DOS redirection table.

   $RETURNS$
      NETLOCNAME() returns the local name for the designated location in the
      DOS redirection table (<nDevice>), or a null string if no name is
      available.

   $DESCRIPTION$
      NETWORK LOCAL NAME
      Under PC LAN/MS-NET, server devices can be redirected to local devices
      using the NET USE <local> <remote> command.  DOS logs these redirections
      in its redirection table.  In this way, NETLOCNAME() allows you to
      determine all the local devices that have been redirected to a server
      device.

   $NOTES$
      ■  Using NetRmtname() allows you to determine the name of the
         corresponding server device.

   $EXAMPLES$
      Determine all the local devices that have been redirected to a server
      device:

      nCounter    :=  0
      cLocalName  :=  NETLOCNAME(nCounter)
      DO WHILE .NOT. Empty(cLocalName)
         ? cLocalName                      // Display local device
         nCounter    := nCounter +1
         cLocalName  := NETLOCNAME(nCounter)
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NetRmtname()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NetPrinter()
   $ONELINER$
      Determines whether the current printer is a local or network printer
   $SYNTAX$
      NetPrinter() --> lServerPrinter

   $RETURNS$
      NetPrinter() returns .T. when the printer installed using the CA-Clipper
      SET PRINTER TO <LPTn> command has been redirected onto a network server.

   $DESCRIPTION$
      NETWORK PRINTER
      This function allows you to determine if the printer installed using the
      CA-Clipper SET PRINTER TO <LPTn> command is local or resides on a
      network server.

   $NOTES$
      ■  This function cannot be used in a Novell network, because
         there the redirection occurs on a deeper level (INT 17h).  However,
         you can use the NNETCAPACT() function in a Novell Network.

   $EXAMPLES$
      Determine whether LPT1 and LPT2 are local or remote:

      SET PRINTER TO LPT1
      ? NetPrinter()                        // .F., local printer
      SET PRINTER TO LPT2
      ? NetPrinter()                        // .T., network printer
   $PLATFORMS$
      DOS
   $SEEALSO$
      NetRedir(), NNetwork(), NNETCAPACT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NetRedir()
   $ONELINER$
      Redirects a local device to a server
   $SYNTAX$
      NetRedir(<cLocalDevice>, <cServerDevice>,
         [<cPassword>])    --> lRedirection

   $ARGUMENTS$
      <cLocalDevice>  Designates the name of the local device (LPTn:,
      PRN:, or d:).

      <cServerDevice>  Designates the complete path for the server
      (\\<Servername>\<Devicename>).

      <cPassword>  Can designate a password when it is required by the
      server.

   $RETURNS$
      NetRedir() returns .T. when the specified local device has been
      redirected to the selected server device.

   $DESCRIPTION$
      NETWORK REDIRECTION
      Under PC LAN/MS-NET, server devices can be redirected to local devices
      using the NET USE <local> <remote> command.  Exactly the same thing can
      be accomplished using the NetRedir() function from within an
      application.  The function returns .T. when the redirection has been
      carried out.  A return of .F. could occur for several reasons:

      ■  The designated drive is not accepted.  Either this drive is
         already physically available or LASTDRIVE in CONFIG.SYS has to be set
         higher.

      ■  The device is not available on the server.  Use NET SHARE on
         the selected server to review all the devices available there.

      ■  The password is incorrect.  Check the password that the server
         has designated for the device.

      ■  Too many devices have already been allocated.  In this
         instance you must change some of the flags with the NET START command
         (see PC LAN/MS-NET manual).

   $NOTES$
      ■  The redirections accomplished here are not listed when you use
         NET USE.

   $EXAMPLES$
      ■  Create a new drive H:

         ? NetRedir("H:", "\\SERVER\DRIVEC")            // .T. if OK

      ■  In this example, the server device asks for a password:

         ? NetRedir("H:", "\\SERVER\DRIVEC", "SECRET")  // .T. if OK

      ■  Allocate a server printer to LPT2:

         ? NetRedir("LPT2:", "\\SERVER\PRINTER")        // .T. if OK
   $PLATFORMS$
      DOS
   $SEEALSO$
      NetCancel(), NETLOCNAME(), NetRmtname()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NetRmtname()
   $ONELINER$
      Determines the name of a server device for a local device
   $SYNTAX$
      NetRmtname(<nDevice>) --> cServerDevice

   $ARGUMENTS$
      <nDevice>  Designates the location within the DOS redirection table.

   $RETURNS$
      NetRmtname() returns the local name for the designated location in the
      DOS redirection table (<nDevice>), or a null string if no name is
      available.

   $DESCRIPTION$
      NETWORK REMOTE NAME
      Under PC LAN/MS-NET server devices can be redirected to local devices
      using the NET USE <local> <remote> command.  DOS logs these redirections
      in its redirection table.  In this way, NetRmtname() allows you to
      determine all the local devices that have been redirected to a server
      device.

   $NOTES$
      ■  Using NETLOCNAME() allows you to determine the name of the
         corresponding local device.

   $EXAMPLES$
      Determine all the devices used by the server:

      nCounter     :=  0
      cDeviceName  :=  NetRmtname(nCounter)
      DO WHILE .NOT. Empty(cDeviceName)
         ? cDeviceName                     // Display server device
         nCounter     := nCounter +1
         cDeviceName  := NetRmtname(nCounter)
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NETLOCNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      Network()
   $ONELINER$
      Tests to see if a network is active
   $SYNTAX$
      Network() --> lActiveNet

   $RETURNS$
      Network() returns .T. when a PC LAN/MS-NET or a Novell network is
      available.

   $DESCRIPTION$
      With Network(), you can determine whether or not an IBM PC LAN/MS-NET or
      Novell network is available and active.  Using NNetwork() allows you to
      further differentiate to see if you are dealing with a Novell network.

   $EXAMPLES$
      Test to see if one of the two networks is available:

      IF Network()
         * ...
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNetwork()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Low Level Bindery Access
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      Each Netware file server maintains a database of users and resources
      available on the network.  This special-purpose database is called the
      bindery.  The bindery contains objects uniquely specified by an object
      name and an object type.  Possible object types are: users, user groups,
      print queues, or print servers.  Each object has associated with it a
      number of properties that can be addressed with names and contain
      information about the object.  For example, the property GROUPS_I'M_IN
      contains a list of user groups of which a user is a member.

      The functions of this chapter allow a low level access to the bindery.
      This provides you with maximum flexibility for programming within
      Novell.  The low level functions allow the creation of your own bindery
      objects as well as the development of bindery analyzers.

      However, even though the bindery concept has a high security level,
      incorrect use of the low level bindery functions can be very dangerous
      if you have supervisor or equivalent access rights.  The network could
      be brought to a standstill.  You should use these functions only with
      extensive knowledge of the bindery concept, the Novell API, and bindery
      management.  For example, you must know the terms object, item, and set
      property.

      For frequent, complex purposes that require bindery access, like adding
      a user to a group, CA-Clipper Tools provides high level functions that
      can be used without a problem.  These functions are based on the low
      level functions and are available in CA-Clipper source code.

      Netware internally uses a high low sequence to store numeric values,
      which is contrary to the standard format of the 80x86 processor family
      (low high sequence).  For efficiency reasons, the Netware functions of
      CA-Clipper Tools expect numeric values that are passed to Netware
      (object types or object IDs) in the high low sequence.  However, this
      will not affect the practical work with the CA-Clipper Tools because
      symbolic constants are defined in the high-low format in the header file
      CTNNET.CH for the most important object types.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETADDSET()
   $ONELINER$
      Adds a bindery object to a set property
   $SYNTAX$
      NNETADDSET(<cObjName>,[<nType>],<cPropName>,<cMember>,
         [<cMemberType>],[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the bindery object that is
      processed.

      <nType>  Designates a numeric value that indicates the type of
      <cObjName>.  The header file CTNNET.CH contains symbolic constants for
      the object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates the object type OBJ_USER.

      <cPropName>  Designates the name of the set property of <cObjName>.

      <cMember>  Designates the name of the bindery object that is stored
      in the property <cPropName> of the bindery object <cObjName>.

      <cMemberType>  Designates a numeric value that indicates the type of
      <cMember>.  The default value indicates the object type OBJ_USER.

      <cServer>  Designates the name of the file server that contains the
      bindery that is accessed.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETADDSET() returns .T. if the bindery object has been added
      successfully.  If an error occurs, the Novell error code can be queried
      with the NNETERROR() function.

   $DESCRIPTION$
      Important!  NNETADDSET() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET ADD BINDERY OBJECT TO SET
      Internally, Novell Netware differentiates between two possible property
      types: item and set property.  The function NNETADDSET() allows the
      storage of information to a set property.  Set properties contain a list
      of references to other bindery objects.  For example, the GROUP_MEMBERS
      property contains a list of users that are members of a user group.

      The parameters <cObjName> and <nType> describe the object that is
      processed.  <cPropName> is the name of the property.  The property must
      have been created before (for example, with the NNETCRTPRP() function).
      <cMember> and <cMemberType> specify the bindery object that is added to
      <cPropName>.  By passing the parameters <cServer> or <nConId>, it is
      possible to access the bindery of any connected file server.  The
      connection ID of a server can be determined with the functions
      NNETATTACH() or NNETLOGIN().

      Prerequisites for a successful call of NNETADDSET() are sufficient
      bindery and property access rights.  The necessary property access
      rights depend on the property security of the property that is
      manipulated.  For efficiency reasons, user defined object types must be
      passed in the high-low format.

   $EXAMPLES$
      ■  Add user MIKE to the MARKET group :

         #include "ctnnet.ch"

         IF NNETADDSET('MARKET',OBJ_GROUP,'GROUP_MEMBERS','MIKE')
         ? 'User added successfully!'
         ELSE
         ? 'No user added!'
         ENDIF

      ■  To add a user to a group, it is also necessary to add the
         group to two user properties.  Use NNETADDGRP() when adding a user to
         a group.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDGRP(), NNETCRTPRP(), NNETDELSET(), NNETWRTITM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETBINACC()
   $ONELINER$
      Determines the bindery security access level
   $SYNTAX$
      NNETBINACC([<cServer>|<nConId>]) --> nRights

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server for which the
      bindery security access level is determined.  Your workstation must be
      attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETBINACC() returns the bindery security access level of the currently
      logged in user.  nRights can be a numeric value between 0 and 3.

   $DESCRIPTION$
      NOVELL NET BINDERY ACCESS LEVEL
      All bindery objects and their properties have security levels for  read
      and write access.  For example, the security code can be defined when a
      new bindery object is created with the NNETCRTOBJ() function.  The
      access to an object or a property is possible only if the user's access
      right is equivalent to or higher than the security level defined for the
      operation.  With NNETBINACC(), you can determine the security access
      level.  The function returns a numeric value between 0 and 3.

      Table 18.1:  Security Access Levels
      <table>
          Value   Definition

          0       User has not logged in to the file server
          1       User has logged in to the file server
          2       User has logged in to the file server with password
          3       User has logged in to the file server as supervisor
         </table>

      With the parameters <cServer> or <nConId>, the security access level can
      be determined for any attached file server.  The connection ID of a file
      server can be determined with the functions NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      Determine the bindery security access level; if the return value is 3
      (supervisor), delete a user:

      #include "ctnnet.ch"

      IF NNETBINACC()=3
      NNETDELOBJ('GUEST',OBJ_USER)
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTOBJ(), NNETCRTPRP(), NNETDELOBJ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETBINCL()
   $ONELINER$
      Closes a bindery
   $SYNTAX$
      NNETBINCL([<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server where the bindery
      is closed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETBINCL() returns .T. if the bindery has been closed successfully.

   $DESCRIPTION$
      Important!  NNETBINCL() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET BINDERY CLOSE
      Under Netware, the bindery is physically organized as two files,
      NET$BIND.SYS and NET$BVAL.SYS.  These files are hidden files in the
      SYS:SYSTEM directory.  During network operation these files are
      exclusively open and cannot be accessed directly.  For example, to
      archive the bindery files, the bindery must be closed.  The bindery can
      be closed with the NETBINCL() function, but supervisor rights are
      required.

      With the parameters <cServer> or <nConId>, the bindery can be closed on
      any attached file server.  The connection ID of a file server can be
      determined with the functions NNETATTACH() or NNETLOGIN().

      Important!  While the bindery is closed, much of the network is not
      functional.  The bindery should not be closed if another user is logged
      in.  The time that the bindery is closed should be kept to a minimum.

   $EXAMPLES$
      In the following example, drive K: is mapped to the SYS:SYSTEM directory
      of the current file server.  If the bindery has been closed
      successfully, the bindery files are copied to a local drive with the
      FileCopy() function.  After the FileCopy(), the bindery is reopened with
      the NNETBINOP() function:

      IF NNETBINCL()
      FileCopy('K:NET$BIND.SYS','C:\NET$BIND.SYS')
      FileCopy('K:NET$BVAL.SYS','C:\NET$BVAL.SYS')
      NNETBINOP()
      ELSE
      ? 'Bindery could not be closed!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETBINACC(), NNETBINOP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETBINOP()
   $ONELINER$
      Opens a bindery
   $SYNTAX$
      NNETBINOP([<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server where the bindery
      is opened.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETBINOP() returns .T. if the bindery has been opened successfully.

   $DESCRIPTION$
      Important!  NNETBINOP() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET BINDERY OPEN
      NNETBINOP() reopens the bindery after it has been closed with
      NNETBINCL().  Supervisor rights are required.

      With the parameters <cServer> or <nConId>, the bindery can be opened on
      any attached file server.  The connection ID of a file server can be
      determined with the functions NNETATTACH() or NNETLOGIN().

   $NOTES$
      ■  It is not necessary to open the bindery explicitly before an
         access.  The bindery files are kept open automatically.

   $EXAMPLES$
      See the examples for NNETBINCL().
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETBINACC(), NNETBINCL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCRTOBJ()
   $ONELINER$
      Creates a new bindery object
   $SYNTAX$
      NNETCRTOBJ(<cName>,[<nType>],[<nDynamic>],[<nSafe>],
         [<cServer>|<nConId>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the new bindery object.  Under
      Netware, object names can be up to 47 characters long.

      <nType>  Designates a numeric value that indicates the type of
      <cName>.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates the object type OBJ_USER.

      <nDynamic>  Designates whether the bindery object is static (0) or
      dynamic (1).  The default value is static (0).

      <nSafe>  Designates the value for the object security.  The value
      specifies the rights required to find (read) or to modify (write) the
      object in the bindery.  The settings are defined in a bit-coded mask.
      The low-ordered bits control the read access; the high-ordered bits
      control the write access to the bindery object.

      Table 18.2:  Values for Object Security
      <table>
          Value  Hex  Bin     Definition

          0      0    0000    Access allowed to all users
          1      1    0001    Access allowed to users who have logged in to the
                              file server
          2      2    0010    Access allowed to users who have logged in to the
                              file server with password
          3      3    0011    Access allowed to users who have logged in to the
                              file server as the supervisor or as a user who has
                              supervisor equivalence
          4      4    0100    Access only allowed to the Netware operating system
         </table>

      The default value for <nSafe> is 49 (31h).  The mask defines write
      access for supervisors and equivalents, and read access for all logged
      in users.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETCRTOBJ() returns .T. if the new object has been created
      successfully.  If an error occurs, the Novell error code can be queried
      with the NNETERROR() function.

   $DESCRIPTION$
      Important!  NNETCRTOBJ() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET CREATE BINDERY OBJECT
      NNETCRTOBJ() allows you to create a new bindery object.  Supervisor
      rights are required.  For efficiency reasons, user defined object types
      must be passed in high-low format.

      For the definition of the security mask, the four bits for the write
      access must be followed by the four bits for the read access.  The
      resulting eight-bit string must be passed as decimal value for <nSafe>.

   $EXAMPLES$
      ■  Create a static object of the type group under the name DEV:

         #include "ctnnet.ch"

         IF NNETCRTOBJ('DEV',OBJ_GROUP)
         ? 'Group created successfully!'
         ELSE
         ? 'Group could not be created!'
         ENDIF

      ■  To create groups, use the NNETCRTGRP function in CA-Clipper
         Tools.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTPRP(), NNETDELOBJ(), NNETERROR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCRTPRP()
   $ONELINER$
      Creates a new bindery property
   $SYNTAX$
      NNETCRTPRP(<cObjName>,[<nObjType>],<cPropName>
         [<nFlag>],[<nSafe>],[<cServer>|<nConId>])
          --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the object for which a new
      property is created.

      <nObjType>  Designates a numeric value that indicates the object
      type.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates the object type OBJ_USER.

      <cPropName>  Designates the name of the new property.  The name can
      be up to 15 characters long.

      <nFlag>  Designates the value for the property flag.  With the
      property flag, two property characteristics can be set.  With bit 1 you
      can determine if the property is static (bit 1 = 0) or dynamic (bit
      1=1).  Bit 2 specifies an item (bit 2 = 0) or a set (bit 2 = 1)
      property.  The following table contains possible values for <nFlag>:

      Table 18.3:  Possible property flags
      <table>
          Value   Sym. Con.    Definition

          0       PRP_ITEM     Static item property
          1                    Dynamic item property
          2       PRP_SET      Static set property
          3                    Dynamic set property
         </table>

      Symbolic constants can be found in the header file CTNNET.CH.  The
      default value for <nFlag> is 0.

      <nSafe>  Designates the value for the property security.  For more
      information, see the description of the function NNETCRTOBJ(). The
      default value is 49 (31h).

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETCRTPRP() returns .T. if the new property <cPropName> has been
      created successfully.  If an error occurs, the Novell error code can be
      queried with the NNETERROR() function.

   $DESCRIPTION$
      Important!  NNETCRTPRP() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET CREATE PROPERTY
      NNETCRTPRP() allows you to create a new property for a bindery object.
      Sufficient bindery and object access rights are required.  The necessary
      object access rights depend on the object security of the object that is
      manipulated.  For efficiency reasons, user defined object types must be
      passed in the high-low format.

   $EXAMPLES$
      ■  The property GROUP_MEMBERS is added to the group DEV.  This
         property is defined by Novell and must be created as set property:

         #include "ctnnet.ch"

         IF NNETCRTPRP('DEV',OBJ_GROUP,'GROUP_MEMBERS',PRP_SET)
         ? 'Property created successfully!'
         ELSE
         ? 'Property could not be created!'
         ENDIF

      ■  To add a group, use the NNETADDGRP() function in CA-Clipper
         Tools.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTOBJ(), NNETDELPRP(), NNETERROR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDELOBJ()
   $ONELINER$
      Deletes a bindery object
   $SYNTAX$
      NNETDELOBJ(<cName>,[<nType>],[<cServer>|<nConId>])
          --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName> Designates the name of the bindery object that is deleted.

      <nType>  Designates a numeric value that indicates the type of
      <cName>.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates the object type OBJ_USER.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDELTOBJ() returns .T. if the object <cName> has been deleted
      successfully.  If an error occurs, the Novell error code can be queried
      with the NNETERROR() function.

   $DESCRIPTION$
      Important!  NNETDELOBJ() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET DELETE BINDERY OBJECT
      NNETDELOBJ() allows you to delete bindery objects.  Users and user
      groups can be deleted.  With the parameters <cServer> or <nConId>, the
      bindery of any attached server can be accessed.  The connection ID of a
      server can be determined with NNETATTACH() or NNETLOGIN().

      Supervisor rights are required to delete a bindery object.  For
      efficiency reasons, user defined object types must be passed in the high-
      low format.

   $NOTES$
      ■  CA-Clipper Tools has no high level function available to
         delete users or user groups.  Use NNETDELOBJ().

   $EXAMPLES$
      ■  Delete user GUEST:

         IF NNETDELOBJ('GUEST')
         ? 'User has been deleted successfully!'
         ELSE
         ? 'User could not be deleted!'
         ENDIF

      ■  Delete group DEV:

         #include "ctnnet.ch"

         IF NNETDELOBJ('DEV',OBJ_GROUP)
         ? 'Group has been deleted successfully!'
         ELSE
         ? 'Group could not be deleted!'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTOBJ(), NNETDELPRP(), NNETERROR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDELPRP()
   $ONELINER$
      Deletes an object property
   $SYNTAX$
      NNETDELPRP(<cObjName>,[<nObjType>],<cPropName>,
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName> Designates the name of the bindery object that is
      processed.

      <nObjType>  Designates a numeric value that indicates the object
      type.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates the object type OBJ_USER.

      <cPropName>  Designates the name of the property that is deleted.
      The name can contain the wildcards "?" and "*".  In this case, all
      properties matching the search mask are deleted.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDELPRP() returns .T. if the property <cPropName> has been deleted
      successfully.  If an error occurs, the Novell error code can be queried
      with the NNETERROR() function.

   $DESCRIPTION$
      Important!  NNETDELPRP() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET DELETE PROPERTY
      NNETDELPRP() allows you to delete properties of a bindery object.
      Sufficient bindery and object access rights are required.  The necessary
      object access rights depend on the object security of the object that is
      manipulated.  For efficiency reasons, user defined object types must be
      passed in the high-low format.

   $EXAMPLES$
      ■  Delete property IDENTIFICATION of the user MICK:

         IF NNETDELPRP('MICK',,'IDENTIFICATION')
         ? 'Property has been deleted successfully!'
         ELSE
         ? 'Property could not be deleted!'
         ENDIF

      ■  The property IDENTIFICATION of a user object contains a user's
         full name.  In the example above, this information is deleted.  Other
         information, such as the user name (login name) or the password is
         not affected.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTPRP(), NNETDELOBJ(), NNETERROR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDELSET()
   $ONELINER$
      Deletes a bindery object from a set property
   $SYNTAX$
      NNETDELSET(<cName>,[<nType>],<cProperty>,<cMember>,
         [<cMemberType>],[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the bindery object that is
      processed.

      <nType>  Designates a numeric value that indicates the type of
      <cName>.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates the object type OBJ_USER.

      <cProperty>  Designates the name of a set property of <cName>.

      <cMember>  Designates the name of the bindery object that is deleted
      from <cProperty> of the bindery object <cName>.

      <cMemberType>  Designates a numeric value that specifies the type of
      <cMember>.  The default value is OBJ_USER.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDELSET() returns .T. if the operation has been completed
      successfully.  If an error occurs, the Novell error code can be queried
      with the NNETERROR() function.

   $DESCRIPTION$
      Important!  NNETDELSET() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET DELETE BINDERY OBJECT FROM SET
      Internally, Novell Netware has defined two different property types:
      item and set properties. NNETDELSET() allows you to delete information
      from a set property.  A set property contains a list of references to
      other bindery objects.  An example is the GROUP_MEMBERS property that
      contains a list of users who are members of a user group.

      The parameters <cName> and <cType> identify the object, and <cProperty>
      is the name of the property.  <cMember> and <cMemberType> define the
      bindery object that is deleted from  <cProperty>.  With the parameters
      <cServer> or <nConId>, the bindery of any attached server can be
      accessed.  The connection ID of a server can be determined with
      NNETATTACH() or NNETLOGIN().

      To delete information from a property, sufficient bindery and property
      access rights are required.  The necessary property access rights depend
      on the property security of the property that is manipulated.  For
      efficiency reasons, user defined object types must be passed in the high-
      low format.

   $NOTES$
      ■  NNETDELSET() deletes only the reference to the bindery object
         <cMember> from <cProperty>.  The object itself is not affected or
         deleted.

   $EXAMPLES$
      ■  Delete user MIKE from the MARKET group:

         #include "ctnnet.ch"

         IF NNETDELSET('MARKET',OBJ_GROUP,'GROUP_MEMBERS','MIKE')
         ? 'User has been deleted from group!'

         ELSE
         ? 'User could not be deleted!'
         ENDIF

      ■  To delete a user from a group, it is also necessary to delete
         the group from two user properties.  Use the function NNETREMGRP() to
         remove a user from a group.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDSET(), NNETREMGRP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETINSET()
   $ONELINER$
      Determines if a bindery object belongs to a set property
   $SYNTAX$
      NNETINSET(<cObjName>,[<nType>],<cPropName>,<cMember>,
         [<cMemberType>],[<cServer>|<nConId>]) --> lMember

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the bindery object that is
      processed.

      <nType>  Designates a numeric value that indicates the type of
      <cName>.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates the object type OBJ_USER.
      When you work with numeric values, you must take into account that, for
      efficiency reasons, NNETRDITM() expects the object type as an integer in
      the high-low format.

      <cPropName>  Designates the name of a set property of <cObjName>.

      <cMember>  Designates the name of the bindery object for which the
      membership in <cPropName> of <cObjName> is checked.

      <cMemberType>  Designates a numeric value that indicates the type of
      <cMember>.  The default value indicates the object type OBJ_USER.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETINSET() returns .T. if <cMember> belongs to the set property
      (<cPropName>) of the bindery object (<cObjName>).  If < cMember> does
      not belong to the set property (<cPropName>) the function returns .F..

   $DESCRIPTION$
      NOVELL NET OBJECT IN SET
      Internally, Novell Netware has defined two different property types:
      item and set properties.  A set property contains a list of references
      to other bindery objects.  An example is the GROUP_MEMBERS property that
      contains a list of users that are members of a user group.  With the
      function NNETINSET(), you can check to see if a bindery object,
      specified with the parameters <cMember> and <cMemberType>, belongs to
      the set property (<cPropName> of the bindery object (<cObjName> and
      <cType>).  With the parameters <cServer> or <nConId>, the bindery of any
      attached server can be accessed.  The connection ID of a server is
      returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      Check to see if user MIKE has supervisor rights:

      #include "ctnnet.ch"

      IF NNETINSET('MIKE',OBJ_USER,'SECURITY_EQUALS','SUPERVISOR',OBJ_USER)
      ? 'User has supervisor rights!'
      ELSE
      ? 'User has no supervisor rights!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDSET(), NNETGRPMEM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETNUMMEM()
   $ONELINER$
      Determines the number of members of a set property
   $SYNTAX$
      NNETNUMMEM(<cObjName>,[<nType>],<cPropName>,
         [<cServer>|<nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the bindery object that is
      processed.

      <nType>  Designates the object type of <cObjName>.  The header file
      CTNNET.CH contains symbolic constants for a number of object types.
      When you work with numeric values, take into account that, for
      efficiency reasons, the function NNETNUMMEM() expects the object type in
      the high-low format.  The default value indicates the object type
      OBJ_USER.

      <cPropName>  Designates the name of the property for which the
      members are counted.  <cPropName> must describe a set property.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETNUMMEM() returns the number of members of the property <cPropName>
      of <cObjName>.  If an error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET COUNT MEMBERS
      Internally, Novell Netware defines two possible property types: item and
      set properties.  Unlike an item property that accepts any kind of data,
      the set property contains references to other bindery objects.  These
      bindery objects are the members of the set property.  This function
      allows you to determine the total of members of a set property without
      having to specify all the members explicitly.

      The object type <nType> must be passed in the high-low format (see the
      Introduction to this chapter).  For the object types, use the symbolic
      constants of the header file CTNNET.CH.  With the parameters <cServer>
      or <nConId>, the bindery of any attached server can be accessed.  The
      connection ID of a server is returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      Determine the number of members of the group EVERYONE:

      #include "ctnnet.ch"

      ? NNETNUMMEM('EVERYONE',OBJ_GROUP,'GROUP_MEMBERS')
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETOBJID()
   $ONELINER$
      Determines the object ID with the object name and the object type
   $SYNTAX$
      NNETOBJID(<cObjName>,<nObjType>,<cServer>|<nConId>])
          --> nObjId

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the object for which the ID is
      determined.

      <nObjType> Designates a numeric value that specifies the object
      type.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use in conjunction with the bindery
      functions of CA-Clipper Tools.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETOBJID() returns the object ID of the bindery object that is
      specified by <cObjName> and <nObjType> on <cServer>.  For efficiency
      reasons, the object ID is returned in the high-low format.  If an error
      occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET OBJECT ID
      Each object in the bindery of a file server is identified by its object
      ID.  NNETOBJID() allows you to determine the ID with the object name and
      the object type.  For efficiency reasons, numeric values for <nObjType>
      must be passed in the high-low format.

   $EXAMPLES$
      Determine the subdirectories of a print queue:

      #include "ctnnet.ch"
      nId=NNETOBJID('PRINTQ_0',OBJ_PRINTQUEUE)
      ? 'Queue directory:'+HexToStr(L2Bin(nId))+'.QDR'
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETUSERID()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETOBJNAM()
   $ONELINER$
      Determines the object name of an object ID
   $SYNTAX$
      NNETOBJNAM(<NId>, [<cServer>|<nConId>]) --> cObjName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <NId>  Designates a bindery object ID.  For efficiency reasons, the
      ID must be passed in the high-low format (see the Introduction to this
      chapter).

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NETOBJNAM() returns the name of the bindery object, specified by <NId>.
      If an error occurs, the function returns a null string.

   $DESCRIPTION$
      NOVELL NET OBJECT NAME
      Within a file server, each bindery object is given a unique object ID
      with a length of four bytes.  With NNETOBJNAM(), you can determine the
      name of the related bindery object.  NNETOBJNAM() can be used in
      conjunction with functions that return an object ID in the high-low
      format (for example, NNETRDSET()).

   $EXAMPLES$
      Read the property SECURITY_EQUALS of user MIKE, and return the object
      names of the members (the SECURITY_EQUALS property contains a list of
      objects to which an object is security-equivalent):

      #include "ctnnet.ch"

      aIn=NNETRDSET('MIKE',OBJ_USER,'SECURITY_EQUALS')
      FOR i=1 TO Len(aIn)
      ?  NNETOBJNAM(aIn[i])
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETOBJTYP(), NNETRDSET()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETOBJSEC()
   $ONELINER$
      Sets the security of a bindery object
   $SYNTAX$
      NNETOBJSEC(<cObjName>,<nObjType>,<nSafe>,
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the object for which the security
      is modified.

      <nObjType>  Designates a numeric value that specifies the object
      type.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use in conjunction with the bindery
      functions of CA-Clipper Tools.

      <nSafe>  Designates the new value for the object security.  This
      value specifies the rights required to find (read) or to modify (write)
      the object in the bindery.  The settings are defined with a bit-coded
      mask.  The low-ordered bits control the read access; the high-ordered
      bits control the write access to the bindery object.

      Table 18.4:  Values for Object Security
      <table>
          Value  Hex  Bin     Definition

          0      0    0000    Access allowed to all users
          1      1    0001    Access allowed to users who have logged in to the
                              file server
          2      2    0010    Access allowed to users who have logged in to the
                              file server with password
          3      3    0011    Access allowed to users who have logged in to the
                              file server as the supervisor or as a user who has
                              supervisor equivalence
          4      4    0100    Access only allowed to the network operating system
         </table>

      <cServer>  Designates the name of the file server that is used.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETOBJSEC() returns .T. if the new security value (<nSafe>) has been
      set successfully.

   $DESCRIPTION$
      Important!  NNETOBJSEC() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET OBJECT SECURITY
      NNETOBJSEC() allows you to modify the security of existing bindery
      objects.  For efficiency reasons numeric values for <nObjType> must be
      passed in the high-low format.  This function requires supervisor
      rights.

   $EXAMPLES$
      Set the security of the user object MICK to 51 (hex 33):

      IF NNETOBJSEC('MICK',OBJ_USER,51)
         ? 'Security modified successfully!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTOBJ(), NNETPRPSEC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETOBJTYP()
   $ONELINER$
      Determines the object type of an object ID
   $SYNTAX$
      NNETOBJTYP(<NId>, [<cServer>|<nConId>]) --> nObjType

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <NId>  Designates a bindery object ID.  For efficiency reasons, the
      ID must be passed in the high-low format (see the Introduction to this
      chapter).

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NETOBJTYP() returns the type of the bindery object, specified by <NId>
      in the high-low format.  If an error occurs, the function returns 0.

   $DESCRIPTION$
      NOVELL NET OBJECT TYPE
      Within a file server, each bindery object is given a unique object ID
      with a length of four bytes.  With NNETOBJTYP(), you can determine the
      type of the related bindery object.  NNETOBJTYP() can be used in
      conjunction with functions that return an object ID in the high-low
      format (for example, NNETRDSET()).

   $EXAMPLES$
      Read the property SECURITY_EQUALS of user MIKE, and return the object
      names and types of the members (the SECURITY_EQUALS property contains a
      list of objects to which an object is security-equivalent):

      #include "ctnnet.ch"

      aIn=NNETRDSET('MIKE',OBJ_USER,'SECURITY_EQUALS')
      FOR i=1 TO Len(aIn)
      ?  NNETOBJNAM(aIn[i])
      ?? IF(NNETOBJTYP(aIn[i])=OBJ_USER,'User','Group')
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETOBJNAM(), NNETRDSET()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPRPSEC()
   $ONELINER$
      Sets the property security
   $SYNTAX$
      NNETPRPSEC(<cObjName>,<nObjType>,<cProp>,<nSafe>,
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the object.

      <nObjType>  Designates a numeric value that specifies the object type.
      The header file CTNNET.CH contains symbolic constants for the object
      types defined by Novell for use in conjunction with the bindery
      functions of CA-Clipper Tools.

      <cProp>  Designates the property for which the security is modified.

      <nSafe>  Designates the new value for the property security.  This
      value specifies the rights required to find (read) or to modify (write)
      the property.  The settings are defined with a bit-coded mask.  The low-
      ordered bits control the read access to the bindery object; the high-
      ordered bits control the write access to the bindery object.

      Table 18.5:  Values for Property Security
      <table>
          Value  Hex  Bin     Definition

          0      0    0000    Access allowed to all users
          1      1    0001    Access allowed to users who have logged in to the
                              file server
          2      2    0010    Access allowed to users who have logged in to the
                              file server with password
          3      3    0011    Access allowed to users who have logged in to the
                              file server as the supervisor or as a user who has
                              supervisor equivalence
          4      4    0100    Access only allowed to the network operating system
         </table>

      <cServer> Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPRPSEC() returns .T. if the new security value (<nSafe>) has been
      set successfully.

   $DESCRIPTION$
      Important!  NNETPRPSEC() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET PROPERTY SECURITY
      NNETPRPSEC() allows you to modify the security of existing properties.
      For efficiency reasons numeric values for <nObjType> must be passed in
      the high-low format.  This function requires supervisor rights.

   $EXAMPLES$
      Set the security of the property IDENTIFICATION of the user object MICK
      to 51 (hex 33):

      IF NNETOBJPRP('MICK',OBJ_USER,'IDENTIFICATION',51)
         ? 'Security modified successfully!'
      ELSE
         ? 'Error!'
      ENDIF

   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTPRP(), NNETOBJSEC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETRDITM()
   $ONELINER$
      Reads an item property segment
   $SYNTAX$
      NNETRDITM(<cObjName>,<nType>,<cProperty>,[<nSeg>],
         [<lMode>],[<cServer>|<nConId>]) --> cPropValue

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the bindery object that is
      processed.

      <nType>  Designates the object type of <cObjName>.  The header file
      CTNNET.CH contains symbolic constants for a number of object types.
      When you work with numeric values, take into account that, for
      efficiency reasons, NNETRDITM() expects the object type in the high-low
      format.

      <cPropName>  Designates the name of the property that is processed.
      <cPropName> must describe an item property.

      <nSeg>  Designates the number of the segment that is read.  The
      smallest possible number, as well as the default value, is 1.

      <lMode>  Designates whether the contents of the property are
      interpreted as text (<lMode> = .F.) or as binary byte sequence (<lMode>
      = .T.).  The default value is .F..  If text, NNETRDITM() returns the
      characters up to the first occurrence of a terminator 0.  In binary
      mode, all 128 bytes of the required property segment are returned.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETRDITM() returns the contents of the specified property segment in
      the form of a character string.  In text mode, the returned string
      contains all characters up to the first occurrence of a terminator 0.
      In binary mode, the string always contains 128 characters.  If an error
      occurs, the function returns an empty string.

   $DESCRIPTION$
      NOVELL NET READ ITEM PROPERTY
      Internally, Novell Netware defines two property types:  item and set
      property.  With NNETRDITM(), you can read the contents of an item
      property.  Item properties can contain any type of data.  The
      information within an item property is organized in segments that have a
      constant length of 128 bytes.  NNETRDITM() allows you to read single
      segments (<nSeg>) of a property (<cPropName>) of a bindery object,
      specified by <cObjName> and <nType>.  The organization of the
      information within a segment depends on the property.  With <lMode> you
      can specify if segment contains text or a binary sequence (see the
      arguments).  An example for text mode is the property IDENTIFICATION.
      The IDENTIFICATION property contains a bindery object's full name as a
      zero-terminated ASCII character string.  An example for the binary mode
      is the property LOGIN_CONTROL.  The property LOGIN_CONTROL contains
      binary-coded information about a user's access limits.  To avoid
      incorrect results when working with binary-coded information, the
      parameter <lMode> must be designated .T..

      To read all property segments, call NNETRDITM() with an incrementing
      value for <nSeg> until NNETRDITM() returns an empty string and
      NNETERROR() returns 236.

      With the parameters <cServer> or <nConId>, the bindery of any attached
      file server can be accessed.  The connection ID of a file server is
      returned by NNETATTACH() or NNETLOGIN().

      The function NNETRDITM() requires sufficient bindery and property access
      rights.  The necessary property access rights depend on the property
      security of the property that is read.

   $EXAMPLES$
      ■  Determine the full name of user MIKE:

         #include "ctnnet.ch"

         ? NNETRDITM('MIKE',OBJ_USER,'IDENTIFICATION')

      ■  Determine the date of the last login of user MIKE:

         #include "ctnnet.ch"

         cBuf=NNETRDITM('MIKE',OBJ_USER,'LOGIN_CONTROL',1,.T.)
         IF !Empty(cBuf)
          dLast=       SToD('19'+NToC(Asc(SubStr(cBuf,57,1)),,2,'0');
             +NToC(Asc(SubStr(cBuf,58,1)),,2,'0');
             +NToC(Asc(SubStr(cBuf,59,1)),,2,'0'))
          ? dLast
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETRDSET(), NNETWRTITM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETRDSET()
   $ONELINER$
      Reads a set property
   $SYNTAX$
      NNETRDSET(<cObjName>,<nType>,<cPropName>,
         [<cServer|<nConId>]) --> aObjList

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName> Designates the name of the bindery objects that are
      processed.

      <nType>  Designates the object type of <cObjName>.  The header file
      CTNNET.CH contains symbolic constants for a number of object types.
      When working with numeric values, take into account that, for efficiency
      reasons, the function NNETRDSET() expects the object type in the high-
      low format.

      <cPropName>  Designates the name of the property that is processed.
      <cPropName> must describe a set property.

      <cServer> Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETRDSET() returns a one-dimensional array that contains the object
      ID's of the bindery objects in <cPropName> as numeric values.

   $DESCRIPTION$
      NOVELL NET READ SET PROPERTY
      Internally, Novell Netware defines two property types:  item and set
      property.  With NNETRDSET(), the contents of a set property can be read.
      Set properties contain a list of object ID's.  An object ID has a length
      of four bytes and identifies a bindery object.  An example is the
      property GROUP_MEMBERS, which contains a list of users that are members
      of a group.

      NNNETRDSET() returns an array with the object ID's of the members of the
      set property <cPropName>.  With the functions NNETOBJNAM() and
      NNETOBJTYP(), object name and object type for the object ID can be
      determined.

      The function NNETRDSET() requires sufficient bindery and property access
      rights.  The necessary property access rights depend on the property
      security of the property that is read.

   $NOTES$
      ■  For efficiency reasons, NNETRDSET() returns the object IDs in
         the high-low format (see the Introduction to this chapter).

   $EXAMPLES$
      The SECURITY_EQUALS property contains a list of objects to which an
      object is security-equivalent.  This property is usually attached to
      user and user group objects.  Read the property SECURITY_EQUALS of user
      MIKE, and display the object names and object types of the members:

      #include "ctnnet.ch"

      aIn=NNETRDSET('MIKE',OBJ_USER,'SECURITY_EQUALS')
      FOR i=1 TO Len(aIn)
      ?  NNETOBJNAM(aIn[i])
      ?? IF(NNETOBJTYP(aIn[i])=OBJ_USER,'User','Group')
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDSET(), NNETDELSET(), NNETOBJNAM(), NNETOBJTYP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETRENOBJ()
   $ONELINER$
      Renames a bindery object
   $SYNTAX$
      NNETRENOBJ(<cOldName>,[<nType>],<cNewName>,
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cOldName>  Designates the name of the bindery object that is
      renamed.

      <nType>  Designates a numeric value that specifies the type of
      <cOldName>.  The header file CTNNET.CH contains symbolic constants of
      the object type defined by Novell for use in conjunction with the
      bindery functions of CA-Clipper Tools.  The default value indicates the
      object type OBJ_USER.

      <cNewName>  Designates the new name for the bindery object.

      <cServer>  Designates the name of the file server of which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETRENOBJ() returns .T. if the bindery object has been renamed
      successfully.  If an error occurs, the error code can be queried with
      NNETERROR().

   $DESCRIPTION$
      Important!  NNETRENOBJ() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET RENAME BINDERY OBJECT
      NNETRENOBJ() allows you to rename bindery objects.  For example, this
      function can be used to change the login name of a user.  With the
      parameters <cServer> or <nConId>, the bindery object of any attached
      server can be accessed.  The connection ID of a server is returned by
      NNETATTACH() or NNETLOGIN().

      To rename an object, the requesting user must have supervisor rights on
      the related file server.  NNETRENOBJ() expects the object type in the
      high-low sequence for efficiency reasons.

   $NOTES$
      ■  NNETRENOBJ() must be used to rename users or user groups, as
         no other high level function is available in CA-Clipper Tools.

   $EXAMPLES$
      ■  Rename user JIM to JAMES and evaluate the return values:

         IF NNETRENOBJ('JIM',,'JAMES')
         ? 'User has been renamed successfully!'
         ELSE
         ? 'Failure during rename!'
         ENDIF

      ■  Rename the group DEV to TECH:

         #include "ctnnet.ch"

         NNETRENOBJ('DEV',OBJ_GROUP,'TECH')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTOBJ(), NNETDELOBJ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSCNBIN()
   $ONELINER$
      Scans a bindery for an object
   $SYNTAX$
      NNETSCNBIN(<cObjMask>,[@]<nType>,[@]<NId>,
         [@<nObjFlag>],[@<nObjSafe>],[@<lObjProp>],
         [<cServer>|<nConId>]) --> cObjName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjMask>  Designates a search mask that is satisfied by the
      bindery objects that are searched.  <cObjMask> can contain the wildcard
      characters "*" and "?" according to DOS regulations.  The default value
      is "*".

      <nType>  Designates the object type that is searched.  The header
      file CTNNET.CH contains symbolic constants for a number of object types.
      When you work with numeric values, NNETSCNBIN() expects the object type
      in the high-low format for efficiency reasons.  If <nType> is passed by
      reference, the variable contains the type of the object found after the
      function has been completed successfully.

      <NId>  Contains the object ID (high-low format) of the last object
      found.  To start the search with the first object, <NId> must be
      designated -1.  If <NId> is passed by reference, the variable contains
      the ID of the object found after the function has been completed
      successfully.

      <nObjFlag>  Designates whether the object found is static (0) or
      dynamic (1).  This parameter must be passed by reference.  In this case,
      the variable contains the object flag after the function has been
      completed successfully

      <nObjSafe>  Designates the object security as an eight-bit number.
      The four high-order bits control the security level for the object's
      write access; the four low-order bits control the object's read access.
      This parameter must be passed by reference.  In this case, the variable
      contains the object security after the function has been completed
      successfully.  A table for access levels can be found with the
      NNETCRTOBJ() function.

      <lObjProp>  Designates whether the object has property (.T.) or not
      (.F.).  This parameter must be passed by reference.

      <cServer>   Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETSCNBIN() returns the name of the binary object that is found.  If no
      object has been found, the function returns a null string.  If the
      parameters <nType>, <NId>, <nObjFlag>, <nObjSafe>, and/or <lObjProp> are
      passed by reference, NNETSCNBIN() returns the object type, the object
      ID, the object flag, the object security, and a flag for property
      existence (see the arguments).

   $DESCRIPTION$
      Important!  NNETSCNBIN() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET SCAN BINDERY
      NNETSCNBIN() allows you to scan the bindery of a file server for objects
      that satisfy a specified search mask (<cObjMask>) and a defined type
      (<nType>).  To find the first object that matches the passed criterion,
      the parameter <NId> must be designated -1.  For a successive search, the
      object ID must be passed by reference to use the ID of the object that
      is found at the next function call.  To find objects of any type, the
      parameter <nType> must contain -1 or the symbolic constant OBJ_WILD.
      With the parameters <cServer> or <nConId>, the bindery of any attached
      file server can be accessed.  The connection ID of a server is returned
      by NNETATTACH() or NNETLOGIN().

   $NOTES$
      ■  The object type and the object ID are expected in the high-low
         format (see the Introduction to this chapter).

   $EXAMPLES$
      List the names and types of all bindery objects on the default server:

      #include "ctnnet.ch"

      nId:=-1          // Start with the 1st object
      WHILE .T.
      nType=OBJ_WILD   // all objects
      IF Empty(cName:=NNETSCNBIN('*',@type,@ID))
      EXIT
      ENDIF
      ? cName,nType
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTOBJ(), NNETSCNPRP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSCNPRP()
   $ONELINER$
      Scans a bindery object for a property
   $SYNTAX$
      NNETSCNPRP(<cObjName>,<nType>,<cPropMask>,[@]<nSeq>,
         [@<nFlag>],[@<nSafe>],[@<lValue>],
         [<cServer>|   <nConId>]) --> cPropName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the bindery object that is
      processed.

      <nType>  Designates the object type of <cObjName>.  The header file
      CTNNET.CH contains the symbolic constants for a number of object types.
      When you work with numeric values, NNETSCNPRP() expects the object type
      in the high-low format for efficiency reasons.

      <cPropMask>  Designates a search mask that is satisfied by the
      properties that are searched.  <cPropMask> can contain the wildcard
      characters "*" and "?".

      <nSeq>  Designates the sequence number (high-low format) of the last
      property that was found.  To start the search with the first property,
      <nSeq> must be designated -1.  If <nSeq> is passed by reference, the
      variable contains the sequence number of the property found after the
      function has been completed successfully.

      <nFlag>  Designates the property flag after the function has been
      completed successfully.  This parameter must be passed by reference.
      The following table contains the possible values for <nFlag>:

      Table 18.6:  Possible property flags
      <table>
          Value   Sym. Con.    Definition

          0       PRP_ITEM     Static item property
          1                    Dynamic item property
          2       PRP_SET      Static set property
          3                    Dynamic set property
         </table>

      <nSafe>  Designates the property security after the function has
      been completed successfully.  This parameter must be passed by
      reference.  The property security is an eight-bit number.  The four high-
      order bits control the security level for the property's write access;
      the four low-order bits control the property's read access.  A table for
      access levels can be found with the NNETCRTOBJ() function.

      <lValue>  Designates a logical value that indicates if the property
      has any values (.T.) or not (.F.).  This parameter must be passed by
      reference.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETSCNPRP() returns the name of the property that is found.  If no
      property is found, the function returns an empty string.  If the
      parameters <nSeq>, <nFlag>, and/or <nSafe> are passed by reference,
      NNETSCNPRP() returns the sequence number, the property flag, property
      security, and a flag for value existence (see the arguments).

   $DESCRIPTION$
      Important!  NNETSCNPRP() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET SCAN PROPERTY
      NNETSCNPRP() allows you to scan a bindery object (<cObjName> and
      <nType>) for properties that satisfy a specified search mask
      (<cPropMask>).  To find the first property that matches the passed
      criterion, the parameter <nSeq> must be designated -1.  For a successive
      search, the sequence number must be passed by reference in order to use
      the sequence number of the found property at the next function call.
      With the parameters <cServer> or <nConId>, the bindery of any attached
      file server can be accessed.  The connection ID of a server is returned
      by NNETATTACH() or NNETLOGIN().

   $NOTES$
      ■  The object type and sequence number are expected and/or
         returned in the high-low format (see the Introduction to this
         chapter).

   $EXAMPLES$
      List all the properties of the bindery object SUPERVISOR:

      #include "ctnnet.ch"

      nSeq:=-1   // Start with 1st property
      WHILE .T.
      cName=NNETSCNPRP('SUPERVISOR',OBJ_USER,'*', @nSeq, ;
      @nFlag,@nSafe,@lValue)
      IF Empty(cName)
      EXIT
      ENDIF
      ? cName,nSeq,nFlag,nSafe,lValue
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTPRP(), NNETSCNBIN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETWRTITM()
   $ONELINER$
      Writes a segment of an item property
   $SYNTAX$
      NNETWRTITM(<cObjName>,[<nObjType>],<cProperty>,
         <cPropValue>,[<nSegment>],[<lDelete>],
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cObjName>  Designates the name of the bindery object that is
      processed.

      <nObjType>  Designates a numeric value that indicates the object
      type.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates object value OBJ_USER.

      <cProperty>  Designates the name of an item property of the object
      <cObjName>.

      <cPropValue>  Designates the value that is stored.  The value must
      be passed as a character string of up to 128 characters.

      <nSegment>  Designates the segment of <cProperty> in which
      <cPropValue> is written.  The default value is the first segment.

      <lDelete>  Designates whether the segments following <nSegment> are
      deleted (.T.) or saved (.F.).  The default value (.F.) saves the
      segments that follow <nSegment>.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETWRTITM() returns .T. if the operation was completed successfully.
      If an error occurs, the Novell error code can be queried with the
      NNETERROR() function.

   $DESCRIPTION$
      Important!  NNETWRITITM() is a low level bindery function and should
      be used only with extensive knowledge of the bindery concept and the
      Novell API.

      NOVELL NET WRITE PROPERTY ITEM
      Internally, Novell Netware defines two different property types: item
      and set properties.  Item properties consist of segments that can accept
      up to 128 characters.  The number of segments within an item property
      can vary.

      A typical example of an item property is the IDENTIFICATION property
      that contains a user or user group's full name (unlike the login name).
      NNETWRTITM() allows you to write information to a segment of an item
      property.

      The parameters <cName> and  <cType> specify the object that is
      processed.  <cProperty> is the name of the property.  The property must
      have been created before (for example, with NNETCRTPRP()).  <cPropValue>
      is the character string that is written to <nSegment> of <cProperty>.
      With the parameter <lDelete>, you can determine whether segments that
      follow <nSegment> are deleted (.T.) or not (.F.).

      With the parameters <cServer> or <nConId>, the bindery of any attached
      server can be accessed.  The connection ID of a server is returned by
      NNETATTACH() or NNETLOGIN().

      To achieve results with NNETWRTITM(), sufficient bindery and property
      access rights are required.  The necessary property access rights depend
      on the property security of the property that is modified.  For
      efficiency reasons, user defined object types must be passed in the high-
      low format.

   $EXAMPLES$
      Set the full name for user MICK:

      IF NNETWRTITM('MICK',,'IDENTIFICATION','Michael Smith')
      ? 'Full name set successfully!'
      ELSE
      ? 'Full name could not be set!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDSET(), NNETCRTPRP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      User and Group Management
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      The functions of the User and Group Management chapter are based
      exclusively upon low level bindery accesses and could be accomplished
      completely with the low level bindery functions.  However, working with
      low level bindery functions can be dangerous (see the Introduction to
      the Low Level Bindery Access chapter).  Therefore, CA-Clipper Tools
      provide a number of high level functions for the most common
      requirements of user and group management.  The functions in this
      chapter allow you to add or remove users, or groups of users, to or from
      groups.  Various lists can be created: established users or groups,
      currently logged in users, members of a group, or groups of which a user
      is a member.  You can determine if a user is a member of a specified
      group.  For example, this allows you to combine the availibility of menu
      options with Netware settings.

      A number of functions in this chapter have been developed in CA-Clipper
      with the use of low level bindery functions.  The source code for these
      functions can be found on the product disks and can be used as an
      example for the use of the low level bindery functions.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETACCDIS()
   $ONELINER$
      Sets or queries an access account lock
   $SYNTAX$
      NNETACCDIS(<cUser>,[<lLock>],[<cServer>|<nConId>),
         --> lLocked

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user for whom an access account
      lock is set or checked.

      <lLock>  Allows locking (.T.) or releasing (.F.) of the access
      account of <cUser>.

      <cServer>  Designates the name of the file server where <cUser> is
      established.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETACCDIS() returns .T. when the access account of <cUser> is currently
      disabled.  <cUser> is not able to log in.  If the parameter <lLock> has
      been passed and the return value does not match <lLock>, the user of the
      NNETACCDIS() function did not have the rights requested for the
      modification (see the description).

   $DESCRIPTION$
      NOVELL NET ACCOUNT DISABLED
      With NNETACCDIS(), the access account lock for <cUser> can be set or
      queried.  To determine the status of the account, do not pass a value
      for the parameter <lLock>.  To set the status of the account, pass .T.
      or .F. for <lLock>.  However, to lock or release an access account lock,
      supervisor rights on the related file server are necessary.  With
      <cServer> or <nConId>, the status of any user on any attached server can
      be queried.  NNETATTACH() and NNETLOGIN() return the server connection
      ID.

   $EXAMPLES$
      ■  Determine the access account status for user MIKE:

         ? NNETACCDIS('MIKE')   // for example .T.

      ■  Disable the account for user MIKE:

         NNETACCDIS('MIKE',.T.)

      ■  Release the account lock for user MIKE:

         NNETACCDIS('MIKE',.F.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETAEXPD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETADDGRP()
   $ONELINER$
      Adds one or more users to a group
   $SYNTAX$
      NNETADDGRP(<cGroup>,<cUser>|<aUser>,
         [,<cServer>|<nConId>) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cGroup>  Designates the name of the group to which <cUser>|<aUser>
      is added.

      <cUser>  Designates the name of the user that is added to <cGroup>.

      <aUser>  Designates a number of elements of the type string.  Each
      element is the name of a user that is added to <cGroup>.

      <cServer>  Designates the name of the file server.  Your workstation
      must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETADDGRP() returns the number of users successfully added to <cGroup>.
      If no user could be added, the function returns 0.

   $DESCRIPTION$
      NOVELL NET ADD USER TO GROUP
      With NNETADDGRP(), one or more users can be added to an existing group.
      To add one user, the login name of the user must be passed as the single
      argument, <cUser>.  More users can be added by passing the array,
      <aUser>, that contains the user names as elements.  As a member of a
      group, users automatically inherit the group privileges.  By passing
      <cServer> or <nConId>, the operation can be executed on any connected
      file server.  The connection ID of a file server can be determined with
      the functions NNETATTACH() or NNETLOGIN().

      Supervisior rights are necessary to add a user to a group.

   $NOTES$
      ■  NNETADDGRP() is a high level function based on the low level
         functions for bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Add user MIKE to the TECH group:

         IF NNETADDGRP('TECH','MIKE')>0
         ? 'User added successfully!'
         ELSE
         ? 'No user added!'
         ENDIF

      ■  Add users PAUL, JIM, and STEPHEN to the group TOOLS:

         NNETADDGRP('TOOLS',{'PAUL','JIM','STEPHEN'})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTGRP(), NNETREMGRP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETAEXPD()
   $ONELINER$
      Determines or sets the expiration date of an access account
   $SYNTAX$
      NNETAEXPD(<cUser>,[<dDate>],[<cServer>|<nConId>)
         --> dExpiration

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user.

      <dDate>  Designates the new expiration date for the access account
      of <cUser>.

      <cServer>  Designates the name of the file server where <cUser> is
      established.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETAEXPD() returns the valid expiration date for the access account of
      <cUser>. If <dDate> has been passed and the returned date does not match
      <dDate>, the user of the NNETAEXPD() did not have the requested rights
      for the modification (see the description).

   $DESCRIPTION$
      NOVELL NET ACCOUNT EXPIRATION DATE
      NNETAEXPD() allows you to query and set the expiration date for the
      access account of <cUser>.  Any attempt by <cUser> to log in after the
      account expires disables the account.  To query the expiration date, do
      not pass a date for <dDate>.  If a value is passed for <dDate>,
      NNETAEXPD() tries to modify the expiration date.  However, supervisor
      rights on <cServer> are required to set a new expiration date.  An
      expiration date can be removed by passing an empty date.  With the
      parameters <cServer> or <nConId>, the expiration date of users on any
      file server can be queried or set.  The connection ID of a file server
      can be determined with the functions NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      ■  Determine the expiration date for user MIKE:

         ? NNETAEXPD('MIKE')   // z.B. 03/19/92

      ■  Set the new expiration date for the account of user MIKE:

         NNETAEXPD('MIKE',CToD('06/01/92'))

      ■  Remove the expiration date for the account of user MIKE:

         NNETAEXPD("MIKE",CToD(""))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETACCDIS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCOPRIV()
   $ONELINER$
      Tests for console privileges under Novell
   $SYNTAX$
      NNETCOPRIV() --> lEntitlement

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETCOPRIV() returns .T. when the station or the logged-in user has
      privileges for the use of the file server console.

   $DESCRIPTION$
      NOVELL NET CONSOLE PRIVILEGES
      This function allows you to determine if the user that is logged-in on
      the station being used has rights for the use of the file server
      console.  These rights are a prerequisite for particular network
      operations and also for certain CA-Clipper Tools functions.  One example
      of a network function that requires specific rights is NNETPURGE()

   $NOTES$
      ■  Console privileges are already contained within supervisor
         rights.

   $EXAMPLES$
      Test to see if you have rights to the file server console:

      ? NNETCOPRIV()         // .T. if console privileges exist
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETSPRVSR(), NNETPURGE(), NNETUSRFRE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCPASS()
   $ONELINER$
      Modifies or sets the password for a bindery object
   $SYNTAX$
      NNETCPASS(<cName>,[<nType>],<cOldPass>,<cNewPass>,
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the bindery object that is
      processed.

      <nType>  Designates a numeric value that indicates the type of
      <cName>.  The header file CTNNET.CH contains symbolic constants for the
      object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value indicates OBJ_USER.

      <cOldPass>  Designates the old password for <cName>.

      <cNewPass>  Designates the new password that is set for <cName>.

      <cServer>  Designates the name of the file server that contains the
      bindery that is accessed.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETCPASS() returns .T. if the new password has been set successfully.
      If an error occurs, the Novell error code can be queried with the
      NNETERROR() function.

   $DESCRIPTION$
      NOVELL NET CHANGE BINDERY OBJECT PASSWORD
      With NNETCPASS(), the password of a bindery object can be modified.
      Usually the function is used to change the password of a user.  The
      parameters <cName> and <nType> specify the object that is processed.  If
      the user does not have supervisor rights, the old password must be
      passed to prove the rights to set a new password.  If no password exists
      for <cName>, an empty string ("") must be passed for <cOldPass>.
      <cNewPass> is the new password that is set.  A user with supervisor
      rights can pass the parameter <cOldPass> as an empty string.

      With the parameters <cServer> or <nConId>, the bindery of any attached
      file server can be accessed.  The connection ID of a file server can be
      determined with NNETATTACH() or NNETLOGIN().

      Supervisor rights for the bindery are required to modify passwords.  For
      efficiency reasons, user defined object types must be passed in the high-
      low format.

   $NOTES$
      ■  The password of a bindery object does not affect the access
         possibilities to the object.  The password is only required when the
         object logs into the file server.

      ■  When a password is first set, the object is required to have
         "password" property.  If necessary, the "password" property must be
         created with NNETCRTPRP().

   $EXAMPLES$
      Change the password for user PAUL from LINDA to SILVIA:

      IF NNETCPASS('PAUL',,'LINDA','SILVIA')
      ? 'Password changed!'
      ELSE
      ? 'Password not changed!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETVPASS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCRTGRP()
   $ONELINER$
      Creates a new group
   $SYNTAX$
      NNETCRTGRP(<cName>,[<cFullName>],[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the new group.

      <cFullName>  Designates the full name of <cName>.

      <cServer>  Designates the name of the file server where the new
      group is created.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETCRTGRP() returns .T. if the group has been created successfully.

   $DESCRIPTION$
      NOVELL NET CREATE GROUP
      NNETCRTGRP() allows you to create a new user group.  With the parameter
      <cFullName>, a full name can be assigned to the group.  With the
      parameters <cServer> or <nConId> ,a new group can be created on any
      attached file server.  The connection ID of the server can be determined
      with NNETATTACH() or NNETLOGIN().

      The group's access rights can be set with the function NNETTRUST().

      Supervisior rights are required to establish a new group.

   $NOTES$
      ■  NNETCRTGRP() is a high level-function based on the low level
         functions for bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      Create the group DEV with full name DEVELOPMENT:

      IF NNETCRTGRP('DEV','DEVELOPMENT')
      ? 'Group created successfully!'
      ELSE
      ? 'Group could not be created!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDGRP(), NNETDELOBJ(), NNETTRUST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCRTUSR()
   $ONELINER$
      Creates a new user
   $SYNTAX$
      NNETCRTUSR(<cName>,[<cPass>],[<cFullName>],[<lSuper>],
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the login name of the new user.

      <cPass>  Designates the password for <cName>.

      <cFullName>  Designates the full name for <cName>.

      <lSuper>  Designates whether the new user is granted supervisor
      rights (.T.) or not (.F.).  The default value (.F.) indicates that the
      new user is not granted supervisor rights.

      <cServer>  Designates the name of the file server where the new user
      is created.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETCRTUSR() returns .T. if the user has been added successfully.

   $DESCRIPTION$
      NOVELL NET CREATE USER
      NNETCRTUSR() allows you to create a new user and to define the basic
      characteristics for the user.  If NNETCRTUSR() is called only with the
      parameter <cName>, a user of the type guest is created.  The guest user
      can log into the file server without a password.  If <cPass> is passed,
      the password is required to log into the file server.  The password can
      also be defined later with the NNETCPASS() function.  With the argument
      <cFullName>, the full name of the new user can be set.  Supervisor
      rights can be granted to the new user by passing the <lSuper> with
      (.T.).  The default value for <lSuper> (.F.) does not grant supervisor
      rights.  Additional rights can be assigned to the user by adding the
      user to a group (NNETADDGRP()) or by explicitly setting trustee rights.
      With the parameters <cServer> or <nConId>, a new user can be added on
      any attached file server.  The connection ID of a server can be
      determined with NNETATTACH() or NNETLOGIN().

      Supervisor rights are required to create a new user.

   $NOTES$
      ■  NNETCRTUSR() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Create user PAUL with password 190366 and the full name PAUL
         SMITH  Give the new user supervisor rights:

         IF NNETCRTUSR('PAUL','190366','Paul Smith',.T.)
         ? 'User created successfully!'
         ELSE
         ? 'User could not be created!'
         ENDIF

      ■  Create a new user, and then set the password to HELLO:

         IF NNETCRTUSR('TEST')
         NNETCPASS('TEST',,'','HELLO')
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDGRP(), NNETCPASS(), NNETDELOBJ(), NNETTRUST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETGROUPS()
   $ONELINER$
      Queries the user groups on a file server
   $SYNTAX$
      NNETGROUPS([<cServer>|<nConId>],[<cMask>])
         --> aGroupList

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server for which the user
      groups are determined.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.  If no file server is specified, the function uses the
      default server.

      <cMask>  Designates a search mask that can contain the wildcard
      characters "?" and "*".  The default value ("*") designates that all
      user groups are determined.

   $RETURNS$
      NNETGROUPS() returns a one-dimensional array.  Each array element
      contains the name of a user group.

   $DESCRIPTION$
      NOVELL NET GROUPS
      NNETGROUPS() allows you to determine all the user groups established on
      a file server.  The file server can be specified either by its name or
      its connection ID.  The connection ID of a server is returned by
      NNETATTACH() or NNETLOGIN().

      To achieve results with this function, the requesting user must be
      logged in on the related file server.  If the requesting user is not
      logged in on the related file server, the function returns an empty
      array.

   $EXAMPLES$
      Display all user groups on the file server NANGERTOOLS2:

      AEval(NNETGROUPS('NANGERTOOLS2'),{|x|QOut(x)})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETLGUSER(), NNETUSERS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETGRPMEM()
   $ONELINER$
      Checks to see if a user is a member of a group
   $SYNTAX$
      NNETGRPMEM(<cUser>,<cGroup>,[<cServer>|<nConId>])
         --> lMember

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user.

      <cGroup>  Designates the name of the group that is searched for
      <cUser>.

      <cServer>  Designates the name of the file server on which the user
      and group definition is searched.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.  If no server has been specified, the function uses the
      default server.

   $RETURNS$
      NNETGRPMEM() returns .T. if the user <cUser> is a member of the group
      <cGroup>.  If <cUser> is not a member of <cGroup>, the function returns
      .F..

   $DESCRIPTION$
      NOVELL NET GROUP MEMBER
      To improve organization and simplify user access to file server
      resources, user groups can be created under Novell Netware.  Each user
      can be a member of one or more groups.  With the function NNETGRPMEM(),
      you can determine if a user is a member of a specific group.  For
      example, the branch in an application can be made dependent on the
      membership of the logged in user to a specific group.

      The file server can be specified either by its name or its connection
      ID.  The connection ID of a server is returned by NNETATTACH() or
      NNETLOGIN().

      This function requires that the requesting user be logged in on the
      related file server.

   $EXAMPLES$
      Log the user into another file server if the user is a member of the
      group DEV:

      IF NNETGRPMEM(cUser,"DEV")
      NNETLOGIN(cUser,cPassword,"NANGERDEV")
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETGROUPS(), NNETINGRPS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETINGRPS()
   $ONELINER$
      Determines the groups to which a user belongs
   $SYNTAX$
      NNETINGRPS(<cUser>[,<cServer>|<nConId>]) --> aGroupList

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user whose group membership is
      determined.

      <cServer>  Designates the name of the file server on which <cUser>
      is established.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.  If no file server is specified, the function uses the
      default file server.

   $RETURNS$
      NNETINGRPS() returns a one-dimensional array.  Each array element
      contains the name of a user group.

   $DESCRIPTION$
      NOVELL NET IN GROUPS
      To improve organization and simplify user access to file server
      resources, you can create user groups under the Novell Netware.  Each
      user can be a member of one or more groups.  With the function
      NNETINGRPS(), you can determine all the user groups to which a user
      belongs.

      The file server can be specified either by its name or its connection
      ID.  The connection ID of a server is returned by  NNETATTACH() or
      NNETLOGIN().

      To achieve results with this function, the requesting user must be
      logged in on the related file server.  If the requesting user is not
      logged in on the related file server, the function returns an empty
      array.

   $EXAMPLES$
      Display all the user groups to which user KEITH on file server STONES
      belongs:

      aList:=NNETINGRPS('KEITH','STONES')
      FOR i = 1 TO Len(aList)
      ? aList[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETGROUPS(), NNETGRPMEM(), NNETUSINGR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETLGUSER()
   $ONELINER$
      Determines the users that are currently logged in on a file server
   $SYNTAX$
      NNETLGUSER([<cServer>|<nConId>]) --> aUserListe

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server for which the
      logged in users are determined.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.  If no file server is specified, the function uses the
      default server.

   $RETURNS$
      NNETLGUSER() returns a one-dimensional array.  Each array element
      contains a user name.

   $DESCRIPTION$
      NOVELL NET LOGGED USER
      NNETLGUSER() allows you to determine all the users currently logged in
      on the specified file server.  The file server can be specified by its
      name or its connection ID.  The connection ID of a server is returned by
      NNETATTACH() or NNETLOGIN().

      The function NNETLGUSER() requires that the requesting user be logged in
      on the related file server.  If the requesting user is not logged in on
      the related file server, the function returns an empty array.

      All users on a file server can be determined with the function
      NNETUSERS().

   $EXAMPLES$
      Display a list of the users currently logged in on file server
      NANGERTOOLS2:

      aList:=NNETLGUSER('NANGERTOOLS2')
      FOR i = 1 TO Len(aList)
      ? aList[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETUSERS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMAXCON()
   $ONELINER$
      Sets or determines the maximum number of connections
   $SYNTAX$
      NNETMAXCON(<cUser>,[<nNumber>],[<cServer>|<nConId>)
         --> nMaxConn

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user for whom the maximum number
      of connections is set or determined.

      <nNumber>  Designates the new maximum number of connections for
      <cUser>.

      <cServer>  Designates the name of the file server where <cUser> is
      established.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETMAXCON() returns the maximum number of connections for <cUser>. If
      the function was called with a value for <nNumber> and the return value
      does not match <nNumber>, the requesting user did not have the rights to
      modify the number of connections.

   $DESCRIPTION$
      NOVELL NET MAXIMUM CONNECTIONS
      NNETMAXCON() allows you to query or set the maximum number of
      connections for <cUser> (the number of workstations where a user can be
      logged in).  To determine the maximum number of connections, do not pass
      a value for <nNumber>.  If <nNumber> contains a numeric value,
      NNETMAXCON() tries to set the maximum number of connections to
      <nNumber>.  Supervisor rights are required on the related file server to
      modify the number of connections.  With <nNumber> equal to 0, an
      existing limit for the number of connections can be removed.

      With <cServer> or <nConId>, the number of connections for users on any
      attached file servers can be modified.  The connection ID of a server is
      returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      ■  Determine the maximum number of connections for user MIKE:

         ? NNETMAXCON('MIKE')   // For example 2

      ■  Set the new number of connections for user MIKE:

         NNETMAXCON('MIKE',5)

      ■  Remove the limit for user MIKE:

         NNETMAXCON("MIKE",0)

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETOCNUMS()
   $ONELINER$
      Determines all of the stations where a user is logged in
   $SYNTAX$
      NNETOCNUMS([<cUser>]) --> cStationList

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of an object of the type user. The default
      value specifies the logged in user.

   $RETURNS$
      NNETOCNUMS() returns a character string where each byte represents a
      station number.

   $DESCRIPTION$
      NOVELL NET OPEN CONNECTION NUMBERS
      With the help of this function you can determine on how many stations,
      and on which stations, an object of the type user is logged into the
      network.  This always relates to the default file server.

      The station numbers are returned as a character string; each byte
      represents a station number.  This character string works very well with
      CA-Clipper Tools string functions, such as CharSort(), CharRem(), etc..

      If no user name is specified, the function returns the numbers for all
      stations that are logged in under the same name as the station being
      used.  This corresponds to a call of NNETOCNUMS(NNETWHOAMI()).

   $NOTES$
      ■  Console privileges are required to determine the station
         number of another user.

   $EXAMPLES$
      Determine the station numbers where JIM is logged in:

      cVar  :=  NNETOCNUMS("JIM")
      FOR I = 1 TO Len(cVar)
         ? Asc(SubStr(cVar, I, 1))               // Station numbers
      NEXT I
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETSTANUM(), NNETCOPRIV(), NNETSPRVSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPEXPD()
   $ONELINER$
      Sets or determines the password expiration date
   $SYNTAX$
      NNETPEXPD(<cUser>,[<dDate>],[<cServer>|<nConId>)
         --> dExpiration

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user whose password is set or
      determined.

      <dDate>  Designates the new expiration date for the password of
      <cUser>.

      <cServer>  Designates the name of the file server to which <cUser>
      has access.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPEXPD() returns the current expiration date of the password for
      <cUser>.  If <dDate> has been passed and the return value does not match
      <dDate>, the requesting user did not have the rights required for the
      modification.

   $DESCRIPTION$
      NOVELL NET PASSWORD EXPIRATION DATE
      NNETPEXPD() allows you to query or set the expiration date of the
      password of <cUser>. To determine the expiration date, do not pass a
      date for <dDate>.  If <dDate> contains a date, NNETPEXPD() tries to set
      a new expiration date.  Supervisor rights are required on the related
      file server to modify the expiration date.  An existing expiration date
      can be removed with an empty date.  With <cServer> or <nConId>, the
      password expiration date of users on any attached file servers can be
      modified.  The connection ID of a server is returned by NNETATTACH() or
      NNETLOGIN().

   $EXAMPLES$
      ■  Determine the password expiration date for user MIKE:

         ? NNETPEXPD('MIKE')               // z.B. 03/19/92

      ■  Set the new password expiration date for user MIKE:

         NNETPEXPD('MIKE',CToD('06/01/92'))

      ■  Remove the password expiration date for user MIKE:

         NNETPEXPD("MIKE",CToD(""))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPEXPI()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPEXPI()
   $ONELINER$
      Sets or determines the password expiration interval
   $SYNTAX$
      NNETPEXPI(<cUser>,[<nDays>],[<cServer>|<nConId>)
         --> nExpiration

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of user whose password expiration
      interval is set or determined.

      <nDays>  Designates the new password expiration interval of <cUser>.

      <cServer>  Designates the name of the file server to which <cUser>
      has access.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPEXPI() returns the current expiration interval of the password for
      <cUser>.  If <nDays> has been passed and the return value does not match
      <nDays>, the requesting user did not have the rights required for the
      modification.

   $DESCRIPTION$
      NOVELL NET PASSWORD EXPIRATION INTERVALL
      NNETPEXPI() allows you to query or set the expiration interval of the
      password of <cUser>. To determine the expiration interval, do not pass a
      value for <nDays>.  If <nDays> contains a numeric value, NNETPEXPI()
      tries to set this value as new expiration interval.  Supervisor rights
      are required on the related file server to modify the expiration
      interval.  An existing expiration interval can be removed if you set
      <nDays> equal to 0.  With <cServer> or <nConId>, the password expiration
      interval of users on any attached file servers can be modified.  The
      connection ID of a server is returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      ■  Determine the password expiration interval for user MIKE:

         ? NNETPEXPI('MIKE')                     // For example 40

      ■  Set the new password expiration interval for user MIKE:

         NNETPEXPI('MIKE',50)

      ■  Remove the password expiration interval for user MIKE:

         NNETPEXPI("MIKE",0)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPEXPD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPWGRCE()
   $ONELINER$
      Sets or queries the number of grace logins
   $SYNTAX$
      NNETPWGRCE(<cUser>,[<nNumber>],[<lMode>],[<cServer>|
         <nConId>) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user whose number of grace
      logins is set or determined.

      <nNumber>  Designates the new number of grace logins for <cUser>.
      The number of remaining grace logins or the maximum number of grace
      logins is set depending on the parameter <lMode>.

      <lMode>  Designates if the number of remaining grace logins (.F.) or
      the maximum number of grace logins (.T.) is set.  The default value is
      .F..

      <cServer>  Designates the name of the file server to which <cUser>
      has access.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPWGRCE() returns the currently valid number of grace logins for
      <cUser>.  Dependent on the parameter <lMode>, the return value contains
      the number of remaining grace logins (<lMode>=.F.) or the maximum number
      of grace logins (<lMode>=.T.).  If a value has been passed for <nNumber>
      and the return value does not match <nNumber>, the requesting user did
      not have the rights for the modification.

   $DESCRIPTION$
      NOVELL NET PASSWORD GRACE LOGINS
      NNETPWGRCE() indicates the number times a user can log in with an
      expired password.  With each login under an expired password, Netware
      reduces the number of remaining logins by 1.  However, the maximum
      number of grace logins remains unchanged.

      NNETPWGRCE() allows you to set or determine the number of remaining
      grace logins or the maximum number of grace logins for <cUser>. If the
      parameter <lMode> is not passed or is passed with .F.,  NNETPWGRCE()
      returns the number of remaining grace logins.  If the <lMode> paramter
      is passed with .T., the maximum number of grace logins can be set or
      determined.  To query the number of grace logins, do not pass a value
      for <nNumber>.  If <nNumber> contains a numeric value, NNETPWGRCE()
      tries to set this value as new number of grace logins.  Supervisor
      rights on the related file server are required to modify the number of
      grace logins.  With the parameters <cServer> or <nConId>, the number of
      grace logins for users on any attached file server can be changed.  The
      connection ID of a file server is returned by NNETATTACH() or
      NNETLOGIN().

   $EXAMPLES$
      ■  Determine the number of remaining grace logins for user MIKE:

         ? NNETPWGRCE('MIKE')              // For example 4

      ■  Determine the maximum number of grace logins for user MIKE:

         ? NNETPWGRCE('MIKE',,.T.)         // For example 6

      ■  Set the new maximum number of grace logins for user MIKE:

         NNETPWLEN('MIKE',8,.T.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPEXPD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPWLEN()
   $ONELINER$
      Sets or determines the minimum password length
   $SYNTAX$
      NNETPWLEN(<cUser>,[<nNumber>],[<cServer>|<nConId>)
         --> nPassLen

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user whose minimum password
      length is set or determined.

      <nNumber>  Designates the new minimum password length for <cUser>.

      <cServer>  Designates the name of the file server to which <cUser>
      has access.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPWLEN() returns the currently valid minimum password length for
      <cUser>.  If a value has been passed for <nNumber> and the return value
      does not match <nNumber>, the requesting user did not have the rights
      for the modification.

   $DESCRIPTION$
      NOVELL NET PASSWORD LENGTH
      NNETPWLEN() allows you to set or determine the minimum password length
      for <cUser>.  To query the minimum password length, do not pass a value
      for <nNumber>.  If <nNumber> contains a numeric value, NNETPWLEN() tries
      to set this value as new minimum password length.  Supervisor rights on
      the related file server are required to modify the password length.
      With <nNumber> equal to 0, a previously set password length can be
      removed.  In this case, a password for <cUser> is not required.

      With the parameters <cServer> or <nConId>, the password length for users
      on any attached file server can be changed.  The connection ID of a file
      server is returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      ■  Determine the minimum password length for user MIKE:

         ? NNETPWLEN('MIKE')               // For example 5

      ■  Set the new minimum password length for user MIKE:

         NNETPWLEN('MIKE',8)

      ■  Remove the limit of the password length for user MIKE:

         NNETPWLEN("MIKE",0)

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETREMGRP()
   $ONELINER$
      Removes one or more users from a group
   $SYNTAX$
      NNETREMGRP(<cGroup>,<cUser>|<aUser>,[<cServer>|
         <nConId>) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cGroup>  Designates the name of the group from which the user is
      removed.

      <cUser>  Designates the name of the user that is removed from
      <cGroup>.

      <aUser>  Designates a one-dimensional array of the type string.
      Each element contains the name of a user to be removed from <cGroup>.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETREMGRP() returns the number of users successfully removed from
      <cGroup>.  A return value of 0 indicates that no user has been removed.

   $DESCRIPTION$
      NOVELL NET REMOVE USER FROM GROUP
      NNETREMGRP() allows you to remove one or more users from a group.  To
      remove one user, the user's login name must be passed as the single
      argument <cUser>.   More users can be removed by passing the array,
      <aUser>.  Each element of the array, <aUser>, contains a user name.  As
      soon as a user has been removed from a group, the user loses all the
      rights that have been granted as a member of the group.  With the
      parameters <cServer> or <nConId>, users on any attached file servers can
      be removed.  The connection ID of a server is returned by NNETATTACH()
      or NNETLOGIN().

      Supervisor rights are required on the related file server to remove a
      user from a group.

   $NOTES$
      ■  NNETREMGRP() only removes the user from <Group>.  The user is
         not deleted.

      ■  NNETCRTUSR() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Remove user MIKE from the TECH group:

         IF NNETREMGRP('TECH','MIKE')>0
         ? 'User removed successfully!'
         ELSE
         ? 'User cannot not be removed!'
         ENDIF

      ■  Remove users JIM, STEPHEN and ED from the TOOLS group:

         NNETREMGRP('TOOLS',{'JIM','STEPHEN','ED'})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDGRP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSPRVSR()
   $ONELINER$
      Determines if the logged in user has supervisor rights
   $SYNTAX$
      NNETSPRVSR() --> lSupervisorMode

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETSPRVSR() returns .T. when the station that is queried has supervisor
      rights on the default file server.

   $DESCRIPTION$
      NOVELL NET SUPERVISOR
      Supervisor rights are the highest level rights within a network.  These
      rights allow a supervisor, or someone with the same security
      equivalence, access to all Netware functions.  For example, this
      function allows you to test to see if the account under which the
      station has been logged in has those rights.

   $NOTES$
      ■  Supervisor rights contain console privileges, existing in
         Netware 2.1/ELS II and up.

   $EXAMPLES$
      Test to see if you have supervisor rights:

      ? NNETSPRVSR()                     // .T., when yes
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETCOPRIV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETUSERS()
   $ONELINER$
      Determines the users on a file server
   $SYNTAX$
      NNETUSERS([<cServer>|<nConId>],[<cMask>])
         --> aUserListe

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server for which the
      users are determined.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.  If no server is specified, the function uses the default
      server.  .

      <cMask>  Designates a search mask that can contain the wildcard
      characters  "?" and "*".  The default character "*" indicates that all
      users are determined.

   $RETURNS$
      NNETUSERS() returns a one-dimensional array.  Each array element
      contains a user name.

   $DESCRIPTION$
      NOVELL NET USERS
      NNETUSERS() allows you to determine all the users of a file server.  The
      file server can be specified by either its name or its connection ID.
      The connection ID of a server is returned by NNETATTACH() or
      NNETLOGIN().

      In order to achieve results with this function, the requesting user must
      be currently logged in on the specified file server.  If the requesting
      user is not currently logged in on the specified file server, the
      function returns an empty array.

      The users currently logged in on a file server can be determined with
      the function NNETLGUSER().

   $EXAMPLES$
      Display a list of all the users on file server NANGERTOOLS2:

      aList=NNETUSERS('NANGERTOOLS2')
      FOR i = 1 TO Len(aList)
      ? aList[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETLGUSER(), NNETGROUPS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETUSINGR()
   $ONELINER$
      Determines the users that are members of a group
   $SYNTAX$
      NNETUSINGR(<cGroup>,[<cServer>|<nConId>]) --> aUserList

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cGroup>  Designates the group for which the members are determined.

      <cServer>  Designates the name of the file server on which <cGroup>
      is established.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.  If no server is specified, the function uses the default
      server.

   $RETURNS$
      NNETUSINGR() returns a one-dimensional array.  Each array element
      contains a user name.

   $DESCRIPTION$
      NOVELL NET USERS IN GROUP
      To improve organization and simplify user access to file server
      resources, you can create user groups under Novell Netware.  Each user
      can be a member of one or more groups.  With the function NNETUSINGR(),
      all the members of a user group can be determined.

      This function requires that the requesting user be logged in on the
      related file server.  If the requesting user is not logged in on the
      related file server, the function returns an empty array.

   $EXAMPLES$
      Display all the users that are members of the STONES group on the
      current file server:

      aList:=NNETUSINGR('STONES')
      FOR i = 1 TO Len(aList)
      ? aList[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETGROUPS(), NNETGRPMEM(), NNETINGRPS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETVPASS()
   $ONELINER$
      Verifies a password for a bindery object
   $SYNTAX$
      NNETVPASS(<cName>,[<nType>],<cPass>,[<cServer>|
         <nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the bindery object that is
      processed.

      <nType>  Designates the object type of <cName>.  The header file
      CTNNET.CH contains symbolic constants for a number of object types.  The
      default value designates the object type OBJ_USER.

      <cPass>  Designates the password that is verified for <cName>.

      <cServer>  Designates the name of the file server for which the
      bindery is accessed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETVPASS() returns .T. if the password <cPass> and the password of
      <cName> in the bindery are identical.  If these passwords are not
      identical, the function returns .F..

   $DESCRIPTION$
      NOVELL NET VERIFY BINDERY OBJECT PASSWORD
      NNETVPASS() allows you to check to see if a character string matches the
      password of a bindery object.  For example, the function can be used to
      verify a user's password.

   $EXAMPLES$
      Check to see if the password HONEY is valid for user JIM:

      IF NNETVPASS('JIM',,'HONEY')
      ? 'Valid password!'
      ELSE
      ? 'Invalid password!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCPASS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETUSERID()
   $ONELINER$
      Queries the established network user IDs
   $SYNTAX$
      NNETUSERID([<cUser>]) --> cUserID

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of an object of the type user (login
      name).  The default value designates the logged-in user.

   $RETURNS$
      NNETUSERID() returns the ID of the designated object of the type user.

   $DESCRIPTION$
      NOVELL NET USER ID
      With NNETUSERID(), the ID of an object of the type user can be
      determined if the user is not logged in on any station.  The function is
      always relative to the default file server.

      The returned character string corresponds to a hexadecimal (eight place)
      number that only occurs once within a network.

      If the optional <cUser> parameter is not specified, the function returns
      the ID for the name where one is currently logged in.  This corresponds
      to a NNETUSERID(NNETWHOAMI) call.

   $NOTES$
      ■  An object ID is automatically assigned by Novell software at
         its creation.

   $EXAMPLES$
      Deterine the ID of a login name:

      ? NNETUSERID("JIM")      // e.g. "0A002300"
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETSTANUM(), NNETSTAID()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Connection Services
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      This chapter provides functions that return information about the
      connection between workstations and file servers and allow you to set up
      or terminate connections.  Even the login of a user from within a
      CA-Clipper application is possible.  With the functions in this chapter,
      you can create a list of file servers within the internal network and
      all attached file servers, and you can determine the network address of
      a workstation.

      Important!  The term "attach" in conjunction with CA-Clipper Tools
      only describes the setup of a logical connection between a workstation
      and a file server and does not include a login, as is the case with the
      Novell utility ATTACH.EXE.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETADR()
   $ONELINER$
      Determines the internal netaddress of a user
   $SYNTAX$
      NNETADR([<cUser>],[<nNumber>],[<cServer>|<nConId>])
          --> cNetAddress

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the login name of the user whose internal
      netaddress is determined.  The default value is the internal netaddress
      of the current workstation.

      <nNumber>  Designates the connection of <cUser>.  The default value
      is 1.

      <cServer>  Designates the name of the file server on which <cUser>
      is logged in.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETADR() returns the internal netaddress of <cUser> in the form of a 20-
      character hexadecimal string.  The returned string represents a
      10-byte sequence, where each byte consists of two hexadecimal
      characters.  The leading eight characters of <cNetAddress> (four byte)
      specify the network number of <cUser>.  The remaining 12 characters (six
      byte) contain the station ID of <cUser> (number of the network adapter,
      Node Address).

      If an error occurs (no user is logged in with the name <cUser>),
      NNETADR() returns an empty string.

   $DESCRIPTION$
      NOVELL NET ADDRESS
      NNETADR() allows you to determine the internal netaddress of the
      workstation, where <cUser> is currently logged in.  For example, this
      address can be used to establish a Point-To-Point connection with
      <cUser>.

      Netware does not limit the number of workstations where a user can be
      simultaneously logged in.  The currently active connections can be
      passed with the optional parameter <nNumber>.  The default return value
      of NNETADR() contains the internal netaddress of the first connection.
      By passing <nNumber>, additional addresses can be determined.

   $NOTES$
      ■  <nNumber> does not specify the connection ID of <cServer>.
         This parameter simply counts the connections of <cUser>.

   $EXAMPLES$
      ■  Determine the internal netaddress of the first connection of
         user MIKE:

         ? NNETADR('MIKE')  // z.B. "4921750400001B025A99"

      ■  Determine the internal netaddresses of all connections of user
         MIKE:

         nNumber=1
         cAdr=""
         WHILE .T.
         cAdr=NNETADR('MIKE',nNumber)
         IF Empty(cAdr)
         EXIT
         ENDIF
         ? cAdr
         nNumber=nNumber+1
         ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSTAID()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETATTACH()
   $ONELINER$
      Attaches a file server to a workstation
   $SYNTAX$
      NNETATTACH(<cServer>) --> nConId

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the server that is attached.

   $RETURNS$
      If the server has been attached successfully, NNETATTACH() returns a
      numeric value between 1 and 8.  This value specifies the connection ID.
      The workstation uses the connection ID to address the server.

      If an error occurs, NNETATTACH() returns 0.  The error code can be
      queried with the function NNETERROR().

   $DESCRIPTION$
      NOVELL NET ATTACH
      A workstation can be attached to up to eight file servers.  This logical
      connection between workstation and file server is necessary to access
      network services and resources.  NNETATTACH() allows you to establish a
      connection without a login of the user on <cServer>.

      If the server has been attached successfully, NNETATTACH() returns a
      value between 1 and 8.  The return value can be stored in a variable and
      can be used later to identify a file server.  Alternatively, a file
      server can also be identified by using the server name.

      Using the NNETLOGIN() function to log in a user on a file server does
      not require the call of NNETATTACH().  NNETLOGIN() attaches the file
      server automatically if necessary.

   $NOTES$
      ■  The names of the attached file servers can be determined by
         using the function NNETFSLIST() or the Novell utility SLIST.

   $EXAMPLES$
      Attach the file server NANGERTOOLS2:

      nConId=NNETATTACH("NANGERTOOLS2")
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETLOGIN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCCNSRV()
   $ONELINER$
      Determines the number of attached file servers
   $SYNTAX$
      NNETCCNSRV([<lLoggedIn>]) --> nServer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <lLoggedIn>  Designates whether the number of all attached servers
      (.F.) or if the number of servers with logged in users (.T.) is
      determined.  The default value (.F.) counts all servers.

   $RETURNS$
      NNETCCNSRV() returns the number of attached servers.

   $DESCRIPTION$
      NOVELL NET COUNT CONNECTED SERVERS
      With the function NNETCCNSRV() you can determine the number of attached
      servers without having to specify the server names (NNETFSLST()).
      Alternatively, you can determine the number of servers, where the user
      is currently logged in.

   $EXAMPLES$
      Server1 is attached.  A user then logs into another server.  The
      information about the attached servers is determined by using
      NNETCCNSRV():

      NNETATTACH('SERVER1')
      NNETLOGIN('PAUL','190366','SERVER2')

      ? NNETCCNSRV()      // Returns: 2
      ? NNETCCNSRV(.T.)   // Returns: 1
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETATTACH(), NNETCCNSRV(), NNETLOGIN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCLRCON()
   $ONELINER$
      Clears a connection number
   $SYNTAX$
      NNETCLRCON(<nConnect>,[<cServer>|<nConId>])
          --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nConnect> Designates the connection number that is cleared.

      <cServer> Designates the name of the file server that is used.  Your
      workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETCLRCON() returns .T. if <nConnect> has been cleared successfully.
      If an error occurs, the function returns .F..

   $DESCRIPTION$
      NOVELL NET CLEAR CONNECTION
      When a workstation is first attached to a server, the Netware file
      server returns a connection number (connection ID) to the workstation.
      The file server keeps the connection ID even after a logout and is
      assigned to the related workstation at the next connection setup.
      However, the connection ID is changed, if all connection numbers are
      used.  In this case, the connection ID can be assigned to another
      workstation. NNETCLRCON() allows you to clear used connection numbers.

      Important!  If the connection <nConnect> is currently active, it is
      interrupted immediately.  This can lead to data loss on the related
      workstation, as all drive mappings become invalid and the writing of
      data to the server is no longer possible.

      Supervisor rights on the related file server are required to clear a
      connection.

   $NOTES$
      ■  This function should be used very carefully as data loss is
         possible if <nConnect> is currently active.

   $EXAMPLES$
      Determine the connection ID of the user MICK, and clear the connection
      (ATTENTION: MICK will be logged out):

      NNETCLRCON(NNETSTANUM('MICK'))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSTANUM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCVSSRV()
   $ONELINER$
      Determines the number of visible file servers in a network
   $SYNTAX$
      NNETCVSSRV([<cMask>]) --> nServer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cMask>  Designates a search mask that can contain the wildcards "?"
      and "*".  The default value ("*") indicates that all file servers are
      taken into account.

   $RETURNS$
      NNETCVSSRV() returns the number of visible file servers that match the
      search mask, <cMask>.  Without argument, the function returns the number
      of all servers within a network.

   $DESCRIPTION$
      NOVELL NET COUNT VISIBLE SERVERS
      With NNETCVSSRV() you can determine the number of all visible file
      servers in a network without having to specify the server names
      (NNETFSLST()).  For example, you can determine if all file servers in a
      WAN are available or if some file servers are currently unavailable.

   $EXAMPLES$
      Determine the number of all visible file servers:

      ? NNETCVSSRV()                        // Returns: 6
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCCNSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDISLOG()
   $ONELINER$
      Disables a file server for logins
   $SYNTAX$
      NNETDISLOG([<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server that is used.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDISLOG() returns .T., if the file server has been successfully
      disabled for logins.  If an error occurs (for example, insufficient
      access rights), the function returns .F..

   $DESCRIPTION$
      NOVELL NET DISABLE LOGIN
      NNETDISLOG() allows you to disable a file server for further logins of
      new users.  For example, you should use this function if you want to
      execute a data backup.  Console rights are required to disable a file
      server for logins with NNETDISLOG().

   $EXAMPLES$
      Disable the default server for further logins:

      IF NNETDISLOG()
         ? 'Server disabled for logins!'
      ELSE
         ? 'Error!
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETENLOG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETENLOG()
   $ONELINER$
      Enables a file server for logins
   $SYNTAX$
      NNETENLOG([<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer> Designates the name of the file server that is used.  Your
      workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETENLOG() returns .T. if the file server has been successfully enabled
      for logins.  If an error occurs (for example, insufficient access
      rights), the function returns .F..

   $DESCRIPTION$
      NOVELL NET ENABLE LOGINS
      NNETENLOG() allows you to enable a file server for logins if it has been
      previously disabled with NNETDISLOG().  Console rights are required to
      enable a file server for logins with NNETENLOG().

   $EXAMPLES$
      Enable the default server for logins:

      NNETENLOG()
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETDISLOG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETFSLST()
   $ONELINER$
      Determines the names of all visible file servers within a network
   $SYNTAX$
      NNETFSLST([<cMask>]) --> aServerList

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cMask>  Designates a search mask that can contain the wildcard
      characters "?" and "*".  The default value ("*") indicates that all
      server names are returned.

   $RETURNS$
      NNETFSLST() returns a one-dimensional array.  Each array element
      contains one server name.

   $DESCRIPTION$
      NOVELL NET FILE SERVER LIST
      NNETFSLST() returns the names of all visible file servers, whether the
      server is attached or not.  With this function you can determine if you
      can address a specific file server before you call NNETATTACH() or
      NNETLOGIN().

   $NOTES$
      ■  Unlike NNETSLIST(), which returns the names of the attached
         servers (maximum of eight), NNETFSLST() returns the names of all
         servers within a network.

   $EXAMPLES$
      ■  Display the names of all the file servers in a network:

         aServer=NNETFSLST()
         FOR i = 1 TO Len(aServer)
         ? aServer[i]
         NEXT i

      ■  Select a file server with AChoice(), and then log in a user:

         aServer=NNETFSLST()
         IF (nSelect:=AChoice(5,5,8,45,aServer))>0
         NNETLOGIN("PAUL","190366",aServer[nSelect])
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETATTACH(), NNETLOGIN(), NNETSLIST(), NNETCVSSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETINUSE()
   $ONELINER$
      Returns the number of objects currently logged into the network
   $SYNTAX$
      NNETINUSE() --> nStations

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETINUSE() returns the number of stations currently in use on the
      default file server.

   $DESCRIPTION$
      NOVELL NET IN USE
      With NNETINUSE() you can determine the number of stations that are
      currently in use on the default file server.  For example, you could
      provide an overview of network capacity.

   $NOTES$
      ■  The returned value does not agree with the users that are
         displayed in USERLIST or CONNECTION INFORMATION within FCONSOLE.  You
         will always have at least one more channel that is open than there
         are users in the network.  The returned value for Netware, versions
         2.1 or later, agree with STATISTIC --> SUMMARY --> CONNECTIONS IN USE
         under FCONSOLE.

   $EXAMPLES$
      Determine the stations in use on the default file server:

      ? NNETINUSE()                        // e.g. 7
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETLOGGED()
   $ONELINER$
      Determines if a station has logged in using LOGIN
   $SYNTAX$
      NNETLOGGED() --> lLoggedIn

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETLOGGED() returns .T. when the related station is logged in on the
      default file server.

   $DESCRIPTION$
      NOVELL NET LOGGED IN
      This function allows you to determine if the related station is logged
      into the network.  This is important information since LOGIN is a
      prerequisite to having any rights within a network.

   $EXAMPLES$
      Determine if this station on the default server is logged in:

      ? NNETLOGGED()            // .T., when logged in
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETLOGIN()
   $ONELINER$
      Log in a user on a file server
   $SYNTAX$
      NNETLOGIN(<cName>,<cPassword>,[<cServer>|<nConId>])
          --> nConId

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the user that is logged in.

      <cPassword>  Designates the corresponding password.  If no password
      is required, an empty string must be passed.

      <cServer>  Designates the name of the file server on which the user
      is logged in.

      <nConId>  Designates the connection ID of the workstation on
      <cServer>.  A connection ID can be passed only if the file server is
      attached to the workstation.

   $RETURNS$
      If a user has been logged in successfully, NNETLOGIN() returns a value
      between 1 and 8.  This value represents the connection ID that can be
      used to address the file server on the workstation.  If an error occurs,
      the function returns 0.

   $DESCRIPTION$
      NNETLOGIN() allows you to log in a user on a file server within an
      application.  The file server must not be attached when you call this
      function.  When NNETLOGIN() is first called, it automatically attaches
      the workstation to <cServer>.  If no server is specified, the function
      tries to log in the user on the default server.

      If a user at the requesting workstation is already logged in on the
      related file server, this user is logged out automatically.  The log out
      is performed even if the name of the logged in user is identical to the
      user name passed with NNETLOGIN().  If the attempt to log in is
      unsuccessful (for example, because of an incorrect password), the
      previous log in is canceled.  Any drives mapped to the related file
      server are deleted and are not restored even if the log in is
      successful.

      Important!  Before you attempt to log in on file servers where a
      user is already logged in on the current workstation, make sure that all
      files on the volumes of the related file server are closed correctly.

      A return value that is greater than 0 indicates that the log in has been
      successful.  The value can be stored in a variable and used later to
      identify the required file server.  Alternatively, the identification of
      the server is possible with the server name.

   $NOTES$
      ■  The password is case sensitive.

      ■  If the log in is unsuccessful (for example, because of an
         invalid password or user name), the server remains attached.

      ■  The function does not execute a login script.  To get a login
         script, the function must be called.

   $EXAMPLES$
      ■  Log in Paul on server NANGERTOOLS2:

         IF (nConId:= NNETLOGIN('PAUL','190366','NANGERTOOLS2'))>0
         ? 'Login successful!'
         ELSE
         ? 'Login failed!'
         ENDIF

      ■  Log in on an attached server:

         IF (nConId:=NNETATTACH('NANGERTOOLS2'))>0
         NNETLOGIN('PAUL','190366',nConId)
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETATTACH(), NNETFSLST(), NNETLOGOUT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETLOGOUT()
   $ONELINER$
      Log out a user of one or all file servers
   $SYNTAX$
      NNETLOGOUT(<cServer>|<nConId>|<lAll>,[<lConnect>])
          --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server on which a user is
      logged out.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

      <lAll>  Allows a log out from all file servers if designated .T..

      <lAttach>  Designates whether or not the file server remains
      attached.  If a user logs out on a file server, the workstation and the
      server are detached.  If the parameter <lAttach> is designated .T., the
      workstation remains attached to <cServer>.

   $RETURNS$
      NNETLOGOUT() returns .T. if the log out has been successful.  If an
      error occurs (for example if the server name or the connection ID are
      invalid), the function returns .F..

   $DESCRIPTION$
      NOVELL NET LOGOUT
      NNETLOGOUT() allows you to log out a user on one or all file servers.

      To log out on a server, the server can be specified either by its name
      or its connection ID.  The connection ID of a server is returned by
      NNETATTACH() or NNETLOGIN().  To log out a user on all servers, the
      parameter <lAll> must be designated .T..

      Usually if you log out on a file server, the workstation connection is
      terminated (detached).  However ,if you want to remain attached to the
      related file server, you can pass the parameter <lAttach> with .T..

      To be able to perform a successful log in, at least one file server must
      be attached.  Therefore, when you use the function NNETLOGOUT(), the
      default server always remains attached and is independent of the
      parameter <lAttach>.

      NNETLOGOUT() can also be used to terminate a connection between a
      workstation and a file server (detach) when no user is logged in.

      Important!  When you call NNETLOGOUT(), all drive mappings for the
      specified server or all servers are terminated.  Files on related server
      volumes cannot be accessed, which can lead to data loss.  Before you use
      NNETLOGOUT(), make sure that all files on the network drives have been
      closed properly.

   $NOTES$
      ■  The server name <cServer> must be passed in uppercase letters.

   $EXAMPLES$
      ■  Close all databases, and then log out on all file servers:

         CLOSE DATABASES
         NNETLOGOUT(.T.)

      ■  After you call NNETLOGOUT(), the default server is still
         attached.

      ■  Log out on server NANGERTOOLS2:

         NNETLOGOUT('NANGERTOOLS2')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETLOGIN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETNAME()
   $ONELINER$
      Determines the user name for an internal netaddress
   $SYNTAX$
      NNETNAME(<cInterNetAdr>,[<cServer>|<nConId>]) --> cUser

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cInterNetAdr>  Designates a 20-character string containing a 10-
      character hexadecimal byte sequence.  Two characters represent one byte
      in hexadecimal form.  The leading eight characters of <cInterNetAdr>
      (four byte) indicate the network number of <cUser>.  The remaining 12
      characters (six byte) contain the station ID of <cUser> (number of the
      network adapter, Node Address).

      <cServer> Designates the name of the file server that is used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETNAME() returns the name of the user that is logged in with the
      internet address, <cInterNetAdr>.  The function returns an empty string
      if the user cannot be determined.

   $DESCRIPTION$
      NOVELL NET NAME
      NNETNAME() allows you to determine the name of a user with an internal
      netaddress and can be used in conjunction with the SPX functions of the
      Point to Point communication.  Functions like SPXCONTARG() always return
      the communication's destination as an internet address.  If both the
      current station and the station specified by <cInterNetAdr> are logged
      in on <cServer>, NNETNAME() allows you to determine the user name of a
      passed internet address.

   $EXAMPLES$
      Determine the destination's user name of an SPX session:

      ? NNETNAME(SPXCONTARG(nHandle))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSTAID(), SPXCONTARG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSETSRV()
   $ONELINER$
      Sets an attached server as the default server
   $SYNTAX$
      NNETSETSRV(<cServerName>) --> lLoggedIn

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServerName> Designates the name of the server that is redirected
      as the default server.

   $RETURNS$
      NNETSETSRV() returns .T. when the designated name has been found in the
      attached server table and designated as the default server.

   $DESCRIPTION$
      NOVELL NET SET SERVER
      With NNETSETSRV(), it is possible to designate an attached server as the
      default server.  Then all NNETXXXXXX() functions except NNETSLIST()
      (list of the attached servers) and NNETSTAID() (station ID) relate to
      this server specifically.

   $EXAMPLES$
      Switch from CA1 server to CA2 server:

      ? NNETSNAME()                        // "CA1"
      ? NNETSETSRV("CA2")                  // .T., if OK.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSLIST()
   $ONELINER$
      Returns a list of all the attached file servers
   $SYNTAX$
      NNETSLIST() --> cServerList

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETSLIST() returns the names of all the attached servers.

   $DESCRIPTION$
      NOVELL NET SERVER LIST
      This function allows you to determine the names of all the servers
      attached through the station.  The character string that is returned
      contains all the server names separated by a CR/LF.  Each of the servers
      that are returned can be redirected as the default server using
      NNETSETSRV().

   $EXAMPLES$
      Determine the names of all attached servers:

      cSList  :=  NNETSLIST()
      TokenInit(@cSList, Chr(10)+Chr(13))
      DO WHILE .NOT. TokenEnd()
         cServer  :=  TokenNext(cSList)
         ? cServer
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSNAME()
   $ONELINER$
      Returns the name of the default file server
   $SYNTAX$
      NNETSNAME() --> cServerName

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETSNAME() returns the name of the default file server.

   $DESCRIPTION$
      NOVELL NET SERVER NAME
      This function allows you to determine the name of the default file
      server.  The returned character string can be up to 48 characters long.
      The NNETSETSRV() function allows you to set another attached file server
      as the default file server.

   $EXAMPLES$
      Determine the name of the default file server:

      ? NNETSNAME()                           // e.g. "CA"
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSTAID()
   $ONELINER$
      Determines the ID of a station (network card)
   $SYNTAX$
      NNETSTAID() --> cStationID

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETSTAID() returns a network station ID as a 12-character string.

   $DESCRIPTION$
      NOVELL NET STATION ID
      This function returns the ID of the network adapter that is built into
      the station.  In the case of an Ethernet card, this ID is the full 12
      characters in length; it is guaranteed that this code is unique.  With
      other types of network cards, and frequently with Ethernet clones, this
      ID depends upon the DIP switch settings on the adapter.  These switches
      must have different settings for each adapter within a network.

   $NOTES$
      ■  If an ID is shorter than 12 characters, the empty places in
         the character string are filled with zeroes, starting from the left.

   $EXAMPLES$
      Determine the station ID:

      ? NNETSTAID()         // e.g. "000F71100123"
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSTANUM(), NNETUSERID()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSTANUM()
   $ONELINER$
      Queries the station number on a file server
   $SYNTAX$
      NNETSTANUM() --> nStation

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETSTANUM() returns the station number of the workstation, relative to
      the default server.

   $DESCRIPTION$
      NOVELL NETSTATION NUMBER
      With NNETSTANUM(), you can query the station number of the network
      station where the function has been implemented can be queried.  This
      information is always relative to the default file server.  The function
      returns a numeric value, based on Netware version, between 1 and 99.  If
      the value is used in file names, then it can be expanded with leading
      zeroes using the NToC() function.

   $EXAMPLES$
      Query the station number as a fixed length string:

      ? NToC(NNETSTANUM(), 10, 2, "0")                     // e.g. 09
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETUSERID()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETWHOAMI()
   $ONELINER$
      Determines the station LOGIN name
   $SYNTAX$
      NNETWHOAMI() --> cStationName

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETWHOAMI() returns the names that are logged in at the station in use
      on the default file server.

   $DESCRIPTION$
      NOVELL NET WHO AM I
      The CA-Clipper NetName() function returns information (limited by the
      Novell software) in a Novell network when a machine name is defined in
      the login script.  However, NNETWHOAMI() is a special Novell call that
      returns the name logged in at a station.  The returned character string
      can be up to 48 characters long.

   $EXAMPLES$
      Determine the name under which the station is logged in:

      ? NNETWHOAMI()      // Character string/max 48 characters
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Capture Services
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      The functions of this chapter allow the start and termination of capture
      processes from within a CA-Clipper application.  Additionally, the most
      important parameters for a capture process can be set.

      The Print Job Definition chapter can be substituted for these functions.
      When working with print job definitions you do not have to worry about
      the settings of capture processes.  You only have to activate a print
      job definition that can be created and maintained with the Novell
      utility PRINTCON.EXE.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETBANNER()
   $ONELINER$
      Sets or queries the current banner name
   $SYNTAX$
      NNETBANNER([<cBannerName>]) --> cName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cBannerName>  Designates an optional parameter that must be passed
      to set a new banner name for the current capture processes.

   $RETURNS$
      NNETBANNER() returns the banner name that is set.

   $DESCRIPTION$
      NOVELL NET BANNER
      NNETBANNER() allows you to set or determine the current banner name.  To
      query the banner name, the function can be called without the parameter.
      To set a new banner name, the name must be passed in <cBannerName>.  The
      banner name is the same for all current capture processes (capture for
      different interfaces).

   $EXAMPLES$
      ■  Determine the current banner name:

         ? NNETBANNER()

      ■  Set the banner name to MICK:

         NNETBANNER('MICK')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJBAN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCAPACT()
   $ONELINER$
      Determines if the capture mode is active for an LPT device
   $SYNTAX$
      NNETCAPACT(<nPrinter>) --> lActive

      Netware : 2.2 and 3.11

   $ARGUMENTS$
      <nPrinter>  Designates the LPT device that is examined to determine
      if the capture mode is active.  LPT1(1) to LPT3(3) are allowed.

   $RETURNS$
      NNETCAPACT() returns .T. when the capture mode for the designated LPT
      device is active.

   $DESCRIPTION$
      NOVELL NETWORK CAPTURE ACTIVE
      With NNETCAPACT(), you can determine if the capture mode is active for
      the designated LPT device and if the printer output has been redirected
      accordingly.  If the function returns .T., the print output is on the
      network server in the allocated queue.

   $EXAMPLES$
      Determine the capture mode status for LPT1:

      NNETCAPBEG(1)                 // Start capture mode
      ? NNETCAPACT(1)               // .T.
      NNETCAPEND(1)                 // End capture mode
      ? NNETCAPACT(1)               // .F.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPBEG(), NNETCAPEND(), NNETCAPCAN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCAPBEG()
   $ONELINER$
      Activates the capture mode for an LPT device
   $SYNTAX$
      NNETCAPBEG(<nPrinter>)    --> lActivate

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPrinter>  Designates the LPT device for which the capture mode is
      activated.  LPT1(1) to LPT3(3) are possible.

   $RETURNS$
      NNETCAPBEG() returns .T. when the capture mode for the designated LPT
      device can be activated.

   $DESCRIPTION$
      NOVELL NETWORK CAPTURE BEGIN
      With NNETCAPBEG(), the capture mode for a particular LPT device can be
      activated directly from within a CA-Clipper application.  Optimal
      control of print output within a Novell network is possible in
      conjunction with other NNETCAPXXX() functions.

      All print output parameters (flags) can be selected using the
      NNETCAPSSF() function.  These parameters must be set before every BEGIN
      CAPTURE command.  In this way, the auto form feed, the banner page, and
      other settings can be carried out from within the CA-Clipper program.

      By contrast, the print queue can be selected using the NNETSETQ()
      function, where another server had been previously selected using
      NNETSETSRV().

   $EXAMPLES$
      Activate the capture mode for LPT2:

      SET PRINTER TO LPT2
      ? NNETCAPBEG(2)                  // .T., when active
      SET PRINT ON
         ? "That is a test 234"
      SET PRINT OFF
      NNETCAPEND(2)                    // End capture mode
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPSSF(), NNETSETQ(), NNETSETSRV(), NNETCAPEND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCAPCAN()
   $ONELINER$
      Deactivates the capture mode and aborts the print job
   $SYNTAX$
      NNETCAPCAN(<nPrinter>) --> lAbort

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPrinter>  Designates the LPT device for which the network print
      output is aborted.  LPT1(1) to LPT3(3) are possible.

   $RETURNS$
      NNETCAPCAN() returns .T. when an existing network print output has been
      aborted.

   $DESCRIPTION$
      NOVELL NETWORK CAPTURE CANCEL
      Using NNETCAPCAN(), you can deactivate an existing capture mode and
      abort the print job in progress.  Only output not yet "in service" is
      aborted.  If the capture mode is not active, the function returns .F..

   $NOTES$
      ■  If a timeout is selected using NNETCAPSSF(), it is possible
         that the print job in progress is already "in service".

   $EXAMPLES$
      Activate the capture mode for LPT3.  Then either abort or pause the
      print job:

      SET PRINTER TO LPT3
      ? NNETCAPBEG(3)               // .T., if active
      SET DEVICE TO PRINT
         @ 10, 10 SAY "This is a test 234"
      SET DEVICE TO SCREEN
      EJECT
      Key  :=  Inkey(0)
      IF Key = 27                   // ESC do not print
         NNETCAPCAN(3)
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPBEG(), NNETCAPEND(), NNETCAPSSF()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCAPEND()
   $ONELINER$
      Terminates the capture mode for an LPT device
   $SYNTAX$
      NNETCAPEND(<nPrinter>) --> lTerminate

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPrinter>  Designates the LPT device for which the capture mode is
      terminated.  LPT1(1) to LPT3(3) are possible.

   $RETURNS$
      NNETCAPEND() returns .T. when an existing capture mode for the
      designated LPT device has been terminated.

   $DESCRIPTION$
      NOVELL NETWORK CAPTURE END
      This function can terminate an active capture mode.  Subsequent print
      output occurs on the local printer.  Print jobs still open are
      terminated and transferred to "service".

   $NOTES$
      ■  If you want to abort the output for the last print job "in
         progress", use NNETCAPCAN().

   $EXAMPLES$
      Activate the capture mode for LPT1, and turn it off after the ensuing
      print output:

      SET PRINTER TO LPT1
      ? NNETCAPBEG(1)                // .T. when active
      SET DEVICE TO PRINT
         @ 10, 10 SAY "This is a test 234"
      SET DEVICE TO SCREEN
      EJECT
      NNETCAPEND(1)                  // Terminate LPT1 capture
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPBEG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCAPFLU()
   $ONELINER$
      Closes the current print job and dispatches it
   $SYNTAX$
      NNETCAPFLU(<nPrinter>) --> lTransfer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPrinter>  Designates the LPT device for which an active print job
      is closed and transferred to "service".  LPT1(1) to LPT3(3) are
      possible.

   $RETURNS$
      NNETCAPFLU() returns .T. when the print job has been transferred to
      "service".

   $DESCRIPTION$
      NOVELL NETWORK CAPTURE FLUSH
      In CA-Clipper, print output occurs in the network when the application
      has been exited or the device has been closed.  To close the current
      print job and dispatch that job, you can set a timeout with the
      NNETCAPSSF() or use the NNETCAPFLU() function.

      If a timeout does not provide you with an acceptable solution, you can
      close a previously occurring print job using the NNETCAPFLU() function
      under Novell; the print job is transferred to "service".  Internally,
      this function corresponds to the END CAPTURE or START CAPTURE commands.
      Subsequent print output can occur in the network without calling
      NNETCAPBEG() again.

   $EXAMPLES$
      Activate the capture mode for LPT1, and then stop it after the print
      output occurs:

      SET PRINTER TO LPT1
      ? NNETCAPBEG(1)               // .T. if active
      SET DEVICE TO PRINT
      ? "This is a test 234"
      SET DEVICE TO SCREEN
      EJECT
      NNETCAPFLU(1)                 // Terminate print job.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPBEG(), NNETCAPEND(), NNETCAPCAN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCAPSSF()
   $ONELINER$
      Sets the Novell capture mode flags
   $SYNTAX$
      NNETCAPSSF(<nPrinter>,[<lPageFeed>,<lBanner>,
         <nServerPrinterNr>,<nTimeout>,<nTab>,<nCopies>,
         <nForm>]) --> lAmended

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPrinter>  Designates the number of the LPT device for which the
      flags are set.  LPT1(1) to LPT3(3) are possible.

      <lPageFeed>  Designates whether the form feed at the end of a print
      job is suppressed (.T.) or transmitted (.F.).  The default value is .F..

      <lBanner>  Designates whether a banner page is transmitted (.T.) or
      not (.F.).  The default value is .F..

      <nServerPrinterNr>  Designates the server printer number between 0
      and 4.  The default value for the server printer is 0.

      <nTimeout>  Designates if a timeout is used and which one.  When you
      input 0, print jobs are not "sent off" after a particular time span.
      However, you can specify a time delay in seconds.  The default value (0)
      specifies no timeout.

      <nTab>  Designates which tabs are used, if any.  If this parameter
      is a 0, there are no tabs.  You can designate tab values between 1 and
      18.  The default value (0) specifies no tabs.

      <nCopies>  Designates the number of copies of the print job that the
      server creates.  Values between 1 and 255 are valid.  The default value
      (1) creates one copy.

      <nForm>  Designates the form definition that the server uses during
      printing.  Values between 0 and 255 are valid.  The default value
      specifies that no form definition is used.

   $RETURNS$
      NNETCAPSSF() returns .T. when the flags for the capture system have been
      changed to the designated values.

   $DESCRIPTION$
      NOVELL NETWORK CAPTURE SET SPECIFIC FLAGS
      This function allows you to make settings for the Novell capture mode.
      These setting are normally done in conjunction with the CAPTURE command
      in the DOS environment or through the PRINTCON for the print job.  All
      capture mode settings must be complete before you initiate a START
      CAPTURE command, or there is no effect.

   $NOTES$
      ■  If this function has not yet been called during the course of
         an application, the values preset by Novell or those selected in the
         last capture mode apply.

      ■  A precise description of the flags can be found in the Novell
         Command Utilities Handbook under the Capture Commands heading.

   $EXAMPLES$
      ■  Configure a print job.  Specify LPT1; suppress the form feed,
         and the "banner page"; and specify server printer 1:

         ? NNETCAPSSF(1, .T., .F., 1)      // .T. when set

      ■  Specify LPT2, with form feed and banner page, server printer
         0, a 5-second timeout, a tab width of 8, and two print copies:

         NNETCAPSSF(2, .F., .T., 0, 5, 8, 2)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPBEG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Drive Mapping
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      The functions in this chapter let you manipulate the drive mapping of
      workstations.  New mappings can be executed, and existing mappings can
      be deleted.  Furthermore, you can query information about current
      mappings.  The basic function of this group of functions is NNETMAP().
      NNETMAP() is used to create or delete an allocation.  All extended
      possibilities, such as search drives and fake roots, are supported.
      Drive mappings can be defined temporarily.  Temporary mappings are
      deleted automatically at the end of an application.

      In conjunction with the ability to log in a user with NNETLOGIN(), the
      functions of this chapter allow you to set up the complete network
      environment of a workstation within an application.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDELFAK()
   $ONELINER$
      Deletes the fake root mapping for a drive
   $SYNTAX$
      NNETDELFAK([<cDrive>]) --> NIL

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDrive>  Designates a drive (A to .Z) or a search drive that has
      been mapped to a network directory as a fake root.  When called without
      the parameter, NNETDELFAK() uses the default drive.

   $DESCRIPTION$
      NOVELL NET DELETE FAKE ROOT MAPPING
      NNETDELFAK() deletes an existing fake root mapping for <Drive>.  The
      function does not affect the drive mapping.  After the fake root mapping
      has been deleted, you can also access parent directories of the fake
      root on <cDrive>.

   $NOTES$
      ■  Fake roots require Novell shell version 3.01 or higher.

   $EXAMPLES$
      Map drive M: as a fake root, then delete the fake root mapping and
      change to the parent directory of the fake root:

      NNETMAP('M','SYS:PAUL',.T.)
      NNETDELFAK('M')
      DirChange('M:..')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMAP(), NNETFAKDEP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETFAKDEP()
   $ONELINER$
      Determines the relative directory depth under a fake root
   $SYNTAX$
      NNETFAKDEP([<cDrive>]) --> nDepth

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDrive>  Designates a drive (A to .Z) or a search drive (S1 to
      .S16) that has been mapped to a network directory as fake root.  When
      called the parameter, the function uses the default drive.

   $RETURNS$
      NNETFAKDEP() returns the relative depth under the fake root directory.
      If the specified drive has not been mapped as fake root, NNETFAKDEP()
      returns -1.  If <cDrive> does not exist, the return value is -2.

   $DESCRIPTION$
      NOVELL NET FAKE DEPTH
      If a network drive has been mapped as a so-called fake root, it becomes
      the apparent root of the allocated drive.  After a directory change,
      NNETFAKDEP() returns the number of directories under the fake root.
      Depth 0 is assigned to the root directory.  Additionally, NNETFAKDEP()
      allows you to determine if a drive has been mapped as a fake root
      (return value => 0) or a normal drive (return value < 0).

   $NOTES$
      ■  Fake roots require shell version 3.01 or higher.

   $EXAMPLES$
      Map drive M: as a fake root, then change the directory, and query the
      relative directory depth:

      NNETMAP('M','SYS:PAUL',.T.)
      DirChange('M:\DATA')
      ? NNETFAKDEP('M')                        // Returns: 1
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETDELFAK(), NNETMAP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMAP()
   $ONELINER$
      Maps and unmaps drives
   $SYNTAX$
      NNETMAP([<cDrive>],[<cPath>],[<lFake>],[<lTemp>]
         [<lInsert>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDrive>  Designates the drive that is mapped or unmapped.  Valid
      identifiers are "A" to "Z" and "S1" to "S16" (search drives).  When
      called without this parameter, the function uses the current drive.

      <cPath>  Designates the path on a server volume that is assigned to
      <cDrive>.  This parameter must be passed if a drive is mapped.  When
      called without <cPath>, NNETMAP() deletes a mapping for <cDrive>.

      <lFake>  Designates whether <cPath> is created as fake root (.T.) or
      not (.F.).  The default value (.F.) designates that <cPath> is not a
      fake root..

      <lTemp>  Designates whether the mapping is permanent (.F.) or
      temporary (.T.).  The default value is .F..

      <lInsert>  Designates whether the mapped search drive (S1 to S16)
      replaces an existing search drive (.F.) or is inserted on the position
      before the old entry (.T.).  This parameter is only important if
      <cDrive> is a search drive.  The default value is .F..

   $RETURNS$
      NNETMAP() returns .T. if the operation has been successful.

   $DESCRIPTION$
      NOVELL NET MAP
      NNETMAP() allows you to map or unmap drives and search drives within an
      application.  If NNETMAP() is called with only the <cDrive> parameter,
      the mapping for the drive is deleted.

      To map a drive, NNETMAP() must be called with the arguments <cDrive> and
      <cPath>.  The path can contain a local drive designator, path, server
      name, volume name, and already mapped drives as well as search drives.
      The default mapping is permanent which means that the mapping continues
      after the application that created the mapping terminates.  If the
      mapping is terminated with the application, the parameter <lTemp> must
      be set to .T..

      The directory <cPath> becomes the root of <cDrive> if the parameter
      <lFake> is set to .T..

      NNETMAP() allows you to create search drives.  Up to 16 search drives,
      "S1" to "S16" can be addressed.  If a search drive is created (Sn,
      n=1..16), NNETMAP() determines the first available drive designator with
      a descending search that starts with "Z".  If no designator is
      available, NNETMAP() cannot perform the allocation and returns .F..  If
      a designator is available, <cPath> is mapped to the drive designator and
      the drive is set on position n in the path environment variable.  The
      previous entry in the path variable is replaced.  If <lInsert> is set to
      .T., the drive  designator is placed before position n in the path list.
      To delete the mapping for a search drive, <cDrive> can be passed either
      with the search drive (S1 to S16) or the drive designator.  The drive
      designator is removed from the path variable.

   $NOTES$
      ■  Fake roots require Novell shell version 3.01 or higher.  If
         version 3.01 or higher is not available, the attempt to map a fake
         root fails (<cFake>=.T.) and NNETMAP() returns .F..

      ■  You cannot add a new search drive if the path environment
         variable already contains 16 entries.

      ■  Do not create temporary search drives because the drive
         mapping is canceled in the program; the invalid drive designator is
         not removed from the path variable.

   $EXAMPLES$
      ■  Map drive L: to directory PUBLIC on server NANGERTOOLS2,
         volume SYS:

         ? NNETMAP('L','NANGERTOOLS2/SYS:PUBLIC')

      ■  Map directory ABC to the next available drive designator,
         starting from drive L:

         ? NNETMAP(NNETNXTFRE(),'L:ABC')

      ■  Create directory SYS:DATA as a permanent search drive on the
         current server, and insert the search drive on position 5 in the path
         variable.  The directory becomes the root for the new drive:

         ? NNETMAP('S5','SYS:DATA',.T.,,.T.)

      ■  Terminate the mapping for drive K:

         NNETMAP('K')

      ■  If K: was a search drive, it is removed from the PATH
         variable.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETNXTFRE(), NNETMAPINF()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMAPINF()
   $ONELINER$
      Determines the mapping for a drive
   $SYNTAX$
      NNETMAPINF([<cDrive>],[<lExpand>]) --> cPath

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDrive>  Designates the drive for which the mapping is determined.
      Without this parameter, NNETMAPINF() returns the mapping for the default
      drive.  Values from "A" to "Z" for a normal drive and "S1" to "S16" for
      a search drive are possible.

      <lExpand>  Designates how the search drives are handled.  When
      called without this parameter, or when the parameter is .F., the
      function returns the drive that corresponds to a search drive
      designator, followed by a colon and a period.  When called with
      <lExpand> equal to .T., NNETMAPINF() returns the network path assigned
      to the drive designator.  The default value is .F..

   $RETURNS$
      NNETMAPINF() returns the path that has been mapped to <cDrive> with the
      function NNETMAP().  For normal network drives, the return value
      contains the server name, the volume name, and the directory.  For
      search drives, the return value depends on the parameter <lExpand>.  If
      this parameter is set to .F., the function returns the drive, followed
      by a colon and a period.  If this parameter is set to .T., the complete
      network path is returned.  If <cDrive> contains a local drive,
      NNETMAPINF() returns the drive designator, followed by a colon.  An
      empty string is returned if the designated drive does not exist.

   $DESCRIPTION$
      NOVELL NET MAP INFORMATION
      In a Novell environment, NNETMAPINF() allows you to differentiate
      between local, network, or unassigned drive designators.  For a network
      drive, the function returns the server name, the volume name, and the
      path allocated to <cDrive>.  For a search drive, you can determine the
      drive designator.

   $EXAMPLES$
      ■  Determine the mapping for drive C:

         ? NNETMAPINF('C')         // C: is a local hard disk

      ■  Determine the mapping for drive J:

         ? NNETMAPINF('J')         // Login directory
         NANGERTOOLS2/SYS:LOGIN

      ■  Determine the mapping for search drive S13:

         ? NNETMAPINF('S13')       // Returns: Z:.

      ■  Determine the mapping for search drive S13 as a complete path:

         ? NNETMAPINF('S13',.T.)
         NNANGERTOOLS2/SYS:PUBLIC
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMAP(), NNETMAPMOD(), NNETSEARCH()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMAPMOD()
   $ONELINER$
      Determines the mapping mode for a drive
   $SYNTAX$
      NNETMAPMOD([<cDrive>]) --> nMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDrive>  Designates the drive (A to Z, S1 to S16) for which the
      mapping mode is determined.  Without this parameter, NNETMAPMOD() uses
      the default drive.

   $RETURNS$
      NNETMAPMOD returns a numeric value that contains the mapping mode for
      <cDrive>.

   $DESCRIPTION$
      NOVELL NET MAP MODE
      NNETMAPMOD() allows you to determine the mapping mode for a specified
      drive.  For example, you can determine if a drive is allocated to a
      network directory, if the mapping is temporary or permanent, or if a
      local drive is "masked".  For valid return values, see the following
      table:

      Table 22.1:  NNETMAPMOD() return values
      <table>
          Value   Hex  Bin         Definition

          0       0    00000000    Drive unknown
          1       1    00000001    Drive mapped permanently
          2       2    00000010    Drive mapped temporarily
          128     8    010000000   Local drive
          129     8    110000001   Drive mapped permanently, initially local drive
          130     8    210000010   Drive mapped temporarily, initially local drive
         </table>

   $EXAMPLES$
      ■  Determine the mapping mode for drive Y:

         ? NNETMAPMOD('Y')                  // Returns: 0

        Drive Y: is currently unavailable.

      ■  Determine the mapping mode for drive J:

         ? NNETMAPMOD('J')                  // Returns: 1

        Drive J: has been mapped permanently.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMAP(), NNETMAPINF(), NNETSEARCH()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETNXTFRE()
   $ONELINER$
      Returns the next available drive designator
   $SYNTAX$
      NNETNXTFRE([<lRevers>]) --> cDrive

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <lRevers> Designates whether the search is performed in ascending
      order, starting from drive designator "A", or in descending order,
      starting from drive designator "Z".  The default value (.F.) designates
      that the search is performed in ascending order.

   $RETURNS$
      NNETNXTFRE() returns the designator of the determined drive.  If no
      further drive designator is available, the function returns an empty
      string ("").

   $DESCRIPTION$
      NOVELL NET NEXT FREE
      NNETNXTFRE() is used mainly in conjunction with the function NNETMAP().
      NNETNEXTFRE() allows you to determine the next available drive
      designator before a drive mapping.  For example, you can avoid deleting
      existing mappings.

   $EXAMPLES$
      ■  Determine the next available drive designator, starting from
         "A":

         ? NNETNXTFRE()                  // Returns:  K

      ■  Determine the next available drive designator, starting from
         "Z":

         ? NNETNXTFRE(.T.)               // Returns:  Y
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMAP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSEARCH()
   $ONELINER$
      Determines the index of a search drive in the path variable
   $SYNTAX$
      NNETSEARCH([<cDrive>]) --> nSearchDrive

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDrive>  Designates the drive (A to Z) for which the index in the
      path variable is determined.  Without this parameter, the function uses
      the default drive.

   $RETURNS$
      NNETSEARCH() returns a numeric value that indicates the position of
      <cDrive> in the form "<cDrive>:.", in the path variable.  The return
      value is between 0 and 16.  If <cDrive> is not a search drive, the
      function returns 0.

   $DESCRIPTION$
      NOVELL NET SEARCH
      NNETSEARCH() determines if the specified drive is a search drive and
      returns the drive's position in the path environment variable.
      NNETSEARCH() assumes that the path variable contains search drives in
      the form "X:.", where "X" can be any drive designator from "A" to "Z".
      If <cDrive> is not a search drive, NNETSEARCH() returns 0.

   $EXAMPLES$
      Determine the search drive position for drive Z:

      ? NNETSEARCH('Z')                     // Returns: 13
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMAP(), NNETMAPINF(), NNETMAPMOD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Volumes, Directories, ...
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      This chapter combines functions that deal with server volumes and files
      on server volumes.  The NNETVOLXXX() functions return information about
      server volumes.  The functions, NNETDIRS() and NNETFILES(), allow you to
      determine extended directory information (analogous to the Novell
      utility NDIR).  The chapter also includes functions used to query and
      set rights, extended file attributes, and functions that can perform the
      tasks of the Novell utilities PURGE and SALVAGE.  The operation of the
      functions NNETPURGE() and NNETSALVAG() depends on the Netware version.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCOPY()
   $ONELINER$
      Copies files within a Novell file server
   $SYNTAX$
      NNETCOPY(<cSourceFile>,<cTargetFile>,[<nBytes>])
         --> nCopiedBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cSourceFile>  Designates the name of the file that is copied.  This
      parameter can contain the drive and path designation but must be
      resident on a network drive.

      <cTargetFile>  Designates  the name of the target file that is
      created.  This parameter can contain the drive and path designation but
      must be resident on a network drive.

      <nBytes>  Designates the number of bytes that are copied.  The
      default value designates the entire file.

   $RETURNS$
      NNETCOPY() returns the number of bytes copied.  If a copy did not occur,
      the function returns -1.

   $DESCRIPTION$
      NOVELL NET COPY
      This function was planned specifically for copying files within a Novell
      file server.  The copy speed is very high because the file content is
      copied within the server and is not transmitted over the network.  In
      this way the function corresponds to the Novell NCOPY utility program.

   $NOTES$
      ■  If the size of the file that is copied is already known,
         (through FileSeek()/FileSize()), you should pass that size as the
         third parameter.  The function then does not have to determine the
         size of the source file and the copy speed is quicker.

      ■  Notice that the source and target file must be resident on
         network drives on the same file server.  You cannot copy to or from
         hard disks or floppies, or copy between different servers.
         FileCopy() must be used for all other file copying.

      ■  Distinctions can be made based on the source of the error
         through ERRORCODE() (source file not found; target file cannot be
         created) or through NNETERROR() (different file servers).

   $EXAMPLES$
      ■  Drive J: is mapped on a Novell server.  Copy a file, giving
         the source and target path:

         NNETCOPY("J:\SUPPORT\TEST.EXE", "J:\USER\TEST2.EXE")

      ■  FileCopy() is a simple method of copying a file every time.
         If you cannot copy with NNETCOPY(), use FileCopy():

         IF FILE(cFileName)
            IF NNETCOPY(cFileName, cTargetFile) = -1
               FileCopy(cFileName, cTargetFile)
            ENDIF
            IF ERRORCODE(.T.) = 0
               ? "File copied successfully!"
            ENDIF
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETERROR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDIRFRE()
   $ONELINER$
      Determines the number of free directory entries in a volume
   $SYNTAX$
      NNETDIRFRE(<nVolume>) --> nFreeDirectoryEntries

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nVolume>  Designates the selected volume number of the related
      default file server.  This value can be from 0 to 31.

   $RETURNS$
      NNETDIRFRE() returns the number of directory entries still free on the
      volume specified in <nVolume>.

   $DESCRIPTION$
      NOVELL NET DIRECTORY FREE
      This function allows you to determine how many directory entries are
      still available for each volume on the default file server.  This allows
      you to determine if new files can be created on the related volume.  The
      number of directory entries in the Novell network software installation
      program can be increased if necessary.

   $NOTES$
      ■  This function requires that the station have console
         privileges.

   $EXAMPLES$
      Determine if directory entries are still available for all volumes:

      FOR I = 0 TO NNETVOLNUM()
         ? NNETDIRFRE(I)         // Avail. entries, each volume
      NEXT I
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETVOLNUM(), NNETVOLNAM(), NNETVOLMAX()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDIRMAX()
   $ONELINER$
      Determines the maximum number of directory entries in a volume
   $SYNTAX$
      NNETDIRMAX(<nVolume>) --> nMaxEntries

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nVolume>  Designates the selected volume number of the related
      default file server.  This value can be from 0 to 31.

   $RETURNS$
      NNETDIRMAX() returns the total number of available directory entries on
      the volume specified in <nVolume>.

   $DESCRIPTION$
      NOVELL NET DIRECTORY MAXIMUM
      This function allows you to determine the maximum number of directory
      entries for each volume on the default file server.

   $NOTES$
      ■  This function requires that the station have console
         privileges at least.

   $EXAMPLES$
      Determine the total number of directory entries available for all
      volumes:

      FOR I = 0 TO NNETVOLNUM()
         ? NNETDIRMAX(I)         // Max. entries per volume
      NEXT I
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETVOLNUM(), NNETVOLNAM(), NNETVOLMAX()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDIRS()
   $ONELINER$
      Determines the extended information about subdirectories
   $SYNTAX$
      NNETDIRS([<cPath>],[<nAttr>|<cAttr>],[<l386>]) --> aDir

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPath>  Designates the directory for which the subdirectories are
      read.  The parameter contains a search mask for the directories that are
      read.  Within the search mask, the wildcard characters "?" and "*" can
      be used.  A file identifier is not permitted.  The search mask is
      ignored if the function is called on a Netware 2.x server, but this
      parameter must be passed.

      <nAttr>  Designates the file attributes in numeric form, according
      to the table in the description .  The default value is 16.

      <cAttr> Designates the file attributes in the form of a character
      string, according to the table in the description.  The default value is
      "D".

      <l386> Designates whether NNETDIRS() also returns extended
      information that is only available on Netware 3.x servers.  The
      parameter must be designated .T..  The default value ( .F.) does not
      return extended information.

   $RETURNS$
      NNETDIRS() returns an array with subarrays (two-dimensional array).
      Each subarray contains information about each directory entry that is
      found.  The structure of the subarrays is described in the following
      table.

      Table 23.1:  NNETDIRS() Subarray Structure
      <table>
          Position  Metasymbol CTNNET.CH    Definition

          1         cName      ND_NAME      Directory name
          2         dCrDate    ND_CREADATE  Creation date
          3         cCrTime    ND_CREATIME  Creation time
          4         nRights    ND_RIGHTS    Maximum (2.x) / Inherited (3.x) Rights
          5         cOwner     ND_OWNER     Owner
         </table>

      If <l386> has been designated .T., the returned array contains the
      following extension:

      Table 23.2:  Extended NNETDIRS() Subarray Structure
      <table>
          Position     Metasymbol     CTNNET.CH      Definition

          6            cUpdDate       ND_UPDDATE     Date of last update
          7            dUpdTime       ND_UPDTIME     Time of last update
          8            cArcDate       ND_ARCDATE     Date of last  archive
          9            nArcTime       ND_ARCTIME     Time of last archive
          10           cArchive       ND_ACHIVER     Name of archivist
         </table>

   $DESCRIPTION$
      NOVELL NET DIRECTORIES
      NNETDIRS() returns extended information about the subdirectories of file
      server directories.  On Netware 3.x servers, the subdirectories can be
      determined by a search mask in <cPath>.  You can also determine the
      default file attribute.  The attribute can be passed in the form of a
      numeric value or a character string:

      Table 23.3:  File Attribute Coding for NNETDIRS()
      <table>
          Value   Symbol    Definition

          1       R         Read Only
          2       H         Hidden directories
          4       S         System directories
          16      D         Subdirectories (always set by  NNETDIRS())
          32      A         Archive bit set
         </table>

      To specify an attribute, numeric values must be added or the related
      symbols must be added to a character string.

      A call of NNETDIRS() for a Netware 2.x file server also requires a
      search mask in <cPath>; however, the mask is ignored.  Under Netware
      2.x, the function returns all subdirectories that correspond to the
      passed attributes.

   $EXAMPLES$
      ■  Read the subdirectories of L:\, and display the directory
         names:

         #include "ctnnet.ch"

         aDirs=NNETDIRS('L:\*')

         FOR i=1 TO Len(aDirs)
            ? aDirs[i,ND_NAME]
         NEXT i

      ■  Read the subdirectories of NANGERTOOLS1/VOL1:DATA, including
         the hidden system directories:

         aDirs=NNETDIRS('NANGERTOOLS1/VOL1:DATA/*','SH')

      ■  Read the subdirectories of L:\ with extended 3.x information.
         Display the directory name and the date of the last update:

         #include "ctnnet.ch"

         aDirs=NNETDIRS('L:\*',,.T.)

         FOR i=1 TO Len(aDirs)
            ? aDirs[i,ND_NAME],aDirs[i,ND_UPDDATE])
         NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETFILES()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDSKUSE()
   $ONELINER$
      Determines the server disk capacity occupied by a user
   $SYNTAX$
      NNETDSKUSE([<cUser>],[<nVol>|<cVol>],[<cServer>|
         <nConId>])   --> nKByte

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user whose disk capacity is
      determined.  The default value designates the logged in user.

      <nVol>  Designates the volume number.  Under Novell, volume numbers
      start with 0.  This parameter is only important if the specified file
      server runs under Netware 3.x.

      <cVol>  Designates the volume name.  A server name is not allowed.
      This parameter is only important if the specified file server runs under
      Netware 3.x.

      <cServer>  Designates the name of the file server where the used
      disk capacity is determined.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDSKUSE() returns the disk capacity in kByte on the specified file
      server or volume occupied by <cUser>.

   $DESCRIPTION$
      NOVELL NET DISK SPACE IN USE
      NNETDSKUSE() allows you to determine the disk capacity on a file server
      occupied by a user.  Under Netware 2.x and Netware 3.x, the function
      returns the total of the used disk capacity over all volumes on the
      specified file server when it is called without the parameter
      <nVol>|<cVol>.  Under  Netware 3.x, it is possible to determine the
      capacity for a specific volume by passing the volume number <nVol> or
      the volume name <cVol>.  With the parameters <cServer> or <nConId>, the
      occupied capacity on any attached file server can be determined.  The
      connection ID of a server is returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      Determine the total occupied disk capacity for user MIKE under Netware
      3.x for all volumes.  Also determine the total occupied disk capacity
      for user MIKE for any Netware version:

      IF NNETVER()>'2'
      FOR i = 0 TO NNETVOLNUM()
      ? NNETVOLNAM(i),NNETDSKUSE('MIKE',i)
      NEXT i
      ? '======================'
      ENDIF
      ? 'Total: ',NNETDSKUSE('MIKE')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETUSRFRE(), NNETVOLNAM(), NNETVOLNUM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETEXTATT()
   $ONELINER$
      Sets or queries extended file attributes
   $SYNTAX$
      NNETEXTATT(<cFile>,[<nAttr>]) --> nNewAttr

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cFile>  Designates the file for which the extended file attributes
      are set or queried.  <cFile> can contain a path specification.

      <nAttr>  Designates an optional parameter that must be passed to set
      the new extended file attributes of <cFile> .  The value for <nAttr> can
      be calculated according to the table in the description.

   $RETURNS$
      NNETEXTATT() returns a numeric value that contains the extended file
      attributes of <cFile>.  These numeric values correspond to the table in
      the description.  If an error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET EXTENDED ATTRIBUTES
      Besides the DOS file attributes, Netware supports additional extended
      file attributes.  NNETEXTATT() allows you to set or query these
      attributes.  The coding of the extended file attributes can be seen in
      the following table:

      Table 23.4:  Coding of Extended File Attributes
      <table>
          Bit     Value     CTNNET.CH    Definition

          5       16        EXA_TTS      Transaction attribute
          6       32        EXA_INDEX    Index attribute
          7       64        EXA_READAU   Read audit attribute
          8       128       EXA_WRITAU   Write audit attribute
         </table>

      To specify more attributes, the numeric values must be added.

   $NOTES$
      ■  Currently, read and write audit attributes (protocol of read
         and write access) are not supported by Netware.

   $EXAMPLES$
      ■  Check to see if the transaction attribute is set for
         CLIENT.DBF:

         IF IsBit(NNETEXTATT('CLIENT.DBF'),5)
            ? 'CLIENT.DBF is flagged transactional!'
         ELSE
            ? 'TTS not possible for CLIENT.DBF!'
         ENDIF

      ■  Set the transaction attribute for CLIENT.DBF:

         #include "ctnnet.ch"

         NNETEXTATT('CLIENT.DBF',EXA_TTS)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETTTSBEG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETFILES()
   $ONELINER$
      Determines the extended information about subdirectories
   $SYNTAX$
      NNETFILES([<cPath>],[<nAttr>|<cAttr>],[<l386>])
         --> aFiles

   $ARGUMENTS$
      <cPath>  Designates the directory for which the subdirectories are
      read.  The parameter contains a search mask for the directories that are
      read.  Within the search mask, the wildcard characters "?" and "*" can
      be used.

      <nAttr>  Designates the file attributes in numeric form, according
      to the following table.  The default (0) designates  normal files.

      <cAttr>  Designates the file attributes in form of a character
      string, according to the following table .  The default value ("")
      designates  normal files.

      <l386> Designates whether NNETFILES() also returns extended
      information that is only available on Netware 3.x servers.  The
      parameter must be designated .T..  The default value (.F.) does not
      return extended information.

   $RETURNS$
      NNETFILES() returns an array with subarrays (two-dimensional array).
      Each subarray contains information about each directory entry that is
      found.  The structure of the subarrays are described in the following
      table.

      Table 23.5:  NNETFILES() Subarray Structure
      <table>
          Position     Metasymbol     CTNNET.CH      Definition

          1            cName          NF_NAME        Directory name
          2            nSize          NF_SIZE        File size
          3            cUpdDate       NF_UPDDATE     Date of last update
          4            cUpdTime       NF_UPDTIME     Time of last update
          5            dCrDate        NF_CREADATE    Creation date
          6            nAttr          NF_ATTR        File attributes
          7            nExtAttr       NF_EXTATTR     Extended file attributes
          8            cOwner         NF_OWNER       Owner
         </table>

      If <l386> has been designated .T., the returned array contains the
      following extension:

      Table 23.6:  Extended NNETFILES() Subarray Structure
      <table>
          Position     Metasymbol     CTNNET.CH      Definition

          9            cArcDate       NF_ARCDATE     Date of last archive
          10           nArcTime       NF_ARCTIME     Time of last archive
          11           cArchiver      NF_ARCHIVER    Name of archivist
         </table>

   $DESCRIPTION$
      NOVELL NET FILES
      NNETFILES() returns extended information about files on file servers.
      The files can be specified by a search mask in <cPath> and by
      determining the file attribute.  The attribute can be passed in the form
      of a numeric value or a character string:

      Table 23.7:  Coding of File Attributes for NNETFILES()
      <table>
          Value   Symbol    Definition

          1       R         Read Only
          2       H         Hidden directories
          4       S         System directories
          32      A         Archive bit set
         </table>

      To specify an attribute, numeric values must be added or the related
      symbols must be added to a character string.

   $EXAMPLES$
      ■  Read the files in L:\, and display the file names:

         #include "ctnnet.ch"

         aFiles=NNETFILES('L:\*.*')

         FOR i=1 TO Len(aFiles)
            ? aFiles[i,NF_NAME]
         NEXT i

      ■  Read the files in NANGERTOOLS1/VOL1:DATA, including the hidden
         files and the system files:

         aFiles=NNETFILES('NANGERTOOLS1/VOL1:DATA/*.*','SH')

      ■  Read the files in L:\ with extended 3.x information, and
         display he file names and the date of the last archive:

         #include "ctnnet.ch"

         aFiles=NNETFILES('L:\*.*',,.T.)

         FOR i=1 TO Len(aFiles)
            ? aFiles[i,NF_NAME],aFiles[i,NF_ARCDATE])

         NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETDIRS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMAXRGH()
   $ONELINER$
      Sets or queries the maximum and inherited rights for a directory
   $SYNTAX$
      NNETMAXRGH([<cPath>],[<nRights>|<cRights>]) --> nRights

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPath>  Designates a directory or a file (only Netware 3.x) of
      which the maximum (Netware 2.x) or the inherited (Netware 3.x) rights
      are set or queried.  If no value is passed for <cPath>, the maximum or
      inherited rights for the current directory are determined.

      <cRights>  Designates a character string that contains the rights
      for the new directory in form of symbols (maximum rights under Netware
      2.x, inherited rights under Netware 3.x).  If no value is passed for
      <cRights> or <nRights>, the rights for <cPath> are not modified.

      <nRights>  Designates a numeric value that contains a bit mask for
      the determination of the rights for the new directory (maximum rights
      under Netware 2.x, inherited rights under Netware 3.x).  If no value is
      passed for <cRights> or <nRights>, the rights for  <cPath> are not
      modified.

   $RETURNS$
      NNETMAXRGH() returns the maximum rights (Netware 2.x) or the inherited
      rights (Netware 3.x) for <cPath>.

   $DESCRIPTION$
      NOVELL NET MAXIMUM RIGHTS
      Under Netware 2.x, NNETMAXRGH() allows you to set or query the maximum
      rights for a directory.  The maximum rights are the rights a user can be
      granted for a directory.  The maximum rights cannot be exceeded even if
      additional trustee rights are defined for a user.  To query the rights,
      do not pass a value for <cRights>|<nRights>.

      Rights can be set by passing a character string whereby each character
      indicates an attribute (<cRights>), or by passing a numeric value that
      results from a bitwise OR operation of the binary significance  of the
      attributes (nRights).  The maximum rights are coded as follows:

      Table 23.8:  Rights Coding under Netware 2.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write files
          3       OPEN           Open files
          4       CREATE         Create new files
          5       DELETE         Delete files
          6       PARENTAL       Create new directories
          7       SEARCH         Search files in directories
          8       MODIFY         Modify files or attributes
         </table>

      The symbols for <cRights> correspond to the first letter of each keyword
      under "Definition" in the above table.  Individual rights of the return
      value can be checked with IsBit().

      Under Netware 3.x, NNETMAXRGH() allows you to set or query the inherited
      rights for a directory as well as for individual files.  The inherited
      rights determine which trustee rights a directory or a file inherits
      from a parent directory, as long as a user has not been explicitly
      granted trustee rights for the directory or file.

      Under Netware 3.x, the rights are coded as follows:

      Table 23.9:  Rights Coding under Netware 3.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write to files
          3       RESERVED
          4       CREATE         Create new files
          5       ERASE          Delete files
          6       ACCESS CONTROL Trustee rights can be modified
          7       FILE SCAN      Search files in directories
          8       MODIFY         Modify files or attributes
          9       SUPERVISORY    All rights / can grant rights
         </table>

      The first letter of each keyword under "Definition" represents the
      symbol for <cRights>.

   $NOTES$
      ■  For detailed information about rights and security, see the
         Novell documentation.

   $EXAMPLES$
      ■  Query the rights for the directory L:DATA:

         nRights=NNETMAXRGH('L:DATA')
         IF NNETVER('L:')<'3'
            ? 'Maximum rights:',nRights
         ELSE
            ? 'Inherited rights:',nRights
         ENDIF

      ■  Set the rights for the directory VOL1:DATA/APRIL:

         IF NNETVER()<'3'
            NNETMAXRGH('VOL1:DATA/APRIL','RWOCDPSM')
         ELSE
            NNETMAXRGH('VOL1:DATA/APRIL','RWCEFM')
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMKDIR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMKDIR()
   $ONELINER$
      Creates a directory on a volume
   $SYNTAX$
      NNETMKDIR(<cPath>,<cRights>|<nRights>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPath>  Designates a directory on a server volume.  The path can
      contain a server name.

      <cRights>  Designates a character string that contains the rights
      for the new directory in form of symbols ( maximum rights under Netware
      2.x, inherited rights under Netware 3.x).

      <nRights>  Designates a numeric value that contains a bit map to
      determine the rights for the new directory ( maximum rights under
      Netware 2.x, inherited rights under Netware 3.x).

   $RETURNS$
      NNETMKDIR() returns .T. if the new directory has been created
      successfully.

   $DESCRIPTION$
      NOVELL NET MAKE DIRECTORY
      NNETMKDIR() allows you to create a new directory on any server volume.
      The volume must not be mapped to a drive.  <cPath> is the path
      designation for the new directory.  With the parameters <cRights> or
      <nRights>, rights can be assigned for the new directory.  The rights can
      be passed as a string where each character represents an attribute, or
      as a numeric value that results from a bit wise OR operation of the
      binary significance of the attributes.

      The possible rights are interpreted differently under Novell 2.x and
      3.x.

      The following table contains the rights under Netware 2.x:

      Table 23.10:  Rights Coding under Netware 2.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write to files
          3       OPEN           Open files
          4       CREATE         Create new files
          5       DELETE         Delete files
          6       PARENTAL       Create new directories
          7       SEARCH         Search files in directories
          8       MODIFY         Modify files or attributes
         </table>

      The first letter of each keyword under "Definition" represents the
      symbol for <cRights>.  Under Novell 2.x, the rights necessary to create
      a directory are the maximum rights a user can get for a directory.  Even
      if additional trustee rights are granted to a user, the maximum rights
      cannot be overwritten.

      The following table contains the possible rights under Netware 3.x:

      Table 23.11:  Rights Coding under Netware 3.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write to files
          3       RESERVED
          4       CREATE         Create new files
          5       ERASE          Delete files
          6       ACCESS CONTROL Trustee rights can be modified
          7       FILE SCAN      Search files in directories
          8       MODIFY         Modify files or attributes
          9       SUPERVISORY    All rights / can grant rights
         </table>

      The first letter of each keyword under "Definition" represents the
      symbol for <cRights>.  Under Novell 3.x, the rights that are granted
      when a user creates the directory specify which trustee rights are
      inherited from the parent directory, as long as the user has not been
      granted trustee rights for the directory.

   $NOTES$
      ■  For detailed information about rights and security, see the
         Novell documentation.

   $EXAMPLES$
      Create the directory VOL1:DATA/APRIL on the default server:

      IF NNETVER()<'3'
      NNETMKDIR('VOL1:DATA/APRIL','RWOCDPSM')
      ELSE
      NNETMKDIR('VOL1:DATA/APRIL','RWCEFM')
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETRENDIR(), NNETRMDIR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPURGE()
   $ONELINER$
      Removes the files that are marked for deletion from the server
   $SYNTAX$
      NNETPURGE(<cFile>,[<lAll>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cFile>  Designates the file that is deleted, but depends on the
      Netware version that is used.

      Under Netware 3.x, <cFile> designates the file that is deleted.  The
      file name can contain a path, but the path must be unique.  Wildcard
      characters are not allowed.

      Under Netware 2.x, the operating system permits a definite purging of
      files only for the entire file server.  If NNETPURGE() determines that
      the server is running under Netware 2.x after a server change is implied
      by <cFile>, the file specification in <cFile> is no longer taken into
      account.  All the files on the related server that are marked for
      deletion are purged.

      <lAll>  Designates the files that are deleted.  <lAll> is only taken
      into account if the function is called on a Netware 2.x server.  If the
      parameter is designated .F., all the marked files of the current user
      are deleted.  If the parameter is designated .T., all the files of the
      related file server that are marked for deletion are deleted.  The
      default value is .F..

   $RETURNS$
      NNETPURGE() returns .T. if the function has been completed successfully.

   $DESCRIPTION$
      NOVELL NET PURGE
      NNETPURGE() allows you to physically delete all the files that are
      marked for deletion on a server disk.  (These files can no longer be
      restored with the Novell utility SALVAGE).  The function is supported
      differently by Netware 2.x and 3.x.  Under Netware 3.x, files can be
      purged individually.  Under Netware 2.x, all the files of the current
      user (<lAll>=.F.) or all the files that are marked for deletion
      (<lAll>=.T.) are removed.  Console operator rights are required to purge
      all the files that are marked for deletion.  You should query the
      Netware version with NNETVER() before calling NNETPURGE() to avoid a
      purging of all files marked for deletion.

   $NOTES$
      ■  For compatibility reasons the previous version of the
         NNETPURGE() function is still supported (NNETPURGE() -->
         lSuccessful).  A call in this form is only valid for Netware 2.x
         servers.  With console operator rights, NNETPURGE() purges of all of
         the files that are marked for deletion.

   $EXAMPLES$
      ■  Delete and purge the file CONFID.DBF:

         NNETMAP('L','FSERVER386/SYS:DATA')

         ERASE L:CONFID.DBF

         IF NNETVER('FSERVER386') > '2'
            NNETPURGE('L:CONFID.DBF')
         ENDIF

      ■  Purge all the files that are marked for deletion for the
         current user on FSERVER286 (2.x server):

         NNETPURGE('FSERVER286/SYS:')

         The definition of the volume SYS: is necessary to identify FSERVER286
         as server name.  If FSERVER286 contains more volumes, all the volumes
         are purged.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSALVAG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETRENDIR()
   $ONELINER$
      Renames a directory on a volume
   $SYNTAX$
      NNETRENDIR(<cPath>,<cNewDir>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPath>  Designates an existing directory on a server volume.  The
      path can contain a server name.

      <cNewDir>  Designates the new name for the directory specified by
      <cPath>.  This character string can contain a maximum of an eight-
      character name, a period, and a three-character extension.

   $RETURNS$
      NNETRENDIR() returns .T. if the directory has been renamed successfully.

   $DESCRIPTION$
      NOVELL NET RENAME DIRECTORY
      NNETRENDIR() allows you to rename an existing directory (<cPath>) on any
      server volume.  The volume must not be mapped to a drive.  Under Netware
      2.x, the rights MODIFY and PARANTEL are required to rename a directory.
      Under Netware 3.x, the right MODIFY for the parent directory of <cPath>
      is required to rename a directory.

   $NOTES$
      ■  The default directories on volume SYS: (LOGIN, PUBLIC, MAIL,
         SYSTEM) cannot be renamed.

   $EXAMPLES$
      Rename the directory ACCOUNT/VOL1:DATEN/ACT to
      ACCOUNT/VOL1:DATEN/BACKUP:

      IF NNETRENDIR('ACCOUNT/VOL1:DATEN/ACT','BACKUP')
      ? 'Directory has been renamed successfully!'
      ELSE
      ? 'Failure during rename!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMKDIR(), NNETRMDIR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETRGHMSK()
   $ONELINER$
      Returns the rights mask, dependent on the Netware version
   $SYNTAX$
      NNETRGHMSK([<cServer>|<nConId>]) --> cRightsMask

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server for which the
      rights mask is determined.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETRGHMSK() returns a string that contains the rights symbols in a
      descending order of their bit significance.

   $DESCRIPTION$
      NOVELL NET RIGHTS MASK
      The possible rights and their definitions are interpreted differently
      under Novell 2.x and 3.x.  NNETRGHMSK() returns a character string that
      contains the symbols of the rights, dependent on the Netware version.
      The possible rights can be seen in the following tables.  The first
      letter of each keyword under "Definition" represents the symbol used by
      NNETRGHMSK().

      The following table contains the rights under Netware 2.x:

      Table 23.12:  Rights Coding under Netware 2.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write to files
          3       OPEN           Open files
          4       CREATE         Create new files
          5       DELETE         Delete files
          6       PARENTAL       Create new directories
          7       SEARCH         Search files in directories
          8       MODIFY         Modify files or attributes
         </table>

      The following table contains the possible rights under Netware 3.x:

      Table 23.13:  Rights Coding under Netware 3.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write to files
          3       RESERVED
          4       CREATE         Create new files
          5       ERASE          Delete files
          6       ACCESS CONTROL Trustee rights can be modified
          7       FILE SCAN      Search files in directories
          8       MODIFY         Modify files or attributes
          9       SUPERVISORY    All rights / can grant rights
         </table>

      The return value of NNETRGHMSK() can be used in the function BitToC().

   $NOTES$
      ■  NNETRGHTMSK() returns a constant that depends on the Netware
         version on the file server used.  The function does not return
         information about the access rights of the currently logged in user.

   $EXAMPLES$
      In the following example, file server TEST286 runs under Netware 2.15
      and file server WORK386 runs under Netware 3.11:

      ? NNETRGHMSK('TEST286')   // Returns: MSPDCOWR
      ? NNETRGHMSK('WORK386')   // Returns: SMFAEC WR
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETRIGHTS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETRIGHTS()
   $ONELINER$
      Tests for access rights to a Novell file server directory
   $SYNTAX$
      NNETRIGHTS(<cPath>) --> nBitMap

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPath>  Designates the complete path, including the drive
      designation for the directory that is tested.

   $RETURNS$
      NNETRIGHTS() returns a value between 0 and 255 that corresponds to a bit
      map for the related directory rights.  A right is present when the
      designated bit is set at 1.

      Table 23.14:  Access Right Coding
      <table>
          Bit     Definition     Description

          1       READ           Read from files
          2       WRITE          Write to files
          3       OPEN           Open files
          4       CREATE         Create new files
          5       DELETE         Delete files
          6       PARENTAL       Create subdirectories
          7       SEARCH         Search for files in directories
          8       MODIFY         Change file names or attributes
         </table>

      Beginning with NETWARE386 version 3.0, the numeric range for the access
      rights coding has been extended from 1 bit up to 9 bits.  Additionally,
      the meaning of the individual bits has been changed according to the
      following table.

      Table 23.15:  Access Right Coding
      <table>
          Bit     Definition     Description

          1       READ           Read from files
          2       WRITE          Write to files
          3       RESERVED
          4       CREATE         Create new files
          5       ERASE          Delete files
          6       ACCESS CONTROL Trustee rights can be changed
          7       FILE SCAN      Search for files in directories
          8       MODIFY         Change file names or attributes
          9       SUPERVISORY    All rights / can assign access rights
         </table>

      With an invalid parameter, the function returns 0 (which equates to no
      rights).

   $DESCRIPTION$
      This function determines the access rights to a directory of a Novell
      file server.  The parameter must always relate the complete path to the
      root directory and must include the drive designation.  The construction
      of this type of absolute path can be done with the aid of functions like
      DirName(), DiskName(), and TrueName().

      You can determine if a Novell network is active and if a drive is
      resident on a file server with the NetDisk() and NNetwork() functions.

   $NOTES$
      ■  This function always returns a value of 511 for a local drive
         and displays full rights to the designated directory.

   $EXAMPLES$
      ■  Display the rights to the CA-Clipper directory on drive J:

         ? NNETRIGHTS("J:\CLIPPER")                // Returns numeric
                                                   // value

      ■  Test for a particular right:

         ? IsBit(NNETRIGHTS("J:\CLIPPER"), 6)      // Allowed to create
                                                   // a directory

      ■  Display the rights in the current directory:

         ? NNETRIGHTS(DiskName() + ":" + DirName())

      ■  Rights depend on the version:

         cDrive := "J:"
         IF NNETVER(cDrive) < "3.00"
            ? BitToC(NNETRIGHTS(cDrive+"\CLIPPER"), "MSPDCOWR", .T.)
         ELSE
            ? BitToC(NNETRIGHTS(cDrive+"\CLIPPER"), "SMFAEC WR", .T.)
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NetDisk(), NNetwork()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETRMDIR()
   $ONELINER$
      Removes a directory from a volume
   $SYNTAX$
      NNETRMDIR(<cPath>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPath>  Designates an existing directory on a server volume.  The
      path can contain a server name.

   $RETURNS$
      NNETRMDIR() returns .T. if the directory has been removed successfully.

   $DESCRIPTION$
      NOVELL NET REMOVE DIRECTORY
      NNETRMDIR() allows you to remove an existing directory (<cPath>) from a
      server volume.  The volume must not be mapped to a drive.  Under Netware
      2.x, the rights DELETE and PARANTEL are required to remove a directory.
      Under Netware 3.x, the right ERASE for the parent directory of <cPath>
      is required to remove a directory.  A directory can be removed only if
      it is empty and it is not currently mapped on another workstation.

   $NOTES$
      ■  The default directories on volume SYS: (LOGIN, PUBLIC, MAIL,
         SYSTEM) cannot be removed.

   $EXAMPLES$
      Remove the directory VOL1:DATEN from file server ACCOUNT:

      IF NNETRMDIR('ACCOUNT/VOL1:DATEN')
      ? 'Directory has been removed successfully!'
      ELSE
      ? 'Directory could not be removed!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMKDIR(), NNETRENDIR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSALLST()
   $ONELINER$
      Determines the list of recoverable files (Netware 3.x only)
   $SYNTAX$
      NNETSALLST([<cPath>]) --> aFiles

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPath>  Designates the directory on a server volume in which the
      recoverable files are searched.  The default value designates the
      current directory on the current drive.

   $RETURNS$
      NNETPSQL() returns an array with subarray (two-dimensional array).  Each
      subarray contains information about a recoverable file.  For the
      subarray structure, see the following table:

      Table 23.16:  NNETSALLST() Subarray Structure
      <table>
          Position     Metasymbol     CTNNET.CH      Definition

          1            cName          SAL_NAME       File name
          2            cSize          SAL_SIZE       File size
          3            dDate          SAL_DATE       Salvage date
          4            cTime          SAL_TIME       Salvage time
          5            cDeletor       SAL_DELETOR    Deletor
         </table>

      If an error occurs, the function returns an empty array.

   $DESCRIPTION$
      NOVELL NET SALVAGE LIST
      Files on a server volume that are deleted within DOS or within an
      application are logically marked for deletion and can be recovered with
      the Novell utility SALVAGE or the CA-Clipper Tools function
      NNETSALVAG().  NNETSALLST() returns a list of all files in the directory
      <cPath> that can be recovered.  This service is only available under
      Netware 3.x.

   $EXAMPLES$
      ■  Determine the list of recoverable files in L:\DATA.  Display
         the name of the files and the name of the user that deleted these
         files:

         #include "ctnnet.ch"

         aFiles=NNETSALLST('L:\DATA')

         FOR i=1 TO Len(aFiles)
            ? aFiles[i,SAL_NAME],aFiles[i,SAL_DELETOR]
         NEXT i

      ■  Purge all recoverable files in L:\DATA:

         #include "ctnnet.ch"

         aFiles=NNETSALLST('L:\DATA')

         FOR i=1 TO Len(aFiles)
            NNETPURGE('L:\DATA\'+aFiles[i,SAL_NAME])
         NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSALVAG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSALVAG()
   $ONELINER$
      Recovers the files marked for deletion
   $SYNTAX$
      NNETSALVAG(<cOldFile>,[<cNewFile>]) --> cFile

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cOldFile>  Designates the file that is marked for deletion, but
      depends on the Netware version used.

      Under Netware 3.x, <cFile> designates the file that is  recovered.  The
      file name can contain a path, but the path must be unique.  Wildcard
      characters are not allowed.

      Under Netware 2.x, the operating system only permits files to be
      salvaged sequentially for the entire volume.  If NNETSALVAG() determines
      that the server is running under Netware 2.x after a server change is
      implied by <cOldFile>, only the volume definition from the remaining
      part of <cOldFile> is taken into account.  The first recoverable file is
      salvaged.

      <cNewFile>  Designates the name under which <cOldFile> is recovered.
      This parameter is only taken into account if the function is called on a
      Netware 3.x server.  <cNewFile> can only contain a file name (an eight-
      character name, and a three-character extension).

   $RETURNS$
      NNETSALVAG() returns the name of the file that is recovered.  If an
      error occurs, the function returns an empty string.

   $DESCRIPTION$
      NOVELL NET SALVAGE
      Files on a server volume that are deleted within DOS or within an
      application are logically marked for deletion.   These files can be
      recovered with the function NNETSALVAG().  The function is supported
      differently under Netware 2.x and 3.x.  Under Netware 3.x, files can be
      salvaged individually.  Under Netware 2.x, only the first recoverable
      file of the current user on the related volume is salvaged.  Files
      cannot be recovered individually under Netware 2.x.

   $EXAMPLES$
      ■  Salvage the file CLIENT.DBF on a Netware 3.x server:

         NNETMAP('L','FSERVER386/SYS:DATA')

         NNETSALVAG('L:CLIENT.DBF')

      ■  Salvage all recoverable files in the directory L:\DATA:

         #include "ctnnet.ch"

         aFiles=NNETSALLST('L:\DATA')

         FOR i=1 TO Len(aFiles)
            NNETSALVAG('L:\DATA\'+aFiles[i,SAL_NAME])
         NEXT i

      ■  Salvage all the files of the current user on volume SYS: of a
         Netware 2.x server:

         WHILE .T.
            IF Empty(cFile:=NNETSALVAG('FSERVER286/SYS:'))
               EXIT
            ENDIF
            ? cFile
         ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPURGE(), NNETSALLST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETTRSLST()
   $ONELINER$
      Determines the trustee directories and files
   $SYNTAX$
      NNETTRSLST(<cName>,[<nType>],[<cServer>|<nConId>]
         --> aTrusteeDir

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the bindery object for which the
      trustee directories and files are determined.  In most cases, <cName>
      represents the login name of a user.

      <nType>  Designates the object type of <cName>.  The default value
      designates the object type, user.

      <cServer>  Designates the name of the file server on which the
      trustee directories and files are determined.  Your workstation must be
      attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETTRSLST() returns a two-dimensional array.

      The number of lines of the array corresponds to the number of trustee
      directories and files of <cName> on the related file server.  Each line
      (subarray) contains a complete path name (including the volume name) and
      the rights of <cName> in this directory.

   $DESCRIPTION$
      NOVELL NET TRUSTEES LIST
      Under Netware, the access rights for each user can be assigned on the
      directory level.  Under Netware 3.x, the access rights for each user can
      be assigned on the file level.  These rights are called trustee rights.
      NNETTRSLST() allows you to determine all trustee assignments for a
      bindery object.  However, supervisor rights on the related file server
      are required.

      NNETTRSLST() returns a two-dimensional array that contains each trustee
      assignment as a separate line (subarray).  Each subarray consists of two
      elements: a complete pathname that specifies the directory or the file
      for which the trustee rights have been granted, and a numeric value that
      represents the rights that have been granted to <cName> for the
      directory.

      The interpretation of the numeric value depends on the Netware version
      used.  Table 23.17 and 23.18 show the definition of the bits.  A right
      is granted if the corresponding bit is represented in the return value.

      Table 23.17:  Rights Coding under Netware 2.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write files
          3       OPEN           Open files
          4       CREATE         Create new files
          5       DELETE         Delete files
          6       PARENTAL       Create new directories
          7       SEARCH         Search files in directories
          8       MODIFY         Modify files or attributes
         </table>

      Table 23.18:  Rights Coding under Netware 3.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write to files
          3       RESERVED
          4       CREATE         Create new files
          5       ERASE          Delete files
          6       ACCESS CONTROL Trustee rights can be modified
          7       FILE SCAN      Search files in directories
          8       MODIFY         Modify files or attributes
          9       SUPERVISORY    All rights / can grant rights
         </table>

   $NOTES$
      ■  For detailed information about rights and security, see the
         Novell documentation.

   $EXAMPLES$
      Determine and display the trustee directories and files for user MIKE.
      Granted rights are represented by the first letter of their definition:

      aTrust=NNETTRSLST('MIKE')
      FOR i = 1 TO Len(aTrust)
      ? PadR(aTrust[i,1],64),BitToC(aTrust[i,2],NNETRGHMSK(),.T.)
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETTRUST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETTRUST()
   $ONELINER$
      Grants or removes trustee rights
   $SYNTAX$
      NNETTRUST(<cName>,[<nType>],<cPath>,[<cRights>|
         <nRights>]    --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the bindery object for which the
      trustee rights are granted or removed.  In most cases, <cName>
      represents the login name of a user.

      <nType>  Designates the object type of <cName>.  The default value
      designates the object type, user.

      <cPath>  Designates a path designation that specifies a directory or
      a file for which the trustee rights are granted.  The path can be passed
      in the Novell notation or in the DOS notation if the directory or file
      has been mapped to a drive.

      <cRights>  Designates a character string that contains the symbols
      for the rights that are granted to <cName> on <cPath>.

      <nRights>  Designates a numeric value that contains a bit mask for
      the rights that are granted to <cName> on <cPath>.

   $RETURNS$
      NNETTRUST() returns .T. if the rights have been granted or removed
      successfully.

   $DESCRIPTION$
      NOVELL NET TRUSTEE
      Under Netware, the access rights for each user can be assigned on the
      directory level.  Under Netware 3.x, the access rights for each user can
      be assigned on the file level.  These rights are called trustee rights.
      NNETTRUST() allows you to grant or remove trustee rights within a
      CA-Clipper application  However, supervisor rights are required.

      <cPath> specifies the directory or the file for which the trustee rights
      are granted or removed.  To set trustee rights, a value must be passed
      for <cRights> or <nRights>.  <cRights> must contain a character string
      in which each character represents an attribute.  <nRights> must be
      passed as numeric value resulting from a bitwise OR operation of the
      binary significance of the attributes.

      The possible rights under Netware 2.x and Netware 3.x are shown in the
      following tables:

      Table 23.19:  Rights Coding under Netware 2.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write files
          3       OPEN           Open files
          4       CREATE         Create new files
          5       DELETE         Delete files
          6       PARENTAL       Create new directories
          7       SEARCH         Search files in directories
          8       MODIFY         Modify files or attributes
         </table>

      Table 23.20:  Rights Coding under Netware 3.x
      <table>
          Bit     Definition     Description

          1       READ           Read files
          2       WRITE          Write to files
          3       RESERVED
          4       CREATE         Create new files
          5       ERASE          Delete files
          6       ACCESS CONTROL Trustee rights can be modified
          7       FILE SCAN      Search files in directories
          8       MODIFY         Modify files or attributes
          9       SUPERVISORY    All rights / can grant rights
         </table>

      The first letter of the definition represents the symbol for <cRights>.

      To remove trustee rights, do not pass a value for the parameters
      <cRights>|<nRights>.

   $NOTES$
      ■  For detailed information about rights and security, see the
         Novell documentation.

   $EXAMPLES$
      ■  Grant read and write access and the rights to create, delete,
         search, and modify files and directories for user MIKE on directory
         VOL1:DATEN/APRIL on the default server.  The following example
         differentiates between Netware 2.x and 3.x:

         IF NNETVER()<'3'
         lOk=NNETTRUST('MIKE',,'VOL1:DATEN/APRIL','RWOCDPSM')
         ELSE
         lOk=NNETTRUST('MIKE',,'VOL1:DATEN/APRIL','RWCEFM')
         ENDIF
         IF lOk
          ? 'Trustee rights set successfully'
         ELSE
          ? 'Rights could not be set, supervisor rights required!'
         ENDIF

      ■  Remove the trustee rights for user MIKE in directory
         VOL1:DATEN/APRIL:

         IF NNETTRUST('MIKE',,'VOL1:DATEN/APRIL')
          ? 'Trustee rights removed successfully'
         ELSE
          ? 'Rights could not be removed, supervisor rights required!'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETTRSLST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETUSRFRE()
   $ONELINER$
      Determines the server disk space still available to a user
   $SYNTAX$
      NNETUSRFRE([<cUser>]) --> nByte

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the object name, which must be of the type,
      user.  The default value designates the logged in user.

   $RETURNS$
      NNETUSRFRE() returns the disk space that an object (user) can still
      occupy on the default server.

   $DESCRIPTION$
      NOVELL NET USER'S FREE SPACE
      Available free disk capacity on the file server can be limited relative
      to an object in newer Novell versions; for example, user JIM can only
      occupy 10 MB.  With NNETUSRFRE(), you can determine how much disk
      capacity an individual user still has available.  If the <cUser>
      parameter is not specified, the function returns the space available for
      the login name.

   $NOTES$
      ■  Console privileges are required in order to determine this
         information for other users; however, the user's own free capacity
         can be determined without additional rights.

      ■  The value returned for free available space does not guarantee
         that it is actually available on the file server hard disk.  This can
         be done using NNETVOLFRE().

   $EXAMPLES$
      ■  Determine your individual disk space still available:

         ? NNETUSRFRE()

      ■  Determine the free capacity for user JIM.  This function
         requires console privileges at least:

         IF NNETCOPRIV()
            ? NNETUSRFRE("JIM")      // e.g. 2000 kB
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETCOPRIV(), NNETSPRVSR(), NNETVOLFRE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETVOLFRE()
   $ONELINER$
      Determines the available capacity of a server volume
   $SYNTAX$
      NNETVOLFRE(<nVolume>) --> nBytesAvailable

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nVolume>  Designates the number of the selected volume on the
      related default file server.  This value can be from 0 to 31.

   $RETURNS$
      NNETVOLFRE() returns the available free memory capacity on the volume
      designated by <nVolume>.

   $DESCRIPTION$
      NOVELL NET VOLUME FREE
      With NNETVOLFRE(), you can determine the amount of free memory capacity
      available for each volume on the default file server.  In this way you
      can determine if memory intensive file operations can be executed
      without difficulty, or if files can be copied onto the server.

   $NOTES$
      ■  This function requires that the station have console
         privileges at least.

   $EXAMPLES$
      Determine the capacity still available for all volumes:

      FOR I = 0 TO NNETVOLNUM()
         ? NNETVOLFRE(I)         // Available capacity
      NEXT I
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETVOLNUM(), NNETVOLNAM(), NNETVOLMAX()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETVOLMAX()
   $ONELINER$
      Determines the maximum capacity of a server volume
   $SYNTAX$
      NNETVOLMAX(<nVolume>) --> nMaxBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nVolume>  Designates the selected volume number of the related
      default file server.  This value can be from 0 to 31.

   $RETURNS$
      NNETVOLMAX() returns the total capacity available on the volume
      designated by <nVolume>.

   $DESCRIPTION$
      NOVELL NET VOLUME MAXIMUM
      Using NNETVOLMAX(), you can determine the total available capacity of
      any volume on the default file server.

   $NOTES$
      ■  This function requires that the station have console
         privileges at least.

   $EXAMPLES$
      Determine the capacities for all volumes:

      FOR I = 0 TO NNETVOLNUM()
         ? NNETVOLMAX(I)         // The related capacity
      NEXT I
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETVOLNUM(), NNETVOLNAM(), NNETVOLFRE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETVOLNAM()
   $ONELINER$
      Determines the name of a server volume
   $SYNTAX$
      NNETVOLNAM(<nVolume>) --> cVolumeName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nVolume>  Designates the number of the selected default file server
      volume.  This value can be from 0 to 31.

   $RETURNS$
      NNETVOLNAM() returns the name of the volume selected using <nVolume> on
      the default file server.

   $DESCRIPTION$
      NOVELL NET VOLUME NAME
      With NNETVOLNAM(), you can determine the name of a volume on the default
      file server.

   $NOTES$
      ■  This function requires that the station have console
         privileges at least.

   $EXAMPLES$
      Determine the names of all volumes:

      FOR I = 0 TO NNETVOLNUM()
         ? NNETVOLNAM(I)         // Displays related names
      NEXT I
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETVOLNUM(), NNETVOLMAX(), NNETVOLFRE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETVOLNUM()
   $ONELINER$
      Determines the maximum number of available server volumes
   $SYNTAX$
      NNETVOLNUM() --> nMaxVol

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETVOLNUM() returns the maximum number of available volumes on the
      default file server.  If an error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET VOLUME NUMBER
      This function returns the maximum number of available volumes for the
      default file server.  This value can be between 0 and NNETVOLNUM().
      With NETVOLNUM() you can determine the name and total free capacity for
      each active volume.  You can also determine all of the available
      directory entries that are possible.

   $NOTES$
      ■  Volumes between 0 and NNETVOLNUM() can be inactive (not
         mounted).

   $EXAMPLES$
      Determine the names of all the volumes.  The function returns a null
      string if a volume is inactive:

      FOR I = 0 TO NNETVOLNUM()
         ? NNETVOLNAM(I)         // Displays related names
      NEXT I
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETVOLNAM(), NNETVOLMAX(), NNETVOLFRE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Broadcast Messages
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      The functions in this chapter provide access to the Netware broadcast
      message system.  With the utility SEND, Netware allows you to send
      messages between workstations.  The NNETSN() functions of CA-Clipper
      Tools make it possible to send messages from within a CA-Clipper
      application.

      Each Netware user knows the problem of getting a message during a
      running application: the application is usually interrupted when a
      message is received.  CA-Clipper Tools provide two possibilities to
      solve this problem: suppressing incoming messages with the NNETBRDCST()
      function (corresponding to the Novell utility CASTOFF) or using the
      CA-Clipper Tools broadcast system.  The broadcast system allows you to
      receive messages in the background and read the messages later from the
      broadcast buffer.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETBRDCST()
   $ONELINER$
      Determines or queries the receiving mode for broadcast messages
   $SYNTAX$
      NNETBRDCST([<nMode>]) --> nPrevMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nMode>  Designates the new mode for receiving broadcast messages.
      Values from 0 to 3 are accepted.

      Table 24.1:  Broadcast Receiving Modes
      <table>
          Value   Sym. Con.      Definition

          0       BRD_RECALL     Receive all messages automatically
          1       BRD_RECSERVER  Receive server messages only, discard other
                                 messages
          2       BRD_STORESERV  Store one server message on the server, discard
                                 other messages
          3       BRD_STOREALL   Store any message on the server
         </table>

   $RETURNS$
      NNETBRDCST() returns a numeric value between 0 and 3.  The value
      represents the broadcast mode at the moment of the call of NNETBRDCST(),
      before a new mode is set (see the argument).  With NNETBRDCST(), you can
      save the previous mode and set a new mode.  A return value of -1
      indicates an error.

   $DESCRIPTION$
      NOVELL NET BROADCAST MODE
      With NNETBRDCST(), you can set the mode for receiving broadcast
      messages.  Broadcast messages can be sent by a file server (system
      messages or the shutdown of a server) or by any workstation within the
      network (user messages set up with the Novell SEND utility or a
      NNETSND()).  When a message is received, the network shell usually
      interrupts the running application, displays the message in line 24 of
      the screen and waits for a user input (<Ctrl> <Enter>).  This behavior
      can be modified by using the function NNETBRDCST().  Four different
      receiving modes are available (see the argument).  Modes 0 and 1 allow
      the interruption of an application; however, mode 1 ignores user
      messages.  Modes 2 and 3 suppress the display of messages on the screen
      during an application.  The file server has a message buffer available
      for each connected workstation.  As soon as the buffer is full,
      additional messages are ignored.  Messages can be read with the function
      NNETGETMSG().

      Alternatively, the broadcast system of CA-Clipper Tools can be activated
      (see NNETMSGOPN()).  This system allows the interrupt controlled
      receiving of broadcast messages in the background.  Messages can be
      processed within an application, and the computer is not interrupted by
      incoming messages.

   $EXAMPLES$
      Suppress incoming messages at program start, and reset to the previous
      mode after the end of the application:

      // Program start
      #include "ctnnet.ch"

      nOldMsg=NNETBRDCST(BRD_STOREALL)
      ....
      // End of program
      NNETBRDCST(nOldMsg)
      RETURN
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETGETMSG(), NNETMSGOPN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETGETMSG()
   $ONELINER$
      Reads the broadcast buffer on a file server
   $SYNTAX$
      NNETGETMSG([<cServer>|<nConId>]) --> cMessage

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server for which the
      message buffer is read.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETGETMSG() returns a character string that contains the broadcast
      message of the specified file server.  If there is no message in the
      broadcast buffer, the function returns a null string.

   $DESCRIPTION$
      NOVELL NET GET BROADCAST MESSAGE
      If the receiving of broadcast messages is suppressed (for example, with
      the Novell utility CASTOFF or the function NNETBRDCST()), the file
      server stores the first message in a buffer.  This buffer can be read
      with NNETBRDCST().  Reading the server buffer causes its deletion.  With
      the parameters <cServer> or <nConId>, the buffer of any attached server
      can be read.  The connection ID of a server is returned by NNETATTACH()
      or NNETLOGIN().

   $EXAMPLES$
      Read the broadcast buffer of the default server, and display the
      message:

      cMsg=NNETGETMSG()
      IF .NOT. Empty(cMsg)
      ? cMsg
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETBRDCST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMSGCLO()
   $ONELINER$
      Reads the message buffer and uninstalls the broadcast system
   $SYNTAX$
      NNETMSGCLO() --> lClosed

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETMSGCLO() returns .T. if an installed broadcast system has been
      uninstalled successfully.

   $DESCRIPTION$
      NOVELL NET MESSAGE BUFFER CLOSE
      A call of NNETMSGCLO() discards all messages in the broadcast buffer and
      uninstalls the broadcast system.  After a call of NNETMSGCLO(), future
      messages are displayed in line 24 of the screen and must be confirmed by
      pressing <Ctrl><Return>.

   $EXAMPLES$
      Read all the messages and close the buffer:

      FOR i = 1 TO NNETMSGCNT()
      ? NNETMSGRD()
      NEXT i
      NNETMSGCLO()
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGOPN(), NNETMSGRD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMSGCLR()
   $ONELINER$
      Clears the broadcast buffer
   $SYNTAX$
      NNETMSGCLR() --> lCleared

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETMSGCLR() returns .T. if the broadcast buffer has been cleared
      successfully.

   $DESCRIPTION$
      NOVELL NET MESSAGE BUFFER CLEAR
      NNETMSGCLR() allows you to delete all the messages from the buffer
      without explicit read access.

   $EXAMPLES$
      Delete the broadcast buffer:

      NNETMSGCLR()
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGOPN(), NNETMSGRD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMSGCNT()
   $ONELINER$
      Determines the number of messages in the broadcast buffer
   $SYNTAX$
      NNETMSGCNT() --> nNumber

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETMSGCNT() returns the number of messages in the broadcast buffer.  If
      the broadcast buffer is empty, the function returns 0.

   $DESCRIPTION$
      NOVELL NET MESSAGE COUNT
      NNETMSGCNT() allows you to determine the number of messages in the
      broadcast buffer.  If the broadcast buffer is empty, or if the broadcast
      system is not installed, the function returns 0.

   $EXAMPLES$
      Read and display all the messages from the broadcast buffer:

      FOR i = 1 TO NNETMSGCNT()
      ? NNETMSGRD()
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGOPN(), NNETMSGRD(), NNETMSGSIZ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMSGKEY()
   $ONELINER$
      Defines the key code for incoming broadcast messages
   $SYNTAX$
      NNETMSGKEY([<nKeyValue>]) --> lActive

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nKeyValue>  Specifies the key code that is placed in the keyboard
      buffer by the broadcast system when a message is received.  All values
      from the CA-Clipper KEYBOARD command are valid.  When called without
      this parameter, the function resets a previously set key code.

   $RETURNS$
      NNETMSGKEY() returns (.T.) if a key code for the broadcast system has
      been set successfully.

   $DESCRIPTION$
      NOVELL NET MESSAGE KEY
      NNETMSGKEY() allows you to react to incoming messages within a wait
      state (READ, WAIT, AChoice() or MemoEdit()).  For example, a refresh can
      be triggered within an input mask, as soon as a defined message arrives.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGOPN(), NNETMSGRD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMSGOPN()
   $ONELINER$
      Initializes the interrupt-controlled broadcast system
   $SYNTAX$
      NNETMSGOPN([<nNumber>]) --> lStatus

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nNumber>  Designates the maximum number of broadcast messages that
      are accepted by the receiving buffer.  Values from 1 to 1000 are
      allowed.  Values outside of this range are corrected automatically.  The
      default value for <nNumber> is 1.

   $RETURNS$
      NNETMSGOPEN() returns .T. if the broadcast system has been initialized
      successfully.  If an error occurs (for example, insufficient fixed heap
      memory to create the buffer), the function returns .F..

   $DESCRIPTION$
      NOVELL NET MESSAGE BUFFER OPEN
      Netware allows you to send broadcast messages between workstations.  For
      example, broadcast messages can be created with the Novell utility SEND
      or with the CA-Clipper Tools function NNETSND().  The broadcast system
      is also used by Netware servers to send system messages.  Incoming
      messages are displayed on line 24 of the screen; these messages block
      the system until they are confirmed with <Ctrl> <Return>.  These
      incoming messages can be suppressed with CASTOFF or with the CA-Clipper
      Tools function NNETBRDCST().  In contrast, NNETMSGOPN(), in conjunction
      with the NNETSND() functions, allows communication between applications.

      NNETMSGOPN() opens a buffer that can accept up to <nNumber> broadcast
      messages and installs an interrupt handler.  After the message system
      has been installed, incoming messages are no longer displayed on the
      screen; these messages are stored in the internal message buffer.  The
      messages can then be read from the buffer in the sequence of their
      arrival with NNETMSGRD().

      The broadcast system can simulate a key code when a message is received.
      If the receiving buffer is full, no additional messages are accepted.
      Do not suppress the receiving of messages when using the broadcast
      system!  Messages are already suppressed on the file server instead of
      the workstation.

   $NOTES$
      Important!  NNETMSGOPN() works with the interrupt system.  Before
      you leave your CA-Clipper application, NNETMSGOPN() must be uninstalled
      with the function NNETMSGCLO().  Changed interrupt vectors can, sooner
      or later, lead to a system crash.  When working with the extended
      drivers module, interrupt vectors are reset automatically.

      ■  It is not possible to use the message system with former
         versions of the Novell shell.  The latest version is available free
         of charge from Novell through CompuServe.

   $EXAMPLES$
      Install the broadcast system with a buffer for up to 10 messages:

      IF NNETMSGOPN(10)
      ? 'Broadcast system installed successfully!'
      ELSE
      ? 'Installation failed!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETBRDCST(), NNETMSGCLO(), NNETMSGKEY(), NNETMSGRD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMSGRD()
   $ONELINER$
      Reads the message from broadcast buffer
   $SYNTAX$
      NNETMSGRD([<lNotDelete>]) --> cMessage

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <lNotDelete>  Designates an optional parameter that allows you to
      read a message from the buffer without changing the contents of the
      buffer.  If <lNotDelete>  is designated .T., the message remains in the
      buffer.  If <lNotDelete> is designated .F., the message is deleted from
      buffer.

   $RETURNS$
      NNETMSGRD() returns a character string that contains the message that
      has been received previously in the background.

   $DESCRIPTION$
      NOVELL NET MESSAGE READ
      NNETMSGRD() allows you to read messages from the broadcast buffer after
      the buffer has been opened with NNETMSGOPN().  NNETMSGRD() always
      returns the oldest message.  If the buffer is empty or if the broadcast
      system is not installed, NNETMSGRD() returns an empty string.

   $EXAMPLES$
      Read a message from the broadcast buffer, and emulate the Novell
      standard behavior:

      #include "inkey.ch"

      IF .NOT. Empty(cMsg:=NNETMSGRD())
      @ 24,0 SAY cMsg
      WHILE Inkey()!=K_CTRL_RETURN
      ENDDO
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGOPN(), NNETMSGCNT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETMSGSIZ()
   $ONELINER$
      Determines the size of the broadcast buffer
   $SYNTAX$
      NNETMSGSIZ() --> nNumber

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETMSGSIZ() returns the number of broadcast messages the broadcast
      buffer can accept.

   $DESCRIPTION$
      NOVELL NET MESSAGE BUFFER SIZE
      NNETMSGSIZ() allows you to determine the size of the broadcast buffer.
      If the broadcast system is not installed, the function returns 0.

   $EXAMPLES$
      Calculate the number of messages that the broadcast buffer can accept:

      ? NNETMSGSIZ()-NNETMSGCNT()
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGCNT(), NNETMSGOPN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSNDALL()
   $ONELINER$
      Sends a message to all users on a file server
   $SYNTAX$
      NNETSNDALL(<cMessage>,[<lNoSender>],
         [<cServer>|<nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cMessage>  Designates the message that is sent to all users.  The
      message can be up to 55 characters long (including information about the
      sender) and can only contain characters that have an ASCII value between
      32 and 127.

      <lNoSender>  Designates an optional parameter that allows you to
      suppress the sender information (from ...) when designated as (.T.).
      When this parameter is designated as .F., the sender information is
      generated automatically.

      <cServer>  Designates the name of the file server through which the
      message is sent.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETSNDALL() returns the number of stations to which the message has
      been sent successfully.  The function returns 0 if no users are logged
      in.

   $DESCRIPTION$
      NOVELL NET SEND GROUP
      NNETSNDGRP() allows you to send a message (<cMessage>) of up to 55
      characters to all users (<cName>) that are currently logged into a file
      server.  The message is sent to all workstations where a user is logged
      in and the message receipt is not disabled (castoff).  The message is
      displayed in line 24 of the screen and must be confirmed with <Ctrl>
      <Return>.

      The message system of CA-Clipper Tools (NNETMSGOPN()) allows the
      interrupt-controlled receipt of messages in the background.  The
      incoming messages can be processed within the application, and the
      computer is not interrupted in critical moments.

      If the parameter <lNoSender> is set to .F. or no parameter is set, the
      message contains information about the sender.  This information
      consists of the word "from", the name of the sender, and the connection
      ID.  By passing <lNoSender> with .T., the sender information can be
      suppressed.  With the parameters <cServer> or <nConId>, the message can
      be sent on any attached file server.  The connection ID of a server is
      returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      Send a message to all users on the default server:

      nNumber= NNETSNDALL('Backup in 5 minutes!')
      ? 'Message has been sent to '+NToC(nNumber)+' station(s)!'
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGOPN(), NNETSNDCON(), NNETSNDGRP(), NNETSNDLOG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSNDCON()
   $ONELINER$
      Sends a message to the server console
   $SYNTAX$
      NNETSNDCON(<cMessage>,[<lNoSender>],
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cMessage>  Designates the message that is sent to the server
      console.  The message can be up to 60 characters long (including
      information about the sender) and can only contain characters that have
      an ASCII value between 32 and 127.

      <lNoSender>  Designates an optional parameter that allows you to
      suppress the sender information (from ...) when designated (.T.).  When
      this parameter is designated .F., the sender information is generated
      automatically.  The default value is .F..

      <cServer>  Designates the name of the file server to which the
      message is sent.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETSNDCON() returns .T. if the message has been sent successfully.  If
      an error occurs, the function returns .F..

   $DESCRIPTION$
      NOVELL NET SEND CONSOLE
      NNETSNDCON() allows you to send a message (<cMessage>) of up to 60
      characters to the console of a file server.  The message is displayed by
      the file server on a connected screen.  If the parameter <lNoSender> is
      set to .F. or if no parameter is set, the message contains information
      about the sender.  The information consists of the word "from", the name
      of the sender, and the connection ID.  By passing <lNoSender> with .T.,
      the sender information can be suppressed.

      With the parameters <cServer> or <nConId>, the message can be sent to
      any attached file server.  The connection ID of a server is returned by
      NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      ■  Send a message to the default server:

         IF NNETSNDCON('Start of the accounting system')
         ? 'Message sent successfully!'
         ELSE
         ? 'Message could not be sent'
         ENDIF

      ■  Send a message to server MAIL under the wrong sender:

         NNETSNDCON('From Mick[99] : Hi, guys!',.T.,'MAIL')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSNDALL(), NNETSNDGRP(), NNETSNDLOG(), NNETSNDUSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSNDGRP()
   $ONELINER$
      Sends a message to all group members
   $SYNTAX$
      NNETSNDGRP(<cName>,<cMessage>,[<lNoSender>],
         [<cServer>|<nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the group that has members to which
      the message is sent.

      <cMessage>  Designates the message that is sent to the members of
      <cName>.  The message can be up to 55 characters long (including
      information about the sender) and can contain only characters that have
      an ASCII value between 32 and 127.

      <lNoSender>  Designates an optional parameter that allows you to
      suppress the sender information (from ...) when designated as (.T.).
      When this parameter is designated .F., the sender information is
      generated automatically.  The default value is .F..

      <cServer>  Designates the name of the file server through which the
      message is sent.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETSNDGRP() returns the number of workstations to which the message
      <cMessage> was successfully sent.  The function returns 0 if no member
      of <cName> is currently logged in or ready to receive messages..

   $DESCRIPTION$
      NOVELL NET SEND GROUP
      NNETSNDGRP() allows you to send a message of up to 55 characters to all
      the users of a group.  The function can be compared with the Novell
      utility SEND.  The group <cName> must exist either on the default server
      or on the server specified by <cServer>|<nConId> because the sending of
      messages is processed through a file server.  The message is sent to all
      workstations on which a member of <cName> is logged in and the message
      receipt is not disabled (castoff).  The message is displayed on line 24
      of the screen and must be confirmed with <Ctrl><Return>.  The message
      system of CA-Clipper Tools (NNETMSGOPN()) allows the interrupt
      controlled receipt of messages in the background.  The incoming messages
      can be processed within the application and the computer is not
      interrupted in critical moments.

      If the parameter <lNoSender> is set to .F. or if no parameter is set,
      the message contains information about the sender.   This information
      consists of the word "from", the name of the sender, and the connection
      ID.  By passing <lNoSender> with .T., the sender inforation can be
      suppressed.  With the parameters <cServer> or <nConId>, the message can
      be sent on any attached file server.  The connection ID of a server is
      returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      Send a message to all members of the group TOOLS:

      nNumber= NNETSNDGRP('TOOLS','Data backup in 5 minutes!')
      ? 'Message has been sent to '+NToC(nNumber)+' stations!'
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGOPN(), NNETSNDALL(), NNETSNDCON(), NNETSNDLOG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSNDLOG()
   $ONELINER$
      Sends a message to the log file of a file server
   $SYNTAX$
      NNETSNDLOG(<cMessage>,[<lNoSender>],
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cMessage>  Designates the message that is written to the log file.
      The message can be up to 80 characters long (including information about
      the sender) and can contain only characters that have an ASCII value
      between 32 and 127.

      <lNoSender>  Designates an optional parameter that allows you to
      suppress the sender information (from ...) when designated as .T..  When
      this parameter is designated .F., the sender information is generated
      automatically.  The default value is . F..

      <cServer>  Designates the name of the file server for which the log
      file is  used.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETSNDLOG() returns .T. if the message has been sent successfully.  If
      an error occurs, the function returns .F..

   $DESCRIPTION$
      NOVELL NET SEND LOG
      Under Netware 2.1x, each file server maintains a log file.  This file is
      in the directory SYS:SYSTEM under the name NET$LOG.MSG.  NNETSNDLOG()
      allows you to send a message of up to 80 characters to the log file.
      The message is saved in the form:

      month/day/year hours:minutes STN <lAttach>: <cMessage>

      If the parameter <lNoSender> is set to .F. or if no parameter is set,
      the message contains the sender information.  This information consist
      of the word "from", the name of the sender, and the connection ID.  By
      passing <lNoSender> with .T., the sender information can be suppressed.
      With the parameters <cServer> or <nConId>, the message can be sent to
      the log file of any attached file server.  The connection ID of a server
      is returned by NNETATTACH() or NNETLOGIN().

   $NOTES$
      ■  Under Netware 3.x, NNETSNDLOG() returns .F. because file
         servers do not maintain a log file.

   $EXAMPLES$
      Write an application start in the log file of the default server:

      IF NNETSNDLOG('Start of the accounting system')
      ? 'Message has been sent successfully!'
      ELSE
      ? 'Message could not be sent!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSNDALL(), NNETSNDCON(), NNETSNDGRP(), NNETSNDUSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSNDUSR()
   $ONELINER$
      Sends a message to a user
   $SYNTAX$
      NNETSNDUSR(<cName>,<cMessage>,[<lNoSender>],
         [<cServer>|<nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the login name of the user to whom the message
      is sent.

      <cMessage>  Designates the message that is sent to <cName>.  The
      message can be up to 55 characters long (including information about the
      sender) and can contain only characters that have an ASCII value between
      32 and 127.

      <lNoSender>  Designates an optional parameter that allows you to
      suppress the sender information (from ...) when designated as .T..  When
      the parameter is designated .F., the sender information is generated
      automatically.

      <cServer>  Designates the name of the file server through which the
      message is sent.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETSNDUSR() returns the number of workstations to which the message
      <cMessage> has been sent successfully.  The function returns 0 if
      <cName> is not logged in or not ready to receive messages.

   $DESCRIPTION$
      NOVELL NET SEND USER
      NNETSNDUSR() allows you to send a message of up to 55 characters to a
      user.  The function can be compared to the Novell utility SEND.  The
      user <cName> must be logged in either on the default server or on the
      server specified by <cServer>|<nConId> because the sending of messages
      is processed through a file server.  The message is sent to all
      workstations on which <cName> is logged in and the message receipt is
      not disabled (castoff).  The message is displayed in line 24 of the
      screen and must be confirmed with <Ctrl> <Return>.  The message system
      of CA-Clipper Tools ( NNETMSGOPN()) allows the interrupt-controlled
      receipt of messages in the background.  The incoming messages can be
      processed within the application, and the computer is not interrupted in
      critical moments.

      If the parameter <lNoSender> is set to .F. or if no parameter is set,
      the message contains the information about the sender.  This information
      consists of the word "from", the name of the sender, and the connection
      ID.  By passing <lNoSender> with .T., the sender information can be
      suppressed.  With the parameters <cServer> or <nConId>, the message can
      be sent on any attached file server.  The connection ID of a server is
      returned by NNETATTACH() or NNETLOGIN().

   $EXAMPLES$
      ■  Send a message to user MIKE:

         nNumber= NNETSNDUSR('MIKE','Good morning')
         ? 'Message has been sent to '+NToC(nNumber)+' stations!'

      ■  Send a message to the supervisor without the sender
         information:

         NNETSNDCON('SUPERVISOR','You fool!',.T.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETMSGOPN(), NNETSNDALL(), NNETSNDCON(), NNETSNDGRP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Print Queue Management
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      The functions in this chapter cover the entire area of print queue
      control under Netware.  Print queues can be created or deleted.  Users,
      operators, and print servers for a print queue can be defined or
      removed.  The queue functions allow you to manipulate jobs within a
      queue.  All settings for a print job can be queried or modified if the
      job is not currently processed (provided that you have sufficient access
      rights).  Jobs can be deleted or moved within a queue.

      Important!  Within the Netware documentation the term "job" is used
      to describe a print job within a queue and also to describe a set of
      capture parameters (print job definition).  Within this chapter the term
      "job" only describes a print job.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETADDQOP()
   $ONELINER$
      Adds operators to a print queue
   $SYNTAX$
      NNETADDQOP(<cQueue>,<cUser>|<aUser>,[<cServer>|
         <nConId>) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates a print queue on the default server or on
      <cServer>|<nConId>.

      <cUser>  Designates the name of a user that is added as an operator
      of <cQueue>.

      <aUser>  Designates a number of elements of the type string.  Each
      element contains the name of a user that is added as an operator of
      <cQueue>.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETADDQOP() returns the number of users that have been added
      successfully as operators of <cQueue>.  A value of 0 indicates that no
      operator has been added.

   $DESCRIPTION$
      NOVELL NET ADD QUEUE OPERATOR
      NNETADDQOP() allows you to add one or more users as operators of a print
      queue.  To add one user, the login name of the user must be passed in
      <cUser>.  To add more users, an array containing all user names can be
      passed in <aUser>.  With the parameters <cServer> or <nConId>, the
      operation can be performed on any attached server.  The connection ID of
      a server can be determined with NNETATTACH() or NNETLOGIN().

      Supervisor rights are required on the related file server to add a user
      as a queue operator.

   $NOTES$
      ■  NNETADDQOP() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Add user MICK as an operator of the queue LINEPRINTER:

         IF NNETADDQOP('LINEPRINTER','MICK')>0
            ? 'User added successfully!'
         ELSE
            ? 'Error!'
         ENDIF

      ■  Add users PETER, MIKE, and JIM as operators of the queue
         LINEPRINTER:

         NNETADDQOP('LINEPRINTER',{'PETER','MIKE','JIM'})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETREMQOP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETADDQSV()
   $ONELINER$
      Adds a print server
   $SYNTAX$
      NNETADDQSV(<cQueue>,<cPServer>|<aPServer>,[<cServer>|
         <nConId>) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates a print queue on the default server or on
      <cServer>|<nConId>.

      <cPServer>  Designates the name of a print server that is added as
      the server for <cQueue>.

      <aPServer>  Designates a number of elements of the type string.
      Each element contains the name of a print server that is added as the
      server for <cQueue>.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETADDQSV() returns the number of print servers that have been added
      successfully as servers of <cQueue>.  A value of 0 indicates that no
      server has been added.

   $DESCRIPTION$
      NOVELL NET ADD QUEUE SERVER
      NNETADDQSV() allows you to add one or more print servers as servers of a
      print queue.  To add one server, the name of the server must be passed
      in <cPServer>.  To add more servers, an array containing all print
      server names can be passed in <aPServer>.  With the parameters <cServer>
      or <nConId>, the operation can be performed on any attached server.  The
      connection ID of a server can be determined with NNETATTACH() or
      NNETLOGIN().

      Supervisor rights are required on the related file server to add a print
      server as the server for a queue.

   $NOTES$
      ■  NNETADDQSV() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Add the print server PSERVERTOOLS1 as the server for the queue
         LINEPRINTER:

         IF NNETADDQSV('LINEPRINTER','PSERVERTOOLS1')>0
         ? 'Print server added successfully!'
         ELSE
         ? 'Error!'
         ENDIF

      ■  Add the print servers PSERVERTOOLS1 and PSERVERDEV1 as servers
         for the queue LINEPRINTER:

         NNETADDQSV('LINEPRINTER',{'PSERVERTOOLS1','PSERVERDEV1'})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETREMQSV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETADDQUS()
   $ONELINER$
      Adds a queue user
   $SYNTAX$
      NNETADDQUS(<cQueue>,<cUser>|<aUser>,[<cServer>|
         <nConId>) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates a print queue on the default server or on
      <cServer>|<nConId>.

      <cUser>  Designates the name of a user that is added as a user of
      <cQueue>.

      <aUser>  Designates a number of elements of the type string.  Each
      element contains the name of a user that is added as a user of <cQueue>.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates  the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETADDQUS() returns the number of users that have been added
      successfully as users of <cQueue>.  A value of 0 indicates that no user
      has been added.

   $DESCRIPTION$
      NOVELL NET ADD QUEUE USER
      NNETADDQUS() allows you to add one or more users as users of a print
      queue.  To add one user, the login name of the user must be passed in
      <cUser>.  To add more users, an array containing all user names can be
      passed in <aUser>.  With the parameters <cServer> or <nConId>, the
      operation can be performed on any attached server.  The connection ID of
      a server can be determined with NNETATTACH() or NNETLOGIN().

      Supervisor rights are required on the related file server to add a user
      as a queue operator.

   $NOTES$
      ■  NNETADDQUS() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Add user MICK as a user of the queue LINEPRINTER:

         IF NNETADDQUS('LINEPRINTER','MICK')>0
            ? 'User added successfully!'
         ELSE
            ? 'Error!'
         ENDIF

      ■  Add users PETER, MIKE, and JIM as users of the queue
         LINEPRINTER:

         NNETADDQUS('LINEPRINTER',{'PETER','MIKE','JIM'})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETREMQUS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCAPJOB()
   $ONELINER$
      Determines the job number of the most recently opened capture job
   $SYNTAX$
      NNETCAPJOB([<nPrinterNo>]) --> nJob

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPrinterNo>  Designates the LPT device for which the job number is
      determined.  LPT1 (1) to LPT3 (3) are possible.  The default value is 1.

   $RETURNS$
      NNETCAPJOB() returns the job number of the last opened capture job for
      <nPrinterNo>.  If an error occurs, the function returns 0.

   $DESCRIPTION$
      NOVELL NET CAPTURE JOB
      To maintain the jobs within a queue, Netware internally uses job
      numbers.  The job number is a 16-bit integer.  This number has nothing
      to do with the logical position of a job within a queue; for example,
      the first job within a queue is not automatically job number 1.  The job
      number is assigned to a print job by the Queue Management Services (QMS)
      and cannot be foreseen.  It is only used to identify a job
      unambiguously.

      After a job has been created, the job number determined with
      NNETCAPJOB() can be used to access and manipulate specific jobs with the
      NNETJXXX() functions.  However, the start of a capture process with
      NNETCAPBEG() does not immediately create a job.  Therefore, a call of
      the function NNETCAPJOB() immediately after a call of NNETCAPBEG()
      returns the number of a job that was called earlier.  A new job is not
      created before the first output via the LPT device.  After the first
      output you can determine the number of the current job using
      NNETCAPJOB().

   $EXAMPLES$
      ■  Determine the job number of the last opened capture job on
         LPT2:

         ? NNETCAPJOB(2)

      ■  Start the capture mode for LPT1, send output to the queue
         LINEPRINTER, and set the job description to "! CONFIDENTIAL !":

         NNETCAPSSF(1)
         NNETCAPBEG(1)
         NNETSETQ(1,'LINEPRINTER')
         SET PRINTER ON
         ? 'Hello'   // A new job is created!
         NNETJDESC('LINEPRINTER',NNETCAPJOB(1),'! CONFIDENTIAL !')
         NNETCAPFLU(1)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJDESC(), NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETCRTQ()
   $ONELINER$
      Creates a new print queue
   $SYNTAX$
      NNETCRTQ(<cQueue>,[<cQueuePath>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the queue that is created.

      <cQueuePath>  Designates the directory where the new queue is
      created.

   $RETURNS$
      NNETCRTQ() returns .T. if the new queue (<cQueue>) has been created
      successfully.  If an error occurs, the Novell error code can be queried
      with the NNETERROR() function.

   $DESCRIPTION$
      NOVELL NET CREATE QUEUE

      NNETCRTQ() allows you to create a new print queue on a file server.  In
      addition to the name of the queue (<cQueue>), you can specify the
      directory (<cQueuePath>) where the new queue is created.  If no
      directory is passed, the queue directory is established in the
      SYS:SYSTEM directory of the default server.  Supervisor rights are
      required to create a new print queue.

   $EXAMPLES$
      ■  Create the queue LINEPRINTER on the default server:

         IF NNETCRTQ('LINEPRINTER')
         ? 'Queue created successfully!'
         ELSE
         ? 'Queue could not be created!'
         ENDIF

      ■  Create the queue LINEPRINTER on the file server DEV:

         NNETCRTQ('LINEPRINTER','DEV/SYS:SYSTEM')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDQUS(), NNETDELQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDELQ()
   $ONELINER$
      Deletes a print queue
   $SYNTAX$
      NNETDELQ(<cQueue>,[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is deleted.

      <cServer>  Designates the name of the file server where <cQueue> is
      established.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDELQ() returns .T. if the queue (<cQueue>) has been deleted
      successfully.  If an error occurs, the Novell error code can be queried
      with the NNETERROR() function.

   $DESCRIPTION$
      NOVELL NET DELETE QUEUE
      NNETDELQ() allows you to delete an entire queue.  After a queue has been
      deleted with NNETDELQ(), all jobs of <cQueue> are canceled, all job
      files are deleted, and all queue directories are removed.  Supervisor
      rights are required to delete a queue.

   $EXAMPLES$
      Delete the queue LINEPRINTER on the default server:

      IF NNETDELQ('LINEPRINTER')
      ? 'Queue has been deleted successfully!'
      ELSE
      ? 'Queue could not be deleted!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCRTQ(), NNETJDEL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJBAN()
   $ONELINER$
      Determines if a banner page is printed for a job
   $SYNTAX$
      NNETJBAN(<cQueue>,<nJob>,[<lNewTitle>],[<cServer>|
         <nConId>]) --> lTitle

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <lNewTitle>  Designates whether a banner page for <nJob> is printed
      (.T.) or not (.F.).

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJBAN() returns .T. if a banner page is printed.

   $DESCRIPTION$
      NOVELL NET JOB BANNER PAGE
      Under Netware, a banner page can be printed before each print job to
      show the user name.  However, if a banner page is not necessary, it can
      be suppressed by passing the parameter <lNewTitle> with .F..

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Determine if a banner page is printed for the first job in the
         queue LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJBAN('LINEPRINTER', nJob)

      ■  Suppress the banner page for the first job in the queue
         LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJBAN('LINEPRINTER', nJob, .F.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJBFILE(), NNETPJBAN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJBFILE()
   $ONELINER$
      Sets or determines the file names in the banner text of a job
   $SYNTAX$
      NNETJBFILE(<cQueue>,<nJob>,[<cNewName>],[<cServer>|
         <nConId>]) --> cName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cNewName>  Designates a new file name that is set for the banner
      text.  The file name can be up to 12 characters long.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJBFILE() returns the file name that is printed on the banner page of
      <nJob>.

   $DESCRIPTION$
      NOVELL NET JOB BANNER FILE
      The banner page of a job contains the user name of the job owner and the
      name of the printed file.  NNETJBFILE() allows you to set or to
      determine the file name.  The default name is LST:.

   $EXAMPLES$
      ■  Determine the file name to be printed on the banner page of
         the first job in the queue LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJBFILE('LINEPRINTER', nJob)

      ■  Set the file name to be printed on the banner page of the
         first job in the queue LINEPRINTER to STONES.TXT:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJBFILE('LINEPRINTER', nJob, 'STONES.TXT')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJBAN(), NNETJBNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJBNAME()
   $ONELINER$
      Sets or determines the banner name for a job
   $SYNTAX$
      NNETJBNAME(<cQueue>,<nJob>,[<cNewName>],[<cServer>|
         <nConId>]) --> cName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cNewName>  Designates a new banner name that is set for <nJob>.
      The banner name can be up to 12 characters long.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJBNAME() returns the user name that is printed on the banner page of
      <nJob>.

   $DESCRIPTION$
      NOVELL NET JOB BANNER NAME

      The banner page of a job contains the user name of the job owner and the
      name of the printed file.  NNETJBNAME() allows you to set or to
      determine the user name.

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Determine the user name that is printed on the banner page of
         the first job in the queue LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJBNAME('LINEPRINTER', nJob)

      ■  Set the user name that is printed on the banner page of the
         first job in the queue LINEPRINTER to MICK:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJBNAME('LINEPRINTER', nJob, 'MICK')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJBAN(), NNETJBFILE(), NNETPJBNAM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJCNT()
   $ONELINER$
      Determines the number of jobs in a print queue
   $SYNTAX$
      NNETJCNT(<cQueue>,[<cServer>|<nConId>]) --> nJobs

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJCNT() returns the number of jobs that are currently in a print
      queue.  If an error occurs (for example, non existing print queue), the
      function returns -1.

   $DESCRIPTION$
      NOVELL NET JOB COUNT
      NNETJCNT() allows you to determine when it is safe to modify certain
      characteristics of a queue (for example, the connection to a print
      server).  You should wait until the queue is empty to modify certain
      characteristics of the queue.  NNETJCNT() can be used to count the jobs
      in a number of queues.  With NNETSETQ() you can then assign a job to the
      queue with the lowest number of jobs.

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Determine the number of jobs in the queue LINEPRINTER:

      ? 'Jobs:',NNETJCNT('LINEPRINTER')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJCOPY()
   $ONELINER$
      Sets or determines the number of copies for a job
   $SYNTAX$
      NNETJCOPY(<cQueue>,<nJob>,[<nNewCopies>],[<cServer>|
         <nConId>]) --> nCopies

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <nNewCopies>  Designates the new number of copies for <nJob>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJCOPY() returns the number of copies of <nJob> that are printed.  If
      an error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET JOB COPIES
      The queue management allows you to print out more than one copy of a
      print job.  With NNETJCOPY(), you can set or determine the number of
      copies of <nJob>.  To query the number of copies, do not pass a value
      for <nNewCopies>.

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Determine the number of copies for the first job in the queue
         LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJCOPY('LINEPRINTER', nJob)

      ■  Set the number of copies for the first job in the queue
         LINEPRINTER to 5:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJCOPY('LINEPRINTER', nJob, 5)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJCOPY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJCPL()
   $ONELINER$
      Sets or determines the number of characters per line for a job
   $SYNTAX$
      NNETJCPL(<cQueue>,<nJob>,[<nNewChar>],[<cServer>|
         <nConId>]) --> nChar

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cNewChar>  Designates the new number of characters per line for
      <nJob>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJCPL() returns the number of characters per line for  <nJob>.  If an
      error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET CHARACTERS PER LINE
      With NNETJCPL(), you can set or determine the number of characters per
      line for <nJob>.  To query the number of copies, do not pass a value for
      <nNewChar>.  A new number of characters can be set by passing the
      selected number.  The number of characters is simply informative; this
      information is not evaluated by Netware.

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Determine the number of characters for the first job in the
         queue LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJCPL('LINEPRINTER', nJob)

      ■  Set the number of characters for the first job in the queue
         LINEPRINTER to 72:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJCPL('LINEPRINTER', nJob, 72)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJLPP(), NNETJTXT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJDEL()
   $ONELINER$
      Deletes a job from a print queue
   $SYNTAX$
      NNETJDEL(<cQueue>,<nJob>,[<cServer>|<nConId>])
         --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is deleted from
      <cQueue>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJDEL() returns .T. if the job has been deleted successfully.  If an
      error occurs, the function returns .F.  An error can occur if <cQueue>
      does not exist or the requesting user does not have the required access
      rights.

   $DESCRIPTION$
      NOVELL NET JOB DELETE
      NNETJDEL() allows you to delete a job from a queue.  The job that is
      deleted is specified by its job number.  The job number has nothing to
      do with the logical position of a job within a queue.  The job number
      can be determined with NNETCAPJOB() or NNETJLIST().  A job that is
      already in process is canceled immediately by a call of NNETJDEL().

   $NOTES$
      ■  The user of a queue can delete a job only if the user
         submitted it to the queue.  The queue operator can remove any job.

   $EXAMPLES$
      Delete the second job from the queue LINEPRINTER:

      nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),3,2))
      IF NNETJDEL('LINEPRINTER',nJob)
      ? 'Job has been deleted successfully!'
      ELSE
      ? 'Job could not be deleted!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJDESC()
   $ONELINER$
      Reads and modifies the job description
   $SYNTAX$
      NNETJDESC(<cQueue>,<nJob>,[<cDescription>],
         [<cServer>|<nConId>]) --> cDescription

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cDescription>  Designates the new job description for <nJob>.  The
      job description can be up to 49 characters long.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJDESC() returns the job description of <nJob> in <cQueue>.  If an
      error occurs (for example, if <cQueue> does not exist), the function
      returns an empty string.

   $DESCRIPTION$
      NOVELL NET JOB DESCRIPTION
      NNETJDESC() allows you to read or to modify the description of each job
      in a queue.  The description can be up to 49 characters long and is
      printed on the banner page.  By passing the parameter <cDescription>,
      you can overwrite the default description "LPTnCatch".  The operation
      has been successful if the returned character string is identical to the
      parameter <cDescription>.

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue.  The
      job number can be determined with NNETCAPJOB() or NNETJLIST().

   $NOTES$
      ■  The reading of a job description requires that the requesting
         user has access to the queue as a user or an operator.  The right to
         modify a job description is reserved for the user who has created the
         job and for the queue operator.

      ■  A job that is already in progress cannot be modified.

   $EXAMPLES$
      ■  Query the job description for the first job in the queue
         LINEPRINTER:

         nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
         ? NNETJDESC('LINEPRINTER',nJob)

      ■  Start the capture mode for LPT1, send output to the queue
         LINEPRINTER, and set the description of the resulting job to
         "!CONFIDENTIAL!":

         NNETCAPSSF(1)
         NNETCAPBEG(1)
         NNETSETQ(1,'LINEPRINTER')
         SET PRINTER ON
         ? 'Hello'
         NNETJDESC('LINEPRINTER',NNETCAPJOB(1),'!CONFIDENTIAL!')
         NNETCAPFLU(1)

      ■  The new job is always created at the first output (? "Hello"),
         not by calling NNETCAPBEG().  Therefore, NNETJDESC() must be called
         after the first output.  If NNETJDESC() is not called after the first
         output, NNETCAPJOB() returns the number of the previous capture job
         and the wrong description is modified.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJBNAME(), NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJEDATE()
   $ONELINER$
      Determines the entry date of a job
   $SYNTAX$
      NNETJEDATE(<cQueue>,<nJob>,[<cServer>|<nConId>])
         --> dDate

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJEDATE() returns the date when <nJob> was placed in <cQueue>.  If an
      error occurs (for example, if <cQueue> does not exist), the function
      returns an empty date.

   $DESCRIPTION$
      NOVELL NET JOB ENTRY DATE
      The Queue Management System (QMS) provides each new job with a date and
      time stamp.  With NNETJEDATE(), you can determine the entry date of
      <nJob> in <cQueue>.  The required job is specified by its job number.
      The job number has nothing to do with the logical position of a job
      within a queue.  The job number can be determined with NNETCAPJOB() or
      NNETJLIST().

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Determine the entry date of the first job in the queue LINEPRINTER:

      nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
      ? NNETJEDATE('LINEPRINTER',nJob)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJETIME(), NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJETIME()
   $ONELINER$
      Determines the entry time of a job
   $SYNTAX$
      NNETJETIME(<cQueue>,<nJob>,[<cServer>|<nConId>])
         --> cTime

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJETIME() returns the time when <nJob> was placed in <cQueue> as a
      string in the form ("HH:MM:SS").  If an error occurs (for example, if
      <cQueue> does not exist), the function returns an empty string ("  :  :
      ").

   $DESCRIPTION$
      NOVELL NET JOB ENTRY TIME
      The Queue Management System (QMS) provides each new job with a date and
      time stamp.  With NNETJETIME(), you can determine the entry time of
      <nJob> in <cQueue>.  The required job is specified by its job number.
      The job number has nothing to do with the logical position of a job
      within a queue.  The job number can be determined with NNETCAPJOB() or
      NNETJLIST().

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Determine the entry time of the first job in the queue LINEPRINTER:

      nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
      ? NNETJETIME('LINEPRINTER',nJob)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJEDATE(), NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJFILE()
   $ONELINER$
      Determines the name of a job file
   $SYNTAX$
      NNETJFILE(<cQueue>,<nJob>,[<cServer>|<nConId>])
         --> cFile

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJFILE() returns the name of the job file of the job <nJob> in
      <cQueue>.  If an error occurs (for example, if <cQueue> does not exist),
      the function returns an empty string.

   $DESCRIPTION$
      NOVELL NET JOB FILE
      Netware stores the contents of a job in a separate file.  The queue
      itself only contains references to these files.  With NNETJFILE(), you
      can determine the size of the job files.  The required job is specified
      by its job number.   The job number has nothing to do with the logical
      position of a job within a queue.  The job number can be determined with
      NNETCAPJOB() or NNETJLIST().

      NNETJFILE() only returns file names and file identification.  The file
      name is assigned to a job by the Queue Management System (QMS) when the
      job is created and cannot be modified.  The job file directory can be
      determined with NNETQDIR().

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Determine the job file name of the second job in the queue LINEPRINTER:

      nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),3,2))
      ? 'File name:', NNETJFILE('LINEPRINTER',nJob)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJLIST(), NNETJSIZE(), NNETQDIR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJFLAGS()
   $ONELINER$
      Reads and sets the job control flag
   $SYNTAX$
      NNETJFLAGS(<cQueue>,<nJob>,[<nNewFlags>],[<cServer>|
         <nConId>]) --> nFlags

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <nNewFlags>  Designates an optional parameter that contains a bit-
      coded value to change the control flags of <nJob> in <cQueue>.  The
      definition of the bits can be seen in table below.  To set multiple
      bits, the decimal values of the attributes must be added.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJFLAGS() returns a numeric value that contains the job flags.  The
      flags correspond to a bit position within this value.

      Table 25.1:  Coding of Job Control Flags
      <table>
          Bit     Value     Definition

          4       8         Service autostart flag
          5       16        Service restart flag.  When this flag is set, a job
                            that is canceled by a job server remains in the queue.
                            Otherwise, the job is deleted from the queue.
          6       32        Entry open flag.  This bit indicates that a job has not
                            been released by a user and therefore is not ready for
                            servicing.
          7       64        User hold flag.  The job remains in the queue without
                            being serviced until the user or the queue operator
                            clears this flag.
          8       128       Operator hold flag.  The job remains in the queue
                            without being serviced until a queue operator clears
                            this flag.
         </table>

      If an error occurs (for example, if <cQueue> does not exist), the
      function returns -1.

   $DESCRIPTION$
      NOVELL NET JOB FLAGS
      Job control flags can provide important information about <nJob>.  The
      required job is specified by its job number.  The job number has nothing
      to do with the logical position of a job within a queue.  The job number
      can be determined with NNETCAPJOB() or NNETJLIST().

      With NNETJFLAGS() you can determine if a job is ready for processing or
      if the user has not yet closed the job (entry open flag).  You can see
      if a job is in waiting state (user or operator hold flag).  By passing
      <nNewFlags>, one or more flags can be set or deleted.  For example, a
      job can be set into a waiting state with the user hold flag.

   $NOTES$
      ■  The reading of the job control flags requires that the
         requesting user has access to <cQueue> as a user or a queue operator.

      ■  Netware does not prevent a user who has created a job from
         changing the operator hold flag.  Therefore, it does not make sense
         to differentiate between a user and an operator hold flag when using
         NNETJFLAGS().  A difference between these two flags can arise in an
         application specific interpretation, like the one that is implemented
         in the Novell utility PCONSOLE.

      ■  A job that is already in progress cannot be modified.

   $EXAMPLES$
      ■  Check to see if job 1 in the queue LINEPRINTER has already
         been closed by the user::

         nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
         IF IsBit(NNETJFLAGS('LINEPRINTER',nJob),6)
         ? 'Job closed!'
         ELSE
         ? 'Job not ready!'
         ENDIF

      ■  Start the capture mode for LPT1, send output in the queue
         LINEPRINTER, and set the user hold flag:

         NNETCAPSSF(1)
         NNETCAPBEG(1)
         NNETSETQ(1,'LINEPRINTER')
         SET PRINTER ON
         ? 'Hello'
         nJob=NNETCAPJOB(1)
         nOldFlags=NNETJFLAGS('LINEPRINTER',nJob)
         nNewFlags=NumAnd(nOldFlags,64)
         NNETJFLAGS('LINEPRINTER',nJob,nNewFlags)
         NNETCAPFLU(1)

      ■  The new job is always created at the first output (? "Hello"),
         not by calling NNETCAPBEG().  Therefore, NNETJFLAGS() must be called
         after the first output.  If NNETJFLAGS() is not called after the
         first output, NNETCAPJOB() returns the number of the previous capture
         job and the job control flags are modified for the wrong job.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJFORM()
   $ONELINER$
      Sets or determines the form name for a job
   $SYNTAX$
      NNETJFORM(<cQueue>,<nJob>,[<cNewName>],[<cServer>|
         <nConId>]) --> cName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cNewName>  Designates an optional parameter that contains a new
      form name that is set for <nJob>.  The form name can be up to 15
      characters long.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJFORM() returns the name of the form required for <nJob>.

   $DESCRIPTION$
      NOVELL NET JOB FORM
      Before a job is serviced, the print server checks to see if the form
      mounted in the printer matches the form specified in <nJob>.  If the
      form in the printer differs from the specified form, the print server
      waits for a form change.  NNETJFORM() allows you to set or determine the
      form name for <nJob>.  To query the form name, do not pass a value for
      <cNewName>.  A new form can be set with this parameter.  However, the
      function does not check to see if <cNewName> exists.

   $EXAMPLES$
      ■  Determine the form name for the first job in the queue
         LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJFORM('LINEPRINTER', nJob)

      ■  Set the form name for the first job in the queue LINEPRINTER
         to INVOICE:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJFORM('LINEPRINTER', nJob, 'INVOICE')
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJLIST()
   $ONELINER$
      Determines a list of job numbers in a queue
   $SYNTAX$
      NNETJLIST(<cQueue>,[<cServer>|<nConId>]) --> cJobNum

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJLIST() returns a string in form of a byte sequence that contains
      the job numbers of the jobs in <cQueue>.  Two bytes correspond to one
      job number.  If an error occurs (for example, if <cQueue> does not
      exist), the function returns an empty string.

   $DESCRIPTION$
      NOVELL NET JOB LIST
      Netware internally uses job numbers in form of 16-bit integers for the
      administration of jobs within a queue.  The job number has nothing to do
      with the logical position of a job within a queue; for example, the
      first job in a queue is not automatically job number 1.  The job number
      is assigned to a job by the Queue Management System (QMS) when the job
      is placed in the queue.  Job numbers are used only to identify a job
      unambiguously.

      You must know the job number to work with the functions (NNETJXXX()).
      NNETJLIST() returns the job numbers in a queue as a string where two
      bytes contain one job number. With the functions SubStr() and Bin2I(),
      you can extract each job number (see the example).  The sequence of the
      job numbers in the string corresponds to the logical job sequence.  The
      first two bytes represent the job with the highest priority in the
      queue.

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Determine and output the job numbers for the queue LINEPRINTER:

      cJobs=NNETJLIST('LINEPRINTER')
      FOR i= 0 TO Len(cJobs)/2-1
      ? Bin2I(SubStr(cJobs,2*i+1,2))
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJCNT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJLPP()
   $ONELINER$
      Sets or determines the number of lines per page for a job
   $SYNTAX$
      NNETJLPP(<cQueue>,<nJob>,[<nNewLines>],[<cServer>|
         <nConId>]) --> nLines

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cNewLines>  Designates the new number of lines per page that are
      set for <nJob>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJLPP() returns the number of lines per page for <nJob>.  If an error
      occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET LINES PER PAGE
      With NNETJLPP(), you can set or determine the number of lines per page
      for <nJob>.  To query the number of lines, do not pass a value for
      <nNewChar>.  A new number of characters can be set by passing the
      selected number.  The number of lines is simply informative; this
      information is not evaluated by Netware.

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Determine the number of lines per page for the first job in
         the queue LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJLPP('LINEPRINTER', nJob)

      ■  Set the number of lines to 62 per page for the first job in
         the queue LINEPRINTER:

         nJob = Bin2I(Left(NNETJLIST('LINEPRINTER'), 2))
         ? NNETJLPP('LINEPRINTER', nJob, 62)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJCPL(), NNETJTXT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJOWNER()
   $ONELINER$
      Determines the login name of a job owner
   $SYNTAX$
      NNETJOWNER(<cQueue>,<nJob>,[<cServer>|<nConId>])
         --> cUser

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJOWNER() returns the login name of the user who has placed <nJob> in
      <cQueue>.  If an error occurs (for example, if <cQueue> does not exist),
      the function returns an empty string.

   $DESCRIPTION$
      NOVELL NET JOB OWNER
      Internally, the Queue Management System (QMS) saves the login name (the
      object ID) of the user who has created the job.  NNETJOWNER() allows you
      to query this information.  The required job is specified by its job
      number.  The job number has nothing to do with the logical position of a
      job within a queue; for example, the job with the highest priority in a
      queue is not automatically job number 1.  The job number must be
      determined with NNETCAPJOB() or NNETJLIST().

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Determine the creator of the third job in the queue LINEPRINTER:

      nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
      ? NNETJOWNER('LINEPRINTER',nJob)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJPOINT()
   $ONELINER$
      Determines if a job is serviced at an interrupt
   $SYNTAX$
      NNETJPOINT(<cQueue>,<nJob>,[<lNewMode>],[<cServer>|
         <nConId>]) --> lMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <lNewMode>  Designates an optional parameter that specifies if
      <nJob> is serviced by a print server when the job file has not been
      closed correctly.  If the parameter is designated .T., the QMS submits
      <nJob> to a print server.  If the parameter is set to .F., QMS discards
      the <nJob> when the job file has not been closed correctly.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      The return value of NNETJPOINT() indicates whether a job is printed
      (.T.) or discarded (.F.) when the job file has not been closed
      correctly.

   $DESCRIPTION$
      NOVELL NET JOB PRINT ON INTERRUPT
      NNETJPOINT() allows you to determine whether or not a job is printed
      when the job file has not been closed correctly.  To query the current
      setting for <nJob>, do not pass a value for <lNewMode>.

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Determine if the first job in the queue LINEPRINTER is printed
         when the job file has not been closed correctly:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         ? NNETJPOINT('LINEPRINTER', nJob)

      ■  Determine that the first job in the queue LINEPRINTER is
         printed when the job file has not been closed correctly:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         ? NNETJPOINT('LINEPRINTER', nJob, .T.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJFLAGS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJPOS()
   $ONELINER$
      Determines or changes the position of a job in a queue
   $SYNTAX$
      NNETJPOS(<cQueue>,<nJob>,[<nNewPos>],[<cServer>|
         <nConId>]) --> nPos

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <nNewPos>  Designates an optional parameter that contains the new
      position of <nJob> in the logical sequence of <cQueue>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJPOS() returns the new position of <nJob> in the logical sequence of
      <cQueue>.  If an error occurs (for example, if  <cQueue> does not
      exist), the function returns -1.

   $DESCRIPTION$
      NOVELL NET JOB POSITION
      Within a queue, the jobs are organized as a waiting line.  Generally,
      the jobs are put into a queue in the sequence of their creation.  With
      NNETJPOS(), you can determine the position of a job within a queue.  The
      job with position 1 is serviced first.  The required job is specified by
      its job number.  The job number has nothing to do with the logical
      position of a job within a queue; for example, the job with the highest
      priority in a queue is not automatically job number 1.  The job number
      must be determined with NNETCAPJOB() or NNETJLIST().

      NNETJPOS() allows a queue operator to change the position of <nJob> in
      <cQueue> by passing the parameter <nNewPos>.

   $NOTES$
      ■  To determine a job position, the requesting user must have
         access to the queue as a user or a queue operator.  The modification
         of a job position is reserved for queue operators.

   $EXAMPLES$
      ■  Determine the position of the last created capture job via
         LPT1 in the queue LINEPRINTER:

         ? NNETJPOS('LINEPRINTER',NNETCAPJOB(1))

      ■  Change the priority of the job:

         IF NNETJPOS('LINEPRINTER',NNETCAPJOB(1),1)<>1
         ? 'No queue operator rights!'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJLIST()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJSDATE()
   $ONELINER$
      Queries and sets a job start date
   $SYNTAX$
      NNETJSDATE(<cQueue>,<nJob>,[<dNew>],[<cServer>|
         <nConId>]) --> dDate

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <dNew>  Designates a new job start date that is set for <nJob>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJSDATE() returns the earliest date for <nJob> in <cQueue>.  The
      function returns an empty date if the job start date has not been set or
      if an error occurs (for example, if <cQueue> does not exist).

   $DESCRIPTION$
      NOVELL NET JOB START DATE
      The Queue Management System (QMS) allows you to provide each job with a
      retention period.  A job is not serviced before that date (job start
      date).  With NNETJSDATE(), you can query or set the job start date of
      <nJob> in <cQueue>.  The required job is specified by its job number.
      The job number has nothing to do with the logical position of a job
      within a queue; for example, the job with the highest priority in a
      queue is not automatically job number 1.  The job number must be
      determined with NNETCAPJOB() or NNETJLIST().

      NNETJSDATE() returns the job start date.  An empty date indicates that
      no date has been set.  In this case, the job is serviced as soon as a
      print server is available.  ( An empty date can also indicate an error.
      A differentiation is possible with the NNETERROR() function.)

      A new job start date can be set by passing a date with the <dNew>
      parameter.  If <dNew> contains an empty date, a previously set job start
      date is removed.  If you reset a job start date, the job start time is
      removed automatically.

      To avoid an incorrect interpretation by the QMS of a time that has not
      been initialized, always set a job start time with the job start date.

   $NOTES$
      ■  To determine a job start date, the requesting user must have
         access to the queue as a user or an operator.  The modification of a
         job start date is reserved for the user who created the job or for
         queue operators.

      ■  A job that is already in progress cannot be modified.

   $EXAMPLES$
      ■  Query the job start date for the first job in the queue
         LINEPRINTER:

         nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
         ? NNETJSDATE('LINEPRINTER',nJob)

      ■  Create the capture job, set the job start date for the
         following day, and set the job start time for 10 PM:

         NNETCAPSSF(1)
         NNETCAPBEG(1)
         NNETSETQ(1,'LINEPRINTER')
         SET PRINTER ON
         ? 'Hello'
         nJob=NNETCAPJOB(1)
         NNETJSDATE('LINEPRINTER',nJob,Date()+1)
         NNETJSTIME('LINEPRINTER',nJob,'22:00:00')
         NNETCAPFLU(1)

      ■  The new job is always created at the first output (? "Hello"),
         not by calling NNETCAPBEG()  Therefore, NNETJSDATE() must be called
         after the first output.  If NNETJSDATE() is not called after the
         first output, NNETCAPJOB() returns the number the previous capture
         job and the job start date is modified for the wrong job.

      ■  Remove the retention period for the first job in the queue
         LINEPRINTER (date and time):

         nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
         ? NNETJSDATE('LINEPRINTER',nJob,CToD(''))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJLIST(), NNETSTIME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJSIZE()
   $ONELINER$
      Determines the size of a job file
   $SYNTAX$
      NNETJSIZE(<cQueue>,<nJob>,[<cServer>|<nConId>])
         --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJSIZE() returns the size of the job file assigned to <nJob> in
      bytes.  If an error occurs (for example, if <cQueue> does not exist),
      the function returns -1.

   $DESCRIPTION$
      NOVELL NET JOB SIZE
      Netware stores the contents of a job in a separate file.  The queue
      itself only contains references to these files.  With NNETJSIZE(), you
      can determine the size of the job files.  If the job is not completed at
      the function call, NNETJSIZE() returns the temporary size.  The required
      job is specified by its job number.   The job number has nothing to do
      with the logical position of a job within a queue.  The job number can
      be determined with NNETCAPJOB() or NNETJLIST().

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Determine the size of the first job in the queue LINEPRINTER:

      nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
      ? 'Size:', NNETJSIZE('LINEPRINTER',nJob)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJFILE(), NNETJLIST(), NNETQDIR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJSRV()
   $ONELINER$
      Sets or determines the target or the processing print server
   $SYNTAX$
      NNETJSRV(<cQueue>,<nJob>,[<cNewPServer>],[<cServer>|
         <nConId>]) --> cPServer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cNewPServer>  Designates an optional parameter that contains a new
      target print server that is set for <nJob>.  If <nJob> is already in
      service on another print server, this parameter is meaningless.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      If <nJob> is not yet in service, NNETJSRV() returns the name of the new
      target print server.  If an error occurs or if no specific printer is
      set, the function returns an empty string.  With NNETERROR(), you can
      determine if an error occurred.

      If <nJob> is already in service, NNETJSRV() returns the name of the
      processing print server.

   $DESCRIPTION$
      NOVELL NET JOB SERVER
      The Queue Management System (QMS) allows you to set a target server for
      each print job.  If more than one print server has access to <cQueue>,
      you can define a specific print server for <nJob>.  To allow any print
      server to process <nJob>, an empty string must be passed for
      <cNewPServer>.  You can query the current target print server by calling
      NNETJSRV() without a value for <cNewPServer>.

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Query the target or the processing server for the first job in
         the queue LINEPRINTER:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         ? NNETJSRV('LINEPRINTER', nJob)

      ■  Set the target server for the first job in the queue
         LINEPRINTER to PSERVER:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         ? NNETJPOINT('LINEPRINTER', nJob, 'PSERVER')

      ■  Reset the target server for the first job in the queue
         LINEPRINTER:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         ? NNETJSRV('LINEPRINTER', '')

      ■  Wait until the first job in the queue LINEPRINTER is serviced,
         and then display the name of the processing server:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         DO WHILE .NOT. NNETJWORK('LINEPRINTER', nJob)
         ENDDO
         ? NNETJSRV('LINEPRINTER', nJob)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJWORK()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJSTIME()
   $ONELINER$
      Queries or sets the job start time
   $SYNTAX$
      NNETJSTIME(<cQueue>,<nJob>,[<cNew>],[<cServer>|
         <nConId>]) --> cTime

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cNew>  Designates a new job start time for <nJob>.  The time must
      be passed as a string in the form ("HH:MM:SS").

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJSTIME() returns the earliest time for <nJob> in <cQueue> as a
      string in the form ("HH:MM:SS").  The function returns an empty string
      ("  :  :  ") if the job start time has not been set or if an error
      occurs (for example, if <cQueue> does not exist).

   $DESCRIPTION$
      NOVELL NET JOB START DATE
      The Queue Management System (QMS) allows you to provide each job with a
      retention period.  A job is not serviced before the specified time (job
      start time).  With NNETJSTIME(), you can query or set the job start time
      of <nJob> in <cQueue>.  The required job is specified by its job number.
      The job number has nothing to do with the logical position of a job
      within a queue; for example, the job with the highest priority in a
      queue is not automatically job number 1.  The job number must be
      determined with NNETCAPJOB() or NNETJLIST().

      NNETJSTIME() returns the job start time.  An empty string indicates that
      no time has been set.  In this case, the job is serviced as soon as a
      print server is available.  ( An empty string can also indicate an
      error.  A differentiation is possible with the NNETERROR() function.)

      A new job start time can be set by passing a time with the <dNew>
      parameter.  If <dNew> contains an empty time string ("  :  :  "), a
      previously set job start date is removed.  If you reset a job start
      time, the job start date is removed automatically.

      To avoid an incorrect interpretation by the QMS of a date that has not
      been initialized, always set a job start date with the job start time.

   $NOTES$
      ■  To determine a job start time, the requesting user must have
         access to the queue as a user or an operator.  The modification of a
         job start time is reserved for the user who created the job or for
         queue operators.

      ■  A job that is already in progress cannot be modified.

   $EXAMPLES$
      ■  Query the job start time for the first job in the queue
         LINEPRINTER:

         nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
         ? NNETJSTIME('LINEPRINTER',nJob)

      ■  Create the capture job, set the job start date for the
         following day, and set the job start time for 10 PM:

         NNETCAPSSF(1)
         NNETCAPBEG(1)
         NNETSETQ(1,'LINEPRINTER')
         SET PRINTER ON
         ? 'Hello'
         nJob=NNETCAPJOB(1)
         NNETJSDATE('LINEPRINTER',nJob,Date()+1)
         NNETJSTIME('LINEPRINTER',nJob,'22:00:00')
         NNETCAPFLU(1)

      ■  The new job is always created at the first output (? "Hello"),
         not by calling NNETCAPBEG().  Therefore, NNETJSTIME() must be called
         after the first output.  If NNETJSTIME() is not called after the
         first output, NNETCAPJOB() returns the number of the previous capture
         job and the job start date is modified for the wrong job.

      ■  Remove the retention period for the first job in the queue
         LINEPRINTER (date and time):

         nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
         ? NNETJSDATE('LINEPRINTER',nJob,('  :  :  '))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJLIST(), NNETSDATE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJSUPFF()
   $ONELINER$
      Checks to see if the form feed at the end of a job is suppressed
   $SYNTAX$
      NNETJSUPFF(<cQueue>,<nJob>,[<lNewMode>],[<cServer>|
         <nConId>]) --> lMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <lNewMode>  Designates an optional parameter.  The value .T. causes
      the print server to ignore form feeds (Chr(12)) in <nJob>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      The return value of NNETJSUPFF() indicates if a form feed at the end of
      <nJob> is suppressed (.T.) or not (.F.).

   $DESCRIPTION$
      NOVELL NET JOB SUPPRESS FORM FEEDS
      Netware automatically creates a form feed at the end of each print job.
      With NNETJSUPFF(), a form feed can be suppressed by designating
      <lNewMode> with .T..  To query the current setting, do not pass a value
      for <lNewMode>.

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Check to see if a form feed is created for the first job in
         the queue LINEPRINTER:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         ? NNETJSUPFF('LINEPRINTER', nJob)

      ■  Suppress the form feed for the first job in the queue
         LINEPRINTER:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         ? NNETJSUPFF('LINEPRINTER', nJob, .T.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJBAN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJTABS()
   $ONELINER$
      Sets or determines the tab setting for a job
   $SYNTAX$
      NNETJTABS(<cQueue>,<nJob>,<nNewTabs>,[<cServer>|
         <nConId>]) --> nTabs

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <nNewTabs>  Designates an optional parameter that contains the
      number of spaces to which the tabs are expanded.  The value 0 indicates
      that the tabs are not expanded.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJTABS() returns the number of spaces to which the tabs (Chr(9)) are
      expanded.  The value 0 indicates that the tabs have not been expanded.
      If an error occurs, the function returns -1.

      The return value makes only sense if <nJob> is a text job.

   $DESCRIPTION$
      The Queue Management System (QMS) differentiates between text and binary
      jobs.  In text jobs, QMS is able to replace tabs (Chr(9)) with spaces.
      The number of spaces per tab can be queried or set with NNETJTABS().

      The required job is specified by its job number.  The job number has
      nothing to do with the logical position of a job within a queue; for
      example, the job with the highest priority in a queue is not
      automatically job number 1.  The job number must be determined with
      NNETCAPJOB() or NNETJLIST().

   $EXAMPLES$
      ■  Determine the number of spaces per tab created for the first
         job in the queue LINEPRINTER:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         IF NNETJTXT('LINEPRINTER', nJob)
         ? NNETJTABS('LINEPRINTER', nJob)
         ELSE
         ? 'No text job'
         ENDIF

      ■  Create five spaces per tab in the first job of the queue
         LINEPRINTER:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),5,2))
         IF NNETJTXT('LINEPRINTER', nJob)
         ? NNETJTABS('LINEPRINTER', nJob, 5)
         ELSE
         ? 'No text job'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJTXT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJTXT()
   $ONELINER$
      Determines if the contents of a job file are interpreted as text or a binary byte sequence
   $SYNTAX$
      NNETJTXT(<cQueue>,<nJob>,[<lNewMode>],[<cServer>|
         <nConId>]) --> lMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <lNewMode>  Designates an optional parameter that indicates if
      <nJob> contains text (.T.) or binary data (.F.).

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJTXT() returns .T. if <nJob> is a text job.  The value .F. indicates
      a binary job or an error.  By calling the function NNETERROR(), you can
      determine if the return value .F. is the result of an error.

   $DESCRIPTION$
      NOVELL NET JOB TEXT
      The Queue Management System (QMS) differentiates between text and binary
      jobs.  NNETJTXT() allows you to query or set the mode for <nJob>.

   $EXAMPLES$
      ■  Determine the mode for the second job in the queue
         LINEPRINTER:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),3,2))
         IF NNETJTXT('LINEPRINTER', nJob)
         ? 'Text job'
         ELSE
         ? 'Binary job'
         ENDIF

      ■  Define the second job of the queue LINEPRINTER as a text job:

         nJob=Bin2I(SubStr(NNETJLIST('LINEPRINTER'),3,2))
         NNETJTXT('LINEPRINTER', nJob, .T.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJTABS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETJWORK()
   $ONELINER$
      Checks to see if a job is currently in service on a print server
   $SYNTAX$
      NNETJWORK(<cQueue>,<nJob>,[<cServer>|<nConId>])
         --> lProcess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <nJob>  Designates the job number of the job that is processed in
      <cQueue>.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETJWORK() returns .T. if <nJob> is currently in service.  If a job is
      not yet in service or if an error occurs, the function returns .F..
      With NNETERROR() you can determine if the return value .F. results from
      an error.

   $DESCRIPTION$
      NOVELL NET JOB WORK
      NNETJWORK() allows you to determine whether or not a job is in service.
      If a job is already in service, its attributes cannot be modified.

   $EXAMPLES$
      Check to see if the first job in the queue LINEPRINTER is already in
      service:

      nJob=Bin2I(Left(NNETJLIST('LINEPRINTER'),2))
      IF NNETJWORK('LINEPRINTER', nJob)
      ? 'Job in service'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETNQSRVS()
   $ONELINER$
      Determines the number of print servers that service a print queue
   $SYNTAX$
      NNETNQSRVS(<cQueue>,[<lAll>],[<cServer>|<nConId>])
         --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is accessed.

      <lAll>  Designates whether all print servers that have access to
      <cQueue> (.T.) or only the print servers that are currently logged in at
      <cQueue> (.F.) are counted.  The default value is .F..

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETNQSRVS() returns the number of print servers currently logged in at
      <cQueue> (<lAll> = .F.) or the number of print servers that have access
      to <cQueue> (<lAll> = .T.).  If an error occurs (for example, if the
      <cQueue> does not exist), the function returns -1.

   $DESCRIPTION$
      NOVELL NET NUMBER OF QUEUE SERVERS
      NNETNQSRVS() allows you to determine if any print server has access to a
      specified queue, if a print server is currently logged in at a queue, or
      if the queue is "dead".

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Set the queue LINEPRINT to LPT1 for the capture mode if it is serviced
      by at least one print server:

      IF NNETNQSRVS('LINEPRINT')>0
      NNETSETQ(1,'LINEPRINT')
      ELSE
      ? 'Queue is currently not serviced !'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETQSRVS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETQDIR()
   $ONELINER$
      Determines the queue directory
   $SYNTAX$
      NNETQDIR(<cQueue>,[<cServer>|<nConId>]) --> cDir

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the queue for which the directory is
      determined.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETQDIR() returns the directory of the job files of <cQueue>. If an
      error occurs, the function returns an empty string.

   $DESCRIPTION$
      NOVELL NET QUEUE DIRECTORY
      Netware stores the contents of a job in a separate file.  The queue only
      contains references to these files.  NNETQDIR() allows you to determine
      the directory of the job files.  By default, the job directory is a
      subdirectory of SYS:SYSTEM.  The name of the subdirectory consists of
      the queue ID and the extension .QDR.

   $NOTES$
      ■  NNETQDIR() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      Display the directory for the print queue QUEUE1:

      ? NNETQDIR('QUEUE1')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJFILE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETQOPS()
   $ONELINER$
      Determines the list of queue operators
   $SYNTAX$
      NNETQOPS(<cQueue>,[<cServer>|<nConId>]) --> aQOps

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the print queue.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETQOPS() returns a one-dimensional array that contains the names of
      the operators of <cQueue>.

   $DESCRIPTION$
      NOVELL NET QUEUE OPERATORS
      NNETQOPS() allows you to determine the operators of <cQueue>.

   $NOTES$
      ■  NNETQOPS() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      Determine and display the operators for the print queue QUEUE1:

      aOps=NNETQOPS('QUEUE1')
      FOR i=1 TO Len(aOps)
         ? aOps[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETQUSERS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETQSRVS()
   $ONELINER$
      Determines the list of print servers that service a print queue
   $SYNTAX$
      NNETQSRVS(<cQueue>,[<lAll>],[<cServer>|<nConId>])
         --> aPrintServer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue for which the print
      servers are determined.

      <lAll>  Designates whether the names of all the print servers that
      have access to <cQueue> (.T.) or only the names of the print servers
      that are currently logged in at <cQueue> (.F.) are determined.  The
      default value is .F..

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETQSRVS() returns an array that contains the names of print servers
      currently logged in at <cQueue> (<lAll> = .F.) or the number of print
      servers that have access to <cQueue> (<lAll> = .T.).  If an error occurs
      (for example, if <cQueue> does not exist), the function returns an empty
      array.

   $DESCRIPTION$
      NOVELL NET QUEUE SERVERS
      NNETQSRVS() allows you to determine the names of print servers that are
      currently logged in <cQueue> or have access to <cQueue>.  This
      information can be used to access one or more print servers with the
      print server functions of CA-Clipper Tools.

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      Display a list of print servers that have access to the queue LINEPRINT
      and a list of print servers currently logged in at the queue LINEPRINT:

      aPServer=NNETQSRVS('LINEPRINT',.T.)
      ? 'Access to LINEPRINT have:'
      FOR i = 1 TO Len(aPServer)
      ? aPServer[i]
      NEXT i

      aPServer=NNETQSRVS('LINEPRINT')
      ? 'Currently logged in are:'
      FOR i = 1 TO Len(aPServer)
      ? aPServer[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETNQSRVS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETQSTAT()
   $ONELINER$
      Sets or reads a print queue status
   $SYNTAX$
      NNETQSTAT(<cQueue>,[<nStatus>],[<cServer>|<nConId>])
         --> nStatus

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the name of the print queue that is processed.

      <nStatus>  Designates an optional parameter that sets the queue
      status.  <nStatus> must be passed as a bit-coded value according to
      table 25.3.  To change more attributes, the decimal values of the
      required definitions must be added.

      <cServer>  Designates the name of the file server on which <cQueue>
      is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETQSTAT() returns a bit-coded value which describes the queue status.
      The following table contains the definitions of the bits:

      Table 25.3:  Queue Status Coding
      <table>
          Bit     Value     Definition

          2       2         No new jobs can be added to queue.
          3       4         Currently, no further print servers can be logged in
                            at queue currently.
          5       16        No jobs are being serviced in queue currently
         </table>

      If an error occurs (for example, if <cQueue> does not exist), the
      function returns -1.

   $DESCRIPTION$
      NOVELL NET QUEUE STATUS
      NNETQSTAT() allows you not only to query, but also to set a new queue
      status.  For example, this can be used to stop the print output for a
      queue temporarily.  To change the queue status, the requesting user must
      have access to the queue as an operator.

   $NOTES$
      ■  This function requires that the requesting user have access to
         the queue as a user or an operator.

   $EXAMPLES$
      ■  Check to see if jobs can be added to the queue LINEPRINTER:

         IF IsBit(NNETQSTAT('LINEPRINTER'),2)
         ? 'No new jobs can be added!'
         ELSE
         ? 'New jobs can be added!'
         ENDIF

      ■  Prevent the servicing of jobs in the queue LINEPRINTER:

         NNETQSTAT('LINEPRINTER',16)
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETQUSERS()
   $ONELINER$
      Determines the list of queue users
   $SYNTAX$
      NNETQUSERS(<cQueue>,[<cServer>|<nConId>])
         --> aQBenutzer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates the print queue.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETQUSERS() returns a one-dimensional array that contains the names of
      the users of <cQueue>.

   $DESCRIPTION$
      NOVELL NET QUEUE USERS
      NNETQUSERS() allows you to determine the users of <cQueue>.

   $NOTES$
      ■  NNETQUSERS() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      Determine and display the users for the print queue QUEUE1:

      aUser=NNETQUSERS('QUEUE1')

      FOR i=1 TO Len(aUser)
         ? aUser[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETQOPS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETREMQOP()
   $ONELINER$
      Removes a queue operator
   $SYNTAX$
      NNETREMQOP(<cQueue>,<cOperator>|<aOperators>,
         [<cServer>|   <nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates a print queue on the default server or on
      <cServer>|<nConId>.

      <cOperator>  Designates the name of a user that is removed from the
      operator list of <cQueue>.

      <aOperators>  Designates a number of elements of the type string.
      Each element designates the name of a user that is removed from the
      operator list of <cQueue>.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETREMQOP() returns the number of operators that are successfully
      removed from the operator list of <cQueue>.  The value 0 indicates that
      no operator has been deleted.

   $DESCRIPTION$
      NOVELL NET REMOVE QUEUE OPERATOR
      NNETREMQOP() allows you to remove one or more users from the operator
      list of a print queue.  To remove one operator, the user name must be
      passed in <cOperator>.  By passing an array containing the user names as
      elements (<aOperators>), more operators can be deleted.  With the
      parameters <cServer> or <nConId>, the operator list of any attached
      server can be modified.  The connection ID of a server can be determined
      with NNETATTACH() or NNETLOGIN().

      Supervisor rights of the requesting user on the related file server are
      required to remove users from an operator list.

   $NOTES$
      ■  NNETREMQOP() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Remove user MICK from the operator list of the queue
         LINEPRINTER:

         IF NNETREMQOP('LINEPRINTER','MICK')>0
               ? 'Operator removed successfully!'
         ELSE
               ? 'Error!'
         ENDIF

      ■  Remove JIM, PETER, and MIKE from the operator list of the
         queue LINEPRINTER:

         NNETREMQOP('LINEPRINTER',{'JIM','PETER','MIKE'})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDQOP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETREMQSV()
   $ONELINER$
      Removes a queue server
   $SYNTAX$
      NNETREMQSV(<cQueue>,<cPServer>|<aPServer>,[<cServer>|
         <nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates a print queue on the default server or on
      <cServer>|<nConId>.

      <cPServer>  Designates the name of a print server that is removed
      from the server list of <cQueue>.

      <aPServer>  Designates a number of elements of the type strings.
      Each element designates the name of a print server that is removed from
      the server list of <cQueue>.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETREMQSV() returns the number of print servers that have been removed
      successfully from the server list of <cQueue>.  The value 0 indicates
      that no print server has been deleted.

   $DESCRIPTION$
      NOVELL NET REMOVE QUEUE SERVER
      NNETREMQSV() allows you to remove one or more print servers from the
      server list of a print queue.  To remove one print server, the server
      name must be passed in <cPServer>.  By passing an array containing the
      server names as elements (<aPServer>), more print servers can be
      deleted.  With the parameters <cServer> or <nConId>, the server list of
      any attached server can be modified.  The connection ID of a server can
      be determined with NNETATTACH() or NNETLOGIN().

      Supervisor rights of the requesting user on the related file server are
      required to remove print servers from a server list.

   $NOTES$
      ■  NNETREMQSV() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Remove the print server PSERVER from the server list of the
         queue LINEPRINTER:

         IF NNETREMQSV('LINEPRINTER','PSERVER')>0
            ? 'Print server removed successfully!'
         ELSE
            ? 'Error!'
         ENDIF

      ■  Remove the print servers PSERVERTOOLS1 and PSERVERDEV1 from
         the server list of the queue LINEPRINTER:

         NNETREMQOP('LINEPRINTER',{'PSERVERTOOLS1','PSERVERDEV1'})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDQSV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETREMQUS()
   $ONELINER$
      Removes a queue user
   $SYNTAX$
      NNETREMQUS(<cQueue>,<cUser>|<aUser>,[<cServer>|
         <nConId>])    --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cQueue>  Designates a print queue on the default server or on
      <cServer>|<nConId>.

      <cUser>  Designates the login name of a user that is removed from
      the user list of <cQueue>.

      <aUser>  Designates a number of elements of the type string.  Each
      element designates the name of a user that is removed from the user list
      of <cQueue>.

      <cServer> Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETREMQUS() returns the number of users that have been removed
      successfully from the user list of <cQueue>.  The value 0 indicates that
      no user has been deleted.

   $DESCRIPTION$
      NOVELL NET REMOVE QUEUE USER
      NNETREMQUS() allows you to remove one or more users from the user list
      of a print queue.  To remove one user, the user name must be passed in
      <cUser>.  By passing an array containing the user names as elements
      (<aUser>), more users can be deleted.  With the parameters <cServer> or
      <nConId>, the user list of any attached server can be modified.  The
      connection ID of a server can be determined with NNETATTACH() or
      NNETLOGIN().

      Supervisor rights of the requesting user on the related file server are
      required to remove users from an user list.

   $NOTES$
      ■  NNETREMQUS() is a high level function based on the low level
         functions of the bindery access.  The CA-Clipper source code can be
         found on the product disks.

   $EXAMPLES$
      ■  Remove user MICK from the user list of the queue LINEPRINTER:

         IF NNETREMQUS('LINEPRINTER','MICK')>0
            ? 'User removed successfully!'
         ELSE
            ? 'Error!'
         ENDIF

      ■  Remove the users JIM, PETER, and MIKE from the user list of
         the queue LINEPRINTER:

         NNETREMQUS('LINEPRINTER',{'JIM','PETER','MIKE'})
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDQOP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSETQ()
   $ONELINER$
      Sets a print queue for the capture mode
   $SYNTAX$
      NNETSETQ(<nPrinter>,<cPrintQueue>) --> lLoggedIn

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPrinter>  Designates to which LPT device a new print queue is
      redirected.  LPT1(1) to LPT3(3) are valid.

      <cPrintQueue>  Designates the name of the print queue on the default
      server where the future print output is created.

   $RETURNS$
      NNETSETQ() returns .T. when the designated print queue has been found
      and redirected.

   $DESCRIPTION$
      NOVELL NET SET QUEUE
      You can use NNETSETQ() to determine which print queue of the default
      server generates the future print output.  If the queue is on another
      server, then you must switch over using NNETSETSRV().  All other
      settings required for printing can be done using the NNETCAPSSF()
      function.

   $NOTES$
      ■  The currently logged in user must have rights to use the
         designated queue.

   $EXAMPLES$
      Redirect the queue USER:

      ? NNETSETQ("USER")         // .T., when successful
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETCAPSSF()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Print Job Definitions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      With the Novell utility PRINTCON.EXE, print job definitions that contain
      the settings for a capture process can be created.  The functions in
      this chapter allow you to control the print job definitions of the
      current users and all other users on a file server.  You can create new
      job definitions and query or modify settings in existing definitions.
      It is possible to read the settings of a job definition and to directly
      start a capture process (NNETPJCAPF()).  This function call is
      equivalent to a call of the CAPTURE utility with the parameter /J=.

      Important!  Within the Netware documentation the term "job" is used
      to describe a print job within a queue and also a set of capture
      parameters (print job definition).  Within this chapter the term "job"
      or "job definition" only describes the definition of capture parameters.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJADD()
   $ONELINER$
      Adds a new print job definition
   $SYNTAX$
      NNETPJADD(<cJob>,[<cUser>],[<cServer>|<nConId>])
         --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the print job definition that is added.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJADD() returns .T. if the print job definition has been added
      successfully.

   $DESCRIPTION$
      NOVELL NET PRINT JOB ADD
      NNETPJADD() allows you to add a new print job definition (<cJob>) for
      <cUser>.  The new job definition is created with default values that can
      be modified by calling other NNETPJXXX() functions.  To achieve results
      with NNETPJADD(), a print job file for <cUser> must exist
      (PRINTCON.DAT).  <cJob> must be unique, and the job file must have less
      than 37 entries.  If <cUser> is not the current user, access rights for
      the mail directory of the user are required.

   $EXAMPLES$
      Add a new print job definition for the current user under the name
      MYJOB:

      IF NNETPJADD('MYJOB')
      ? 'Job definition has been added successfully'
      ELSE
      ? 'Error'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJCRT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJBAN()
   $ONELINER$
      Sets or queries the print of a banner page
   $SYNTAX$
      NNETPJBAN([<cJob>],[<lNewTitle>],[<cUser>],[<cServer>|
         <nConId>]) --> lBanner

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <lNewTitle>  Designates whether a banner page for <nJob> is printed
      (.T.) or not (.F.).

      <cServer>  Designates the name of the file server on which the queue
      <Queue> is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJBAN() returns .T. if the job definition includes printing a banner
      page.

   $DESCRIPTION$
      NOVELL NET PRINT JOB BANNER
      A banner page can be printed under Netware before each print job to show
      the user name.  NNETPJBAN() allows you to determine if a banner page is
      printed.  The printing of a banner page can be suppressed by passing the
      parameter <lNewTitle> with .F..  If <cUser> is not the current user,
      access rights for the mail system of the user are required.

   $EXAMPLES$
      ■  Determine if the job definition MYJOB includes printing a
         banner page:

         ? NNETPJBAN('MYJOB')

      ■  Suppress the printing of a banner page for the job MYJOB:

         ? NNETPJBAN('MYJOB', .F.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJBAN(), NNETPJBNAM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJBNAM()
   $ONELINER$
      Sets or queries the banner name of a print job
   $SYNTAX$
      NNETPJBNAM([<cJob>],[<cNewName>],[<cUser>],[<cServer>|
         <nConId>]) --> cName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates a default job.

      <cNewName>  Designates a new banner name that is set for <cJob>.
      The banner name can be up to 12 characters long.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJBNAM() returns the user name that is printed on the banner page of
      <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB BANNER NAME
      The banner page of a job contains the user name of the job owner and the
      name of the printed file.  NNETPJBNAM() allows you to set or determine
      the name of the printed file.  If <cUser> is not the current user,
      access rights for the mail system of the user are required.

   $EXAMPLES$
      ■  Determine the file name for the banner page in the job
         definition MYJOB:

         ? NNETPJBNAM('MYJOB')

      ■  Set the file name for the banner page in the job definition
         MYJOB to LST:

         ? NNETPJBAN('MYJOB', 'LST')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJBNAME(), NNETPJBAN(), NNETPJUSR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJCAP()
   $ONELINER$
      Sets or queries the capture mode for a print job
   $SYNTAX$
      NNETPJCAP([<cJob>],[<lNewCap>],[<cUser>],[<cServer>|
         <nConId>]) --> lCaptureMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <lNewCap>  Designates an optional parameter that allows you to set a
      new capture mode for <cJob>.  When this parameter is .T., the function
      activates the auto end capture mode.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJCAP() returns .T. if the auto end capture mode has been activated.

   $DESCRIPTION$
      NOVELL NET PRINT JOB CAPTURE MODE
      Under Netware, two capture modes are possible.  If the auto end capture
      mode is activated, open print jobs are closed automatically when the
      application has been terminated or the printer device has been closed.
      If the auto end capture mode is not activated, open jobs are closed when
      the timeout value is exceeded, or the ENDCAP utility or the CA-Clipper
      Tools NNETCAPEND() function are called.  NNETPJCAP() allows you to query
      or set the capture mode in a print job definition.  If <cUser> is not
      the current user, access rights for the mail system of the user are
      required.

   $EXAMPLES$
      ■  Determine the capture mode in the job definition MYJOB:

         IF NNETPJCAP('MYJOB')
         ? 'Auto end capture activated'
         ELSE
         ? 'Auto end capture mode not active'
         ENDIF

      ■  Activate the auto end capture mode in the job definition
         MYJOB:

         ? NNETPJCAP('MYJOB', .T.)
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJCAPF()
   $ONELINER$
      Starts the capture mode with print job settings
   $SYNTAX$
      NNETPJCAPF([<cJob>],[<cUser>],[<cServer>|<nConId>])
         --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJCAPF() returns .T. if the capture mode has been started
      successfully.

   $DESCRIPTION$
      NOVELL NET PRINT JOB CAPTURE FLAGS
      NNETPJCAPF() allows you to start a capture process with the settings of
      a print job definition (<cJob>).  A call of NNETPJCAPF() corresponds to
      a call of the Novell utility CAPTURE, with or without the /j=<cJob>
      option.  If <cUser> is not the current user, access rights for the mail
      system of the user are required.

   $NOTES$
      ■  NNETPJCAPF() starts a capture process.  A following call of
         NNETCAPBEG() is not necessary.

   $EXAMPLES$
      ■  Start a capture process with the settings of the default job
         definition:

         IF NNETPJCAPF()
         ? 'Capture has been started successfully'
         ELSE
         ? 'Error'
         ENDIF

      ■  Start a capture process with the settings of the job
         definition MYJOB:

         IF NNETPJCAPF('MYJOB')
         ? 'Capture has been started successfully'
         ELSE
         ? 'Error'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPBEG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJCNT()
   $ONELINER$
      Determines the number of jobs in a job file
   $SYNTAX$
      NNETPJCNT([<cUser>],[<cServer>|<nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJCNT() returns the number of print job definitions in the job
      definition file (PRINTCON.DAT) of <cUser>.  If an error occurs, the
      function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT JOB COUNT
      A job definition file (PRINTCON.DAT) can contain up to 37 entries.
      NNETPJCNT() allows you to determine the current number of job
      definitions.  If <cUser> is not the current user, access rights for the
      mail system of the user are required.

   $EXAMPLES$
      Determine the number of print job definitions for the current user:

      ? NNETPJCNT()
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJADD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJCOPY()
   $ONELINER$
      Sets or queries the number of copies for a print job
   $SYNTAX$
      NNETPJCOPY([<cJob>],[<nNewCopies>],[<cUser>],
         [<cServer>|<nConId>]) --> nCopies

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewCopies>  Designates the new number of copies for <cJob>.  The
      maximum number of copies is 255.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJCOPY() returns the number of copies of <cJob> that are printed.
      If an error occurs, the function returns -1.

   $DESCRIPTION$
      NNETPJCOPY() allows you to set or query the number of copies within a
      print job definition.  To query the number of copies, do not pass a
      value for <nNewCopies>.  If <cUser> is not the current user, access
      rights for the mail system of the user are required.

   $EXAMPLES$
      ■  Determine the number of copies in print job definition MYJOB:

         ? NNETPJCOPY('MYJOB')

      ■  Set the number of copies in print job definition MYJOB to 3:

         ? NNETPJCOPY('MYJOB', 3)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJCOPY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJCRT()
   $ONELINER$
      Creates an empty print job file
   $SYNTAX$
      NNETPJCRT([<cUser>],[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJCRT() returns .T. if the print job file has been created
      successfully.

   $DESCRIPTION$
      NOVELL NET PRINT JOB (DEFINITION FILE) CREATE
      NNETPJCRT() allows you to create an empty job definition file
      (PRINTCON.DAT) for the current user or any other user.  Job definitions
      can be added to this file by calling NNETPJADD().  If <cUser> is not the
      current user, access rights for the mail system of the user are
      required.

   $NOTES$
      Important!  If a print job file for <cUser> already exists, all job
      entries are lost when you call NNETPJCRT().

   $EXAMPLES$
      Create a new job definition file for the current user:

      cDef = 'SYS:MAIL/+RemLeft(NNETUSERID(), '0')+'PRINTCON.DAT'
      IF !FILE(cDef)
      NNETPJCRT()
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJADD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJDEF()
   $ONELINER$
      Sets or queries the default print job for a user
   $SYNTAX$
      NNETPJDEF([<cNewDefault>],[<cUser>],[<cServer>|
         <nConId>]) --> cDefault

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nNewDefault>  Designates an optional parameter that sets a new
      print job definition.  The definition must already exist.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJDEF() returns the name of the default job definition for <cUser>.

   $DESCRIPTION$
      In general, all NNETPJXXX() functions that refer to a print job
      definition access the default job definition.  NNETPJDEF() allows you to
      set or query the name of the default job definition.  If <cUser> is not
      the current user, access rights for the mail system of the user are
      required.

   $EXAMPLES$
      ■  Determine the name of the default job definition for the
         current user:

         ? NNETPJDEF()

      ■  Set MYJOB as the default job definition for the current user:

         ? NNETPJDEF('MYJOB')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJADD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJDEL()
   $ONELINER$
      Deletes a print job definition
   $SYNTAX$
      NNETPJDEL(<cJob>,[<cUser>],[<cServer>|<nConId>])
         --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the name of the print job definition.

      <cUser>  Designates the name of the user whose print job definition
      file (PRINTCON.DAT) is accessed.  The default value accesses the current
      user.

      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJDEL() returns .T. if the print job definition <cJob> has been
      deleted successfully.  If an error occurs, the function returns .F..

   $DESCRIPTION$
      NOVELL NET PRINT JOB DELETE
      NNETPJDEL() allows you to delete the print job definition (<cJob>) of
      the current user or any other user (if the print job definition file can
      be accessed for that user).  The default job cannot be deleted.

   $EXAMPLES$
      Delete the print job HPLJ of the current user:

      IF NNETPJDEL('HPLJ')
         ? 'Job definition deleted successfully!'
      ELSE
         ? 'Error'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJADD(), NNETPJCRT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJDEV()
   $ONELINER$
      Sets or queries the print job device
   $SYNTAX$
      NNETPJDEV([<cJob>],[<cNewDevice>],[<cUser>],
         [<cServer>|<nConId>]) --> cDevice

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewDevice>  Designates a new device name for <cJob>.  The device
      name must have an entry in the printer definition file (NET$PRN.DAT) on
      <cServer>.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJDEV() returns the device name in the job definition <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB DEVICE
      A print job definition can contain the name of a device.  This name can
      be set or queried by calling NNETPJDEV().  Do not pass a value for
      <cNewDevice> to query the device name.  A device name can be set by
      specifying <cNewDevice>.  To reset a device name (set to none), the
      parameter <cNewDevice> must contain an empty string ("").  If <cUser> is
      not the current user, access rights for the mail system of the user are
      required.

   $NOTES$
      ■  Setting a new device name resets the current device mode.  The
         mode can then be set by calling NNETPJMODE().

   $EXAMPLES$
      ■  Determine the device name in the job definition MYJOB:

         ? NNETPJDEV('MYJOB')

      ■  Set the device name in the job definition MYJOB to HPLJ:

         ? NNETPJDEV('MYJOB', 'HPLJ')

      ■  Reset the device name in the job definition MYJOB to NONE:

         ? NNETPJDEV('MYJOB', '')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJFORM(), NNETPJMODE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJFORM()
   $ONELINER$
      Sets or queries the print job form
   $SYNTAX$
      NNETPJFORM([<cJob>],[<cNewForm>],[<cUser>],[<cServer>|
         <nConId>]) --> cForm

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewForm>  Designates a new form name for <cJob>.  The form name
      must have an entry in the printer definition file (NET$PRN.DAT) on
      <cServer>.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJFORM() returns the form name in the job definition <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB FORM
      A print job definition can contain the name of a form.  This name can be
      set or queried by calling NNETPJFORM().  Do not pass a value for
      <cNewForm> to query the form name.  A form name can be set by specifying
      <cNewForm>.  If <cUser> is not the current user, access rights for the
      mail system of the user are required.

   $EXAMPLES$
      ■  Determine the form name in the job definition MYJOB:

         ? NNETPJFORM('MYJOB')

      ■  Set the form name in the job definition MYJOB to INVOICE:

         ? NNETPJFORM('MYJOB', 'INVOICE')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJDEV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJFSRV()
   $ONELINER$
      Sets or queries the file server for a print job
   $SYNTAX$
      NNETPJFSRV([<cJob>],[<cNewServer>],[<cUser>],
         [<cServer>|<nConId>]) --> cFileServer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewServer>  Designates a new file server name for <cJob>.  The
      file server must be available in the internal network.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJFSRV() returns the name of the file server in the job definition
      <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB FILE SERVER
      A print job definition must contain the name of a file server to find
      the print queue when the job is activated.  The file server name can be
      set or queried by calling NNETPJFSRV().  Do not pass a value for
      <cNewServer> to query the server name.  A server name can be set by
      specifying <cNewServer>.  If <cUser> is not the current user, access
      rights for the mail system of the user are required.

   $EXAMPLES$
      ■  Determine the file server name in the job definition MYJOB:

         ? NNETPJFSRV('MYJOB')

      ■  Set the server name in the job definition MYJOB to SERVER1:

         ? NNETPJFSRV('MYJOB', 'SERVER1')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJLIST()
   $ONELINER$
      Determines the print job list for a user
   $SYNTAX$
      NNETPJLIST([<cUser>],[<cServer>|<nConId>]) --> aJobs

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJLIST() returns a one-dimensional array that contains the names of
      the print job definitions for <cUser>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB LIST
      NNETPJLIST() returns a list of all existing job definitions for <cUser>.
      If <cUser> is not the current user, access rights for the mail system of
      the user are required.

   $EXAMPLES$
      Determine and display the job definitions for the current user:

      aJobs = NNETPJLIST()
      FOR i = 1 TO Len(aJobs)
      ? aJobs[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJDEF()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJLPT()
   $ONELINER$
      Sets the LPT device for a print job definition
   $SYNTAX$
      NNETPJLPT([<cJob>],[<nNewLPT>],[<cUser>],[<cServer>|
         <nConId>]) --> nLPT

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewLPT>  Designates a new LPT device for <cJob>.  Values from 1 to
      3 (LPT1 to LPT3) are valid.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJLPT() returns the LPT device.  A return value of -1 indicates an
      error.

   $DESCRIPTION$
      NOVELL NET PRINT JOB LPT
      A local parallel interface, referred to the definition, must be
      specified for each print job definition.  The LPT device of a print job
      definition can be set or queried by calling NNETPJLPT().  Do not pass a
      value for <cNewLPT> to query the LPT device.  A new LPT device can be
      set by designating a value for <cNewLPT> between 1 and 3 for LPT1 to
      LPT3.  If <cUser> is not the current user, access rights for the mail
      system of the user are required.

   $EXAMPLES$
      ■  Determine the LPT device in the job definition MYJOB:

         ? NNETPJLPT('MYJOB')

      ■  Set the LPT device in the job definition MYJOB to 2:

         ? NNETPJLPT('MYJOB', 2)
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJMODE()
   $ONELINER$
      Sets or queries the device mode for a print job
   $SYNTAX$
      NNETPJMODE([<cJob>],[<cNewMode>],[<cUser>],[<cServer>|
         <nConId>]) --> cMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewMode>  Designates a new device mode for <cJob>.  The device
      mode must have an entry in the printer definition file (NET$PRN.DAT) on
      <cServer>.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJMODE() returns the device mode in the job definition <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB MODE
      A print job definition can contain the name of a device and a
      corresponding device mode.  The device mode can be set or queried by
      calling NNETPJMODE().  Do not pass a value for <cNewMode>.  A device
      mode can be set to query the device mode by specifying <cNewMode>.  To
      reset a device mode (set to none), the parameter <cNewMode> must contain
      an empty string ("").  If <cUser> is not the current user, access rights
      for the mail system of the user are required.

   $NOTES$
      ■  The device mode is validated only when it is set.  If the
         device has been modified with NNETPJDEV(), the returned device mode
         can be invalid.

   $EXAMPLES$
      ■  Determine the device mode in the job definition MYJOB:

         ? NNETPJMODE('MYJOB')

      ■  Set the device mode in the job definition MYJOB to PLAIN:

         ? NNETPJMODE('MYJOB', 'PLAIN')

      ■  Reset the device name and the device mode in the job
         definition MYJOB to NONE:

         ? NNETPJDEV('MYJOB', '')
         ? NNETPJMODE('MYJOB', '')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJDEV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJNOTY()
   $ONELINER$
      Sets or queries the notify mode for a print job
   $SYNTAX$
      NNETPJNOTY([<cJob>],[<lNewMessage>],[<cUser>],
         [<cServer>|<nConId>]) --> lMessage

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewMessage>  Designates a new notify mode that is set for <cJob>.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJNOTY() returns the notify mode in the job definition <cJob>.  A
      return of .T. indicates that the user is notified after a job has been
      printed.

   $DESCRIPTION$
      NOVELL NET PRINT JOB NOTIFY
      Netware allows a user to receive a broadcast message after a job has
      been printed.  This option can be specified within a job definition.
      NNETPJNOTY() allows you to set or query the option.  Do not pass a value
      for <cNewMessage> to query the notify option.  When <cNewMessage> is set
      to .T., the user is notified after a job has been printed.    If <cUser>
      is not the current user, access rights for the mail system of the user
      are required.

   $EXAMPLES$
      ■  Determine the notify mode for the default job:

         IF NNETPJNOTY()
         ? 'Notify mode activated'
         ELSE
         ? 'Notify mode not active'
         ENDIF

      ■  Activate the notify mode for default job:

         ? NNETPJNOTY(, .T.)
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJPSRV()
   $ONELINER$
      Sets or queries the target print server for a print job
   $SYNTAX$
      NNETPJPSRV([<cJob>],[<cNewServer>],[<cUser>],
         [<cServer>|<nConId>]) --> cPrintServer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewServer>  Designates a new print server name for <cJob>.  The
      print server must be in the print server list of the currently defined
      queue.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJPSRV() returns the name of the print server in the job definition
      <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB PRINT SERVER
      A print job definition can contain the name of a print server.  This
      setting is not supported by the Novell capture services.  However, you
      can use the information in conjunction with the CA-Clipper Tools
      functions for job manipulation to set a specified print server as the
      target for a print job  (NNETJSRV()).

      The print server name can be set or queried by calling NNETPJPSRV().  Do
      not pass a value for <cNewServer> to query the server name.  A server
      name can be set by specifying <cNewServer>.  If <cUser> is not the
      current user, access rights for the mail system of the user are
      required.

   $EXAMPLES$
      ■  Determine the print server name in the job definition MYJOB:

         ? NNETPJPSRV('MYJOB')

      ■  Set the print server name in the job definition MYJOB to
         PSERVER:

         ? NNETPJPSRV('MYJOB', 'PSERVER')

      ■  Create the print job, and set the print server of the job
         definition MYJOB as the target server:

         NNETPJCAPF('MYJOB')
         SET PRINTER ON
         ? 'Hello'           // A new job is created
         NNETJSRV('LINEPRINTER', NNETCAPJOB(1), NNETPJPSRV('MYJOB'))
         ? NNETCAPFLU(1)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETCAPJOB(), NNETJSRV(), NNETPJFSRV(), NNETPJQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJQ()
   $ONELINER$
      Sets or queries the print queue for a print job
   $SYNTAX$
      NNETPJQ([<cJob>],[<cNewQueue>],[<cUser>],[<cServer>|
         <nConId>]) --> cQueue

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewQueue>  Designates a new queue that is set for <cJob>.  The
      queue must exist on the file server currently defined in <cJob>.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJQ() returns the name of the print queue in the job definition
      <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB QUEUE
      A print job definition must contain the name of the print queue that is
      set as the target queue when the definition is activated.  The queue
      name can be set or queried by calling NNETPJQ().  Do not pass a value
      for <cNewQueue> to query the queue name.  A new queue can be set by
      specifying <cNewQueue>.  If <cUser> is not the current user, access
      rights for the mail system of the user are required.

   $EXAMPLES$
      ■  Determine the queue in the job definition MYJOB:

         ? NNETPJPQ('MYJOB')

      ■  Set the queue in the job definition MYJOB to LINEPRINTER:

         ? NNETPJQ('MYJOB', 'LINEPRINTER')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJFSRV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJSUPF()
   $ONELINER$
      Sets or queries the form feed mode after a print job
   $SYNTAX$
      NNETPJSUPF([<cJob>],[<lNewPage>],[<cUser>],[<cServer>|
         <nConId>]) --> lPageMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <lNewPage>  Designates a new form feed mode for <cJob>.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJSUPF() returns the form feed mode for <cJob>.  A return of .F.
      indicates that a form feed is performed after a job has been printed.

   $DESCRIPTION$
      NOVELL NET SUPPRESS FORM FEED
      Netware automatically creates a form feed at the end of each print job.
      NNETPJSUPF() allows you to set a form feed or determine if a form feed
      is defined in the job definition.  A form feed can be suppressed by
      designating <lNewPage> with .T..  Do not pass a value for <lNewPage> to
      query the current setting.  If <cUser> is not the current user, access
      rights for the mail system of the user are required.

   $EXAMPLES$
      ■  Determine the form feed mode for the default job:

         IF NNETPJSUPF()
         ? 'Form feed suppressed'
         ELSE
         ? 'Form feed activated'
         ENDIF

      ■  Deactivate the form feed for the default job:

         ? NNETPJSUPF(, .T.)
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJTABS()
   $ONELINER$
      Sets or queries the tab widths for a print job
   $SYNTAX$
      NNETPJTABS([<cJob>],[<nNewTab>],[<cUser>],[<cServer>|
         <nConId>]) --> nTab

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewTabs>  Designates an optional parameter that contains the
      number of spaces to which the tabs are expanded.  The value 0 designates
      that the tabs are not expanded.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJTABS() returns the number of spaces to which the tabs (Chr(9)) are
      expanded.  The value 0 indicates that the tabs have not been expanded.
      If an error occurs, the function returns -1.

      The return value has a meaning only if the text mode is set in <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB TABS
      In text jobs, the print server is able to replace tabs (Chr(9)) with
      spaces.  The number of spaces per tab can be queried or set with
      NNETPJTABS().  Do not pass a value for <nNewTabs> to query the number of
      spaces.

   $EXAMPLES$
      ■  Determine the number of spaces that are set as a tab
         replacement in the default job:

         NNETPJTABS()

      ■  Set the number of spaces per tab to 4 in the default job:

         ? NNETPJTABS(, 4)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJTXT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJTXT()
   $ONELINER$
      Sets or queries the text or binary mode for a print job
   $SYNTAX$
      NNETPJTXT([<cJob>],[<lNewText>],[<cUser>],[<cServer>|
         <nConId>]) --> lText

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <lNewMode>  Designates an optional parameter that indicates whether
      text (.T.) or binary (.F.) jobs are created after the definition <cJob>
      has been activated.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      The return value of NNETPJTXT() specifies the data type in the job
      definition <cJob>.  A return value of .F. indicates binary data, and a
      return value of .T. indicates text data.

   $DESCRIPTION$
      NOVELL NET PRINT JOB TEXT
      The Queue Management System (QMS) differentiates between text and binary
      jobs.  NNETJTXT() allows you to query or set the mode for a job
      definition <cJob>.

   $EXAMPLES$
      ■  Determine the mode for the default job:

         IF NNETPJTXT()
         ? 'Text mode'
         ELSE
         ? 'Binary mode'
         ENDIF

      ■  Set the text mode for the default job:

         ? NNETPJTXT(, .T.)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJTABS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJUSR()
   $ONELINER$
      Sets or determines the user name of a print job
   $SYNTAX$
      NNETPJUSR([<cJob>],[<cNewName>],[<cUser>],[<cServer>|
         <nConId>]) --> cName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <cNewName>  Designates an optional parameter that allows you to set
      a new user name for <cJob>.  The name can be up to 12 characters long.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NOVELL NET PRINT JOB USER
      NNETPJUSR() returns the user name for the banner page in the job
      definition file <cJob>.

   $DESCRIPTION$
      NOVELL NET PRINT JOB USER (NAME)
      The banner page of a job contains the user name of the job owner and the
      name of the printed file.  NNETPJUSR() allows you to set or determine
      the user.  If <cUser> is not the current user, access rights for the
      mail system of the user are required.

   $EXAMPLES$
      ■  Determine the user name for the banner page in the job
         definition MYJOB:

         ? NNETPJUSR('MYJOB')

      ■  Set the user name for the banner page in the job definition
         MYJOB to MICK:

         ? NNETPJBAN('MYJOB', 'MICK')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJBNAME(), NNETPJBAN(), NNETPJBNAM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPJWAIT()
   $ONELINER$
      Sets or queries the timeout for a print job
   $SYNTAX$
      NNETPJWAIT([<cJob>],[<nNewTimeout>],[<cUser>],
         [<cServer>|<nConId>]) --> nTimeout

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cJob>  Designates the selected print job definition.  The default
      value designates the default job.

      <nNewTimeout>  Designates an optional parameter that allows you to
      set a timeout in seconds for <cJob>.  A value of 0 indicates a timeout
      that does not end.

      <cUser>  Designates the name of the user whose print job definition
      is processed.  The default value designates the current user.

      <cServer>  Designates the name of the file server on which the
      operation is processed.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPJWAIT() returns the timeout in seconds.  The value 0 indicates a
      timeout that does not end.  If an error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT JOB WAIT
      The timeout in a job definition specifies after how many seconds without
      data output a job is automatically closed.  NNETPJWAIT() allows you to
      set or query the timeout.  Do not pass a value for <nNewTimeout> to
      query the number of seconds.  If <cUser> is not the current user, access
      rights for the mail system of the user are required.

   $EXAMPLES$
      ■  Determine the timeout in the job definition MYJOB:

         ? NNETPJWAIT('MYJOB')

      ■  Set the timeout in the job definition MYJOB to 20 seconds:

         ? NNETPJWAIT('MYJOB', 20)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPJCAP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Print Server Access
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      Under Netware 3.x, control of network printers is no longer handled by a
      file server but by a print server.  (However, as an NLM, the print
      server can also run on a file server.)  Under Netware 2.2, a print
      server VAP is available.  The functions of this chapter provide the
      ability to access the most important information and functions of a
      print server.  For example, you can determine the status of a print
      server printer.  In conjunction with the functions for Point To Point
      communication, a CA-Clipper application is able to emulate a remote
      printer (see sample program RPRINTER.PRG).
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSACC()
   $ONELINER$
      Determines the access rights to a print server
   $SYNTAX$
      NNETPSACC(<cPServer>,[<cServer>|<nConId>]) --> nAccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSACC() returns the access rights to <cPServer>.

      Table 27.1:  Access Rights
      <table>
          Value   Definition

          -1      Error
          0       Restricted access
          1       Print server user
          2       Print server operator
         </table>

   $DESCRIPTION$
      NOVELL NET PRINT SERVER ACCESS
      NNETPSACC() allows you to determine the operations that the current user
      can execute on <cPServer>.  While simple operations (like status query)
      can be done by any user, critical operations (like print server
      controlling and configuration) require operator rights.

   $EXAMPLES$
      Determine the access rights to print server PSERVER1:

      ? NNETPSACC('PSERVER1')
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSADDQ()
   $ONELINER$
      Adds a queue to a print server printer
   $SYNTAX$
      NNETPSADDQ(<cPServer>,<nPrinter>,<cQueue>,[<nPrior>],
         [<cServer>|<nConId>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cQueue>  Designates the name of the print queue that is added.

      <nPrior>  Designates the priority for <cQueue>.  The highest
      priority is 1, which is also the default value.

      <cServer> Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSADDQ() returns .T. if <cQueue> has been added successfully to
      <nPrinter>.  If an error occurs (for example, insufficient rights), the
      function returns .F..

   $DESCRIPTION$
      NOVELL NET PRINT SERVER ADD QUEUE (TO PRINTER)
      NNETPSADDQ() allows you to add a print queue to a print server printer
      (<nPrinter>).  This function requires operator rights and access rights
      for <cPServer> and <cQueue>.

   $EXAMPLES$
      Add the print queue TOOLSQ_1 to print server printer 0 on print server
      PSERVER:

      IF NNETPSADDQ('PSERVER',0,'TOOLSQ_1')
         ? 'Queue TOOLSQ_1 has been added!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADDQSV(), NNETPSACC(), NNETPSDELQ(), NNETQSRVS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSAJOB()
   $ONELINER$
      Aborts the print job that is currently being printed
   $SYNTAX$
      NNETPSAJOB(<cPServer>,<nPrinter>,[<nJobMode>],[<cServer>|
         <nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <nJobMode>  Designates the mode of the job that is aborted according
      to the following table:

      Table 27.2:  Job Modes
      <table>
          Value   CTPS.CH        Definition

          1       PSJ_RET2Q      Return job to queue
          2       PSJ_THROWAWAY  Discard job
         </table>

      The default value for <nJobMode> is 1.  To return the job to the queue,
      you must set the service restart flag (see NNETJFLAGS()).

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSAJOB() returns .T. if the current job of <nPrinter> on <cPServer>
      has been aborted.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER ABORT JOB
      NNETPSAJOB() allows you to abort a print job currently being printed.
      You can determine if the job is returned to the queue (<nJobMode>=1) or
      discarded (<nJobMode>=2).

   $EXAMPLES$
      Abort and discard the job of printer 0 on print server PSERVER:

      #include "ctps.ch"

      NNETPSAJOB('PSERVER',0,PS_THROWAWAY)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSTOP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSANO()
   $ONELINER$
      Defines an object that is notified for the print server printer
   $SYNTAX$
      NNETPSANO(<cPServer>,<nPrinter>,<cObjName>,[<nObjType>],
         [<nFirst>],[<nNext>],[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cObjName>  Designates the name of the bindery object (for example,
      a user) that is defined as the object that is notified for <nPrinter> on
      <cPServer>.

      <nObjType>  Designates a numeric value that indicates the type of
      <cObjName>.  The header file CTNNET.CH contains symbolic constants for
      the object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value designates the object type
      OBJ_USER.

      <nFirst>  Designates a time value in seconds that specifies the
      waiting period between when a problem occurs and the first message.  The
      default value is 30 seconds.

      <nNext>  Designates a time value in seconds that specifies the
      length of the time interval between two messages.  The default value is
      60 seconds.

      <cServer> Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSANO() returns .T. if <cObjName> has been added as the object that
      is notified for <nPrinter> on <cPServer>.  If an error occurs (for
      example, no operator rights), the function returns .F..

   $DESCRIPTION$
      NOVELL NET PRINT SERVER ADD NOTIFY OBJECT
      NNETPSANO() allows you to define objects (normally users) that are
      notified if printer problems occur (printer offline, no paper) for a
      print server printer.  This function requires operator rights for
      <cPServer>.  For efficiency reasons, numeric values for <nObjType> must
      be passed in the high-low format.

   $EXAMPLES$
      Add user MICK as the object that is notified for printer 0 on PSERVER:

      IF NNETPSANO('PSERVER',0,'MICK')
         ? 'User MICK added successfully!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSCNO(), NNETPSDNO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSARP()
   $ONELINER$
      Determines the available remote printers of a print server
   $SYNTAX$
      NNETPSARP(<cPServer>,[<cServer>|<nConId>]) --> aRemote

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer> Designates the name of the print server that is accessed.

      <cServer> Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSARP() returns an array with subarrays (two-dimensional array).
      Each subarray contains information about an available remote printer.
      For the structure of the subarrays, see the following table:

      Table 27.3:  NNETPSARP() Subarray Structure
      <table>
          Position     Metasymbol     CTPS.CH   Definition

          1            cName          ARP_NAME  Printer name
          2            nNumber        ARP_NUM   Printer number (0..15)
          3            nTyp           ARP_TYPE  printer type
         </table>

      If an error occurs, the function returns an empty array.

      For the printer type, the following values are possible:

      Table 27.4:  Printer Types
      <table>
          Value   CTPS.CH        Definition

          7       PSP_REMLPT1    Remote printer on LPT1:
          8       PSP_REMLPT2    Remote printer on LPT2:
          9       PSP_REMLPT3    Remote printer on LPT3:
          10      PSP_REMCOM1    Remote printer on COM1:
          11      PSP_REMCOM2    Remote printer on COM2:
          12      PSP_REMCOM3    Remote printer on COM3:
          13      PSP_REMCOM4    Remote printer on COM4:
         </table>

   $DESCRIPTION$
      NOVELL NET AVAILABLE REMOTE PRINTERS
      Netware print servers can serve printers connected to a workstation
      (remote printers).  NNETPSARP() allows you to determine which remote
      printers of a print server are available.  The sample program
      RPRINTER.PRG demonstrates how to use NNETPSARP() for the emulation of a
      remote printer.

   $EXAMPLES$
      Display the list of available remote printers for print server PSERVER:

      #include "ctnet.ch"

      aRemote=NNETPSARP('PSERVER')
      FOR i=1 TO Len(aRemote)
         ? aRemote[i,ARP_NAME],aRemote[i,ARP_TYPE]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSRRP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSCAND()
   $ONELINER$
      Cancels the down request of a print server
   $SYNTAX$
      NNETPSCAND(<cPServer>,[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSCAND() returns .T. if a running down request of <cPServer> has
      been canceled successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER CANCEL DOWN (REQUEST)
      If a print server receives a down request, it can continue to process
      active jobs.  Within this time period, the down request can be canceled
      with NNETPSCAND().  This function requires operator rights for
      <cPServer>.

   $EXAMPLES$
      Cancel the down request for the print server PSERVER:

      // Start down request
      NNETPSDOWN('PSERVER')

      IF .NOT. NNETPSCAND('PSERVER')
         ? 'Down request cannot be canceled!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSDOWN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSCHGQ()
   $ONELINER$
      Changes the queue priority
   $SYNTAX$
      NNETPSCHGQ(<cPServer>,<nPrinter>,<cQueue>,[<nPrior>],
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cQueue>  Designates the queue for which the priority is changed.

      <nPrior>  Designates the new priority for <cQueue>.  The highest
      priority is 1, which is also the default value.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSCHGQ() returns .T. if the priority has been changed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER CHANGE QUEUE (PRIORITY)
      Jobs within a queue are serviced by a print server according to the
      queue priorities.  NNETPSCHGQ() allows you to change the priority of a
      queue (<cQueue>) for a print server (<nPrinter>).  This function
      requires operator rights for <cPServer>.

   $EXAMPLES$
      Set the priority of QUEUE1 for printer 0 on PSERVER to 3 (low priority):

      IF NNETPSCHGQ('PSERVER',0,'QUEUE1',3)
         ? 'Priority changed successfully!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSADDQ(), NNETPSDELQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSCNO()
   $ONELINER$
      Changes the settings for the object that is notified
   $SYNTAX$
      NNETPSCNO(<cPServer>,<nPrinter>,<cObjName>,[<nObjType>],
         [<nFirst>],[<nNext>],[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cObjName>  Designates the name of the bindery object (for example,
      a user) that is defined as the object to notify for <nPrinter> on
      <cPServer>.

      <nObjType>  Designates a numeric value that indicates the type of
      <cObjName>.    The header file CTNNET.CH contains symbolic constants for
      the object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value designates the object type
      OBJ_USER.

      <nFirst>  Designates a time value in seconds that specifies the
      waiting period between when a problem occurs and the first message.  The
      default value designates no modification.

      <nNext>  Designates a time value in seconds that specifies the
      length of the interval between two messages.  The default value
      designates no modification.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSCNO() returns .T. if the values for <nFirst> and <nNext> have been
      changed as requested.  If an error occurs (for example, no operator
      rights), the function returns .F..

   $DESCRIPTION$
      NOVELL NET PRINT SERVER CHANGE NOTIFY (OBJECT)
      NNETPSCNO() allows you to change the waiting period for the first
      message after a problem has occurred (<nFirst>) and the time period
      between the following messages (<nNext>).  This function requires
      operator rights for <cPServer>.  For efficiency reasons, numeric values
      for <nObjType> must be passed in the high-low format.

   $EXAMPLES$
      Set the waiting period for the first message to 10 seconds, and set the
      time interval between the following messages to 30 seconds:

      IF NNETPSCNO('PSERVER',0,'MICK',,10,30)
         ? 'Values changed successfully!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSANO(), NNETPSDNO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSDELQ()
   $ONELINER$
      Deletes queue access for a print server printer
   $SYNTAX$
      NNETPSDELQ(<cPServer>,<cQueue>,[<lImmediate>],
         [<nJobMode>],[<cServer>|<nConId>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cQueue>  Designates the name of the print queue that is deleted
      from <nPrinter>.

      <lImmediate>  Designates if the operation is executed immediately
      (.T.) or if active jobs are completed (.F.).  The default value is .F..

      <nJobMode>  Designates the mode of the job that will be active,
      according to the following table.  This parameter is only taken into
      account if <lImmediate> is designated .T..

      Table 27.5:  Job Modes
      <table>
          Value   CTPS.CH        Definition

          1       PSJ_RET2Q      Return job to queue
          2       PSJ_THROWAWAY  Discard job
         </table>

      The default value for <nJobMode> is 1.  To return the job to the queue,
      you must set its service restart flag (see NNETJFLAGS()).

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSDELQ() returns .T. if the queue has been deleted successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER DELETE QUEUE (FROM PRINTER)
      NNETPSDELQ() allows you to delete a queue from a print server printer
      (<nPrinter>).  This function requires operator rights for <cPServer>.

   $EXAMPLES$
      Delete the print queue TOOLSQ_1 from print server printer 0 on print
      server PSERVER:

      IF NNETPSDELQ('PSERVER',0,'TOOLSQ_1')
         ? 'Queue TOOLSQ_1 deleted!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSADDQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSDNO()
   $ONELINER$
      Deletes an object that is notified for a print server printer
   $SYNTAX$
      NNETPSDNO(<cPServer>,<NPrinter>,<cOBjName>,[<nObjType>],
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cObjName>  Designates the name of the bindery object (for example,
      a user) that is deleted from the list of notified objects.

      <nObjType>  Designates a numeric value that indicates the type of
      <cObjName>.  The header file CTNNET.CH contains symbolic constants for
      the object types defined by Novell for use with the bindery functions of
      CA-Clipper Tools.  The default value designates the object type
      OBJ_USER.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSDNO() returns .T. if <cObjName> has been deleted from the list of
      notified objects for <nPrinter> on <cPServer>.  If an error occurs (for
      example, no operator rights), the function returns .F..

   $DESCRIPTION$
      NOVELL NET PRINT SERVER NOTIFY OBJECT
      NNETPSDNO() allows you to delete a notified object from the list of
      notified objects for <nPrinter> on <cPServer>.  This function requires
      operator rights for <cPServer>.  For efficiency reasons, numeric values
      for <nObjType> must be passed in the high-low format.

   $EXAMPLES$
      Delete user MICK from the list of notified objects for printer 0 on
      PSERVER:

      IF NNETPSDNO('PSERVER',0,'MICK')
         ? 'User MICK deleted successfully!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSANO(), NNETPSCNO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSDOWN()
   $ONELINER$
      Deinitializes a print server
   $SYNTAX$
      NNETPSDOWN(<cPServer>,[<lImmediate>],[<nJobMode>],
         [<cServer>|<nConId>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <lImmediate>  Designates if the operation is executed immediately
      (.T.) or if active jobs are completed (.F.).  The default value is .F..

      <nJobMode>  Designates the mode of the job that will be active,
      according to the following table.  This parameter is only taken into
      account if <lImmediate> is designated .T..

      Table 27.6:  Job Modes
      <table>
          Value   CTPS.CH        Definition

          1       PSJ_RET2Q      Return job to queue
          2       PSJ_THROWAWAY  Discard job
         </table>

      The default value for <nJobMode> is 1.  To return the job to the queue,
      you must set its service restart flag (see NNETJFLAGS()).

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDOWN() returns .T. if the operation has been executed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER DOWN
      NNETDOWN() allows you to initialize a down request for <cPServer>.  With
      <lImmediate> you can specify if the down request is executed immediately
      (.T.) or if active jobs are completed first (.F.).  During this time
      period the down request can be canceled with NNETPSCAND().  This
      function requires operator rights for <cPServer>.

   $NOTES$
      ■  A print server shut down with NNETDOWN() cannot be rebooted
         from an application!

   $EXAMPLES$
      Start the controlled shut down of PSERVER:

      ? NNETPSDOWN('PSERVER')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSCAND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSERR()
   $ONELINER$
      Determines the error code of the most recent print server call
   $SYNTAX$
      NNETPSERR() --> nErrorCode

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETPSERR() returns the error code of the most recent print server
      function call by a CA-Clipper Tools function (NNETPSXXX() functions).
      There is an error code table in Appendix F.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER ERROR
      CA-Clipper Tools functions for print server control (NNETPSXXX()) do not
      use Netware API calls, but communicate directly with the print server.
      Therefore, the error code of the print server functions cannot be
      queried with the NetError() function.  NNETPSERR() allows you to
      determine the error code of the most recent print server call.  If a
      print server call has been executed successfully, the function returns
      0.

   $EXAMPLES$
      Delete QUEUE1 from printer 0 on PSERVER.  If the call is unsuccessful,
      determine the reason:

      IF .NOT. NNETPSDELQ('PSERVER',0,'QUEUE1')
         IF NNETPSERR()=782
            ? 'Insufficient rights...'
         ENDIF
      ENDIF
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSFF()
   $ONELINER$
      Initializes a form feed on the print server printer
   $SYNTAX$
      NNETPSFF(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSFF() returns .T. if the function has been executed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER FORM FEED
      NNETPSFF() allows you to initialize a form feed even if no job is
      currently being serviced by <nPrinter>.  This function requires operator
      rights <cPServer>.

   $EXAMPLES$
      Initialize the form feed on printer 0 on PSERVER:

      NNETPSFF('PSERVER',0)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSMTOF()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJBYT()
   $ONELINER$
      Determines the number of bytes already printed for an active job
   $SYNTAX$
      NNETPSJBYT(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJBYT() returns the number of bytes already printed within the
      current copy.  If an error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB BYTES
      NNETPSJBYT() allows you to determine the processing state of the current
      job for <nPrinter> on <cPServer>.

   $EXAMPLES$
      Determine the number of bytes printed for the current job of printer 0
      on PSERVER:

      IF (nBytes:=NNETPSJBYT('PSERVER',0))>=0
         ? nBytes,' bytes printed.'
      ELSE
         ? 'No job active or other error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSJPCO(), NNETPSJSIZ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJDSC()
   $ONELINER$
      Determines the description of the active job
   $SYNTAX$
      NNETPSJDSC(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> cDescription

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJDSC() returns the job description of the active job of
      <nPrinter>.  If an error occurs (for example, no job active), the
      function returns an empty string.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB DESCRIPTION
      NNETPSJDSC() allows you to determine the description of the active job
      of <nPrinter> on <cPServer>.  The job is already active, so the
      description cannot be modified.

   $EXAMPLES$
      Determine the description of the active job of printer 0 on PSERVER:

      ? NNETPSJDSC('PSERVER',0))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJDESC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJFRM()
   $ONELINER$
      Determines the form number for the active job
   $SYNTAX$
      NNETPSJFRM(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> nForm

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJFRM() returns the number of the form used for the active job of
      <nPrinter>.  If an error occurs (for example, no job active), the
      function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB FORM
      The job is already active, so the form number cannot be modified.

   $EXAMPLES$
      Determine the form number of the active job of printer 0 on PSERVER:

      IF (nForm:=NNETPSJFRM('PSERVER',0))>=0
         ? 'Form:',nForm
      ELSE
         ? 'No job active or other error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPFORMS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJFS()
   $ONELINER$
      Determines the file server of the active job
   $SYNTAX$
      NNETPSJDSC(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> cFileServer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can therefore depend on the specified file
      server.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJFS() returns the file server of the active job of  <nPrinter>.
      If an error occurs (for example, no active job), the function returns an
      empty string.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB FILE SERVER
      NNETPSJFS() allows you to determine the file server for the active job
      of <nPrinter> on <cPServer>.

   $EXAMPLES$
      Determine the file server for the active job of printer 0 on PSERVER:

      ? NNETPSJFS('PSERVER',0))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSJQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJNO()
   $ONELINER$
      Determines the number of an active job
   $SYNTAX$
      NNETPSJNO(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> nJob

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJNO() returns the job number of the active job of <nPrinter>.  If
      an error occurs (for example, no active job), the function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB NUMBER
      Internally, Netware uses job numbers to manage jobs within a queue.  The
      job number of an active job of <nPrinter> can be determined with
      NNETPSJNO().  The job number and queue name can be used to determine
      additional job information using the NNETJXXX() functions.

   $EXAMPLES$
      ■  Determine the job number of the active job of printer 0 on
         PSERVER:

         IF (nJob:=NNETPSJNO('PSERVER',0))>=0
            ? 'Job number:',nJob
         ELSE
            ? 'No job active or other error!'
         ENDIF

      ■  Determine the owner of the active job:

         nJob=NNETPSJNO('PSERVER',0)
         cQueue=NNETPSJQ('PSERVER',0)
         ? 'Owner: ',NNETJOWNER(cQueue,nJob)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETJLIST(), NNETPSJQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJPCO()
   $ONELINER$
      Determines the number of copies printed for the active job
   $SYNTAX$
      NNETPSJPCO(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> nCopies

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJPCO() returns the number of copies of the active job that have
      already printed on <nPrinter>.  If an error occurs (for example, no
      active job), the function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB PRINTED COPIES
      NNETPSJPCO() allows you to determine the processing state of the active
      job of <nPrinter> on <cPServer>.

   $EXAMPLES$
      Determine the number of printed copies for the active job of printer 0
      on PSERVER:

      IF (nCopies:=NNETPSJPCO('PSERVER',0))>=0
         ? nCopies,' copies printed.'
      ELSE
         ? 'No job active or other error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSJBYT(), NNETPSJTCO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJQ()
   $ONELINER$
      Determines the queue of the active job
   $SYNTAX$
      NNETPSJQ(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> cQueue

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJQ() returns the queue of the active job of <nPrinter>. If an
      error occurs (for example, no active job), the function returns an empty
      string.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB QUEUE
      NNETPSJQ() allows you to determine the print queue of the active job of
      <nPrinter> on <cPServer>.

   $EXAMPLES$
      Determine the queue of the active job of printer 0 on PSERVER:

      ? NNETPSJQ('PSERVER',0))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSJFS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJSIZ()
   $ONELINER$
      Determines the size of an active job
   $SYNTAX$
      NNETPSJSIZ(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJSIZ() returns the size of the active job of <nPrinter> on
      <cPServer> in bytes.  If an error occurs (for example, no active job),
      the function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB SIZE
      NNETPSJSIZ() allows you to determine the size of an active job.  In
      conjunction with NNETPSJBYT(), a relative value of characters already
      printed or characters to be printed can be calculated.

   $EXAMPLES$
      Determine the size of the active job of printer 0 on PSERVER:

      IF (nBytes:=NNETPSJSIZ('PSERVER',0))>=0
         ? nBytes,' bytes.'
      ELSE
         ? 'No job active or other error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSJBYT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJTCO()
   $ONELINER$
      Determines the total number of copies for an active job
   $SYNTAX$
      NNETPSJTCO(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> nCopies

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can therefore depend on the specified file
      server.  Your workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJTCO() returns the total number of copies of the active job that
      are printed on <nPrinter>.  If an error occurs (for example, no active
      job), the function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB TOTAL COPIES
      NNETPSJTCO() allows you to determine the total number of copies for an
      active job.  In conjunction with NNETPSJPCO(), a relative value of
      copies already printed or copies to be printed can be calculated.

   $EXAMPLES$
      Determine the total number of copies of the active job of printer 0 on
      PSERVER:

      IF (nCopies:=NNETPSJTCO('PSERVER',0))>=0
         ? nCopies,' copies.'
      ELSE
         ? 'No job active or other error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSJPCO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSJTXT()
   $ONELINER$
      Checks to see if an active job is a text job
   $SYNTAX$
      NNETPSJTXT(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> lText

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSJTXT() returns .T. if the active job of <nPrinter> on <cPServer>
      is a text job.  A return of .F. indicates a binary job.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER JOB TEXT
      NNETPSJTXT() allows you to determine whether the active job of
      <nPrinter> on <cPServer> is a text or binary job.

   $EXAMPLES$
      Determine the job type of the active job of printer 0 on PSERVER:

      IF NNETPSJTXT('PSERVER',0)
         ? 'Text job!'
      ELSEIF NNETPSERR()=0
         ? 'Binary job!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSLIN()
   $ONELINER$
      Logs in a print server to a file server
   $SYNTAX$
      NNETPSLIN(<cPServer>,<cPassword>,<cServer1>,[<cServer2>|
         <nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is logged
      in on <cServer1>.

      <cPassword>  Designates the password defined for <cPServer> on
      <cServer1>.

      <cServer1>  Designates the file server on which <cPServer> is logged
      in.

      <cServer2>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer2>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer2>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer2>.

   $RETURNS$
      NNETPSLIN() returns .T. if the function has been executed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER LOGIN
      To service a queue on a file server, a print server must be logged in on
      the file server.  NNETPSLIN() allows you to log in a print server on a
      file server (<cServer1>) after it has been started.  For a print server
      login, a password can be queried and then passed for <cPassword>.  An
      empty string ("") for <cPassword> must be passed if no password has been
      specified for <cPServer> on <cServer1>.

   $EXAMPLES$
      Log in the print server PSERVER on file server TOOLS1 (with password
      SECRET):

      IF NNETPSLIN('PSERVER','SECRET','TOOLS1')
         ? 'Log in successful!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSLOUT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSLOUT()
   $ONELINER$
      Logs out a print server from a file server
   $SYNTAX$
      NNETPSLOUT(<cPServer>,<cServer1>,[<lImmediate>]
         [<lJobMode>],[<cServer2>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is logged
      out from <cServer1>.

      <cServer1>  Designates the file server from which <cPServer> is
      logged out.

      <lImmediate>  Designates if the operation is executed immediately
      (.T.) or if active jobs are completed (.F.).  The default value is .F..

      <nJobMode>  Designates the mode of the job that will be active,
      according to the following table.  This parameter is only taken into
      account if <lImmediate> is designated .T..

      Table 27.7:  Job Modes
      <table>
          Value   CTPS.CH        Definition

          1       PSJ_RET2Q      Return job to queue
          2       PSJ_THROWAWAY  Discard job
         </table>

      The default value for <nJobMode> is 1.  To return the job to the queue,
      you must set its service restart flag (see NNETJFLAGS()).

      <cServer2>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer2>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer2>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer2>.

   $RETURNS$
      NNETPSLOUT() returns .T. if the function has been executed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER LOGOUT
      NNETPSLOUT() performs a logout of <cPServer> from <cServer1>.  After a
      successful logout, print queues on <cServer1> are no longer serviced by
      <cPServer>.  NNETPSLOUT() requires operator rights on <cPServer>.

   $EXAMPLES$
      Log out the print server PSERVER from file server TOOLS1 (make sure that
      the active jobs are completed):

      IF NNETPSLIN('PSERVER','TOOLS1')
         ? 'Logout successful!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSLIN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSMTOF()
   $ONELINER$
      Marks the top of the page on the print server printer
   $SYNTAX$
      NNETPSMTOF(<cPServer>,<nPrinter>,<cChar>|<nChar>
         [<cServer>|<nConId>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cChar>  Designates the character used to mark the top of page.

      <nChar>  Designates the ASCII code of <cChar>.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSMTOF() returns .T. if the function has been executed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER MARK TOP OF FORM
      NNETPSMTOF() allows you to mark the top of the page if no job is
      currently being processed by <nPrinter>.  The character to mark the top
      of the page can be passed as a character string (<cChar>) or a character
      code (<nChar>). On the print server, one line that contains the passed
      character is printed.  NNETPSMTOF() requires operator rights on
      <cPServer>.

   $EXAMPLES$
      Mark the top of page on printer 0 of PSERVER with one line containing
      "=" characters:

      NNETPSMTOF('PSERVER',0,"=")
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSFF()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSNMOD()
   $ONELINER$
      Determines the number of queue service modes
   $SYNTAX$
      NNETPSNMOD(<cPServer>,[<cServer>|<nConId>]) --> nModes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSNMOD() returns the number of queue service modes supported by
      <cPServer>.  If an error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER NUMBER OF MODES
      NNETPSNMOD() allows you to determine the number of queue service modes
      supported by <cPServer>.  The four standard modes are:  change forms as
      requested,  minimize form changes within a queue, avoid form changes,
      and minimize form change between queues.

   $EXAMPLES$
      Determine the number of queue service modes for print server PSERVER:

      ? NNETPSNMOD('PSERVER')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSPMOD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSNOTL()
   $ONELINER$
      Determines the list of notified objects for the print server printer
   $SYNTAX$
      NNETPSNOTL(<cPServer>,<nPrinter>,[<cServer>|<nConId>)
         --> aNoti

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSNOTL() returns an array with subarrays (two-dimensional array).
      Each subarray contains information about a file entry found.  For the
      structure of the subarrays, see the following table:

      Table 27.8:  NNETPSNOTL() Subarray Structure
      <table>
          Position     Metasymbol     CTPS.CH      Definition

          1            cServer        NL_SERVER    File server
          2            nObjName       NL_NAME      Object name
          3            nType          NL_TYPE      Object type
          4            nFirst         NL_FIRST     Time to the first message
          5            nNext          NL_NEXT      Time between messages
         </table>

      If an error occurs, the function returns an empty array.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER NOTIFY LIST
      For each print server printer, objects (normally users) that are
      notified if printer problems occur (printer offline, no paper) can be
      defined.  NNETPSNOTL() allows you to determine a list of the objects
      defined for <nPrinter>.

   $EXAMPLES$
      Determine the notified objects for printer 0 on print server PSERVER,
      and display the file server and the names of the objects found:

      #include "ctnet.ch"

      aObjs=NNETPSNOTL('PSERVER',0)
      FOR i=1 TO Len(aObjs)
         ? aObjs[i,NL_SERVER],aObjs[i,NL_NAME]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSANO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSNPRN()
   $ONELINER$
      Determines the number of print server printers
   $SYNTAX$
      NNETPSNPRN(<cPServer>,[<cServer>|<nConId>]) --> nPrinter

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSNPRN() returns the number of printers defined for <cPServer>.  If
      an error occurs, the function returns  -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER NUMBER OF PRINTERS
      NNETPSNPRN() returns the number of printers defined for <cPServer>.  The
      value returned includes printers that are directly connected and remote.

   $EXAMPLES$
      Determine the number of printers on print server PSERVER:

      ? NNETPSNMOD('PSERVER')
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSPFRM()
   $ONELINER$
      Sets or determines the form for the print server printer
   $SYNTAX$
      NNETPSPFRM(<cPServer>,<nPrinter>,[<nNewForm>],[<cServer>|
         <nConId>]) --> nForm

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <nNewForm>  Designates an optional parameter that must be passed to
      set a new form.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSPFRM() returns the form number of <nPrinter> on <cPServer>.  If an
      error occurs, the function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER PRINTER FORM
      NNETPSPFRM() allows you to set or determine the current form of
      <nPrinter> on <cPServer>.  The form number can be queried by users and
      operators; however, operator rights are required to set a new form
      number on <cPServer>.

   $EXAMPLES$
      ■  Determine the current form number of printer 0 on print server
         PSERVER:

         IF (nForm:=NNETPSPFRM('PSERVER',0))>=0
            ? 'Form:',nForm
         ELSE
            ? 'Error!'
         ENDIF

      ■  Set the form number for printer 0 on print server  PSERVER to
         1:

         IF NNETPSPFRM('PSERVER',0,1)>=0
            ? 'Form number set successfully!'
         ELSE
            ? 'Error!'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSJFRM()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSPJOB()
   $ONELINER$
      Checks to see if the print server printer is processing a job
   $SYNTAX$
      NNETPSPJOB(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> lJob

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSPJOB() returns .T. if <nPrinter> on <cPServer> is currently
      processing a job.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER PRINTER (HAS) JOB ?
      NNETPSPJOB() checks to see if a print server printer is currently
      processing a job.  This allows you to determine whether or not the
      printer is directly available.

   $EXAMPLES$
      Determine if printer 0 on print server printer PSERVER is currently
      processing a job:

      IF NNETPSPJOB('PSERVER',0)
         ? 'Printer is busy!'
      ELSEIF NNETPSERR()=0
         ? 'Printer available!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSERR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSPMOD()
   $ONELINER$
      Sets or determines the queue service mode
   $SYNTAX$
      NNETPSPMOD(<cPServer>,<nPrinter>,<nMode>,[<cServer>|
         <nConId>]) --> nMode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <nMode>  Designates an optional parameter that must be passed to set
      a new queue service mode for <nPrinter>.  For possible queue service
      modes see the description.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSPMOD() returns the queue service mode of <nPrinter> on <cPServer>.
      For possible service modes see the description.  If an error occurs, the
      function returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER PRINTER MODE
      For print server printers, various service modes regarding the form
      change are possible.  The following table shows the four standard queue
      service modes:

      Table 27.9:  Queue Service Modes
      <table>
          Value   CTPS.CH        Definition

          1       QSM_NEED       Change forms as requested
          2       QSM_MINQ       Minimize form change within a queue
          4       QSM_NEVER      Avoid form change
          8       QSM_MINACROSS  Minimize form change between queues
         </table>

   $EXAMPLES$
      ■  Determine the current queue service mode of printer 0 on print
         server PSERVER:

         IF (nMode:=NNETPSPMOD('PSERVER',0))>=0
            ? 'Queue service mode:',nMode
         ELSE
            ? 'Error!'
         ENDIF

      ■  Set the queue service mode for printer 0 on print server
         PSERVER to QSM_MINQ:

         #include "ctnet.ch"

         IF NNETPSPMOD('PSERVER',0,QSM_MINQ)>=0
            ? 'Queue service mode set successfully!'
         ELSE
            ? 'Error!'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSNMOD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSPNAM()
   $ONELINER$
      Determines the name of a print server printer
   $SYNTAX$
      NNETPSPNAM(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> cName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can therefore depend on the specified file
      server.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSPNAM() returns the name of <nPrinter> on <cPServer>.  If an error
      occurs, the function returns an empty string.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER PRINTER NAME
      In a print server, configuration names can be assigned to print server
      printers.  NNETPSPNAM() allows you to determine the name for a print
      server printer (<nPrinter>).

   $EXAMPLES$
      Determine the name of printer 0 on print server PSERVER:

      ? NNETPSPNAM('PSERVER',0)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSNPRN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSPROB()
   $ONELINER$
      Determines the cause of an error for print server printer
   $SYNTAX$
      NNETPSPROB(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> nProblem

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSPROB() returns a numeric value that specifies the cause of an
      error on <nPrinter> on <cPServer>.

      Table 27.10:  Return Values of NNETPSPROB()
      <table>
          Value   CTPS.CH        Definition

          -1                     Call error
          0       PPROB_NONE     No problem
          1       PPROB_OFFLINE  Printer is offline
          2       PPROB_NOPAPER  Paper out
         </table>

   $DESCRIPTION$
      NOVELL NET PRINT SERVER PRINTER PROBLEM
      With the aid of NNETPSPROB() applications can check to see if <nPrinter>
      on <cPServer> is ready.  For example, this allows you to display an
      error message before a print job is started.

   $EXAMPLES$
      Determine the cause of an error for printer 0 on print server PSERVER:

      #include "ctps.ch"

      nProb=NNETPSPROB('PSERVER',0)

      DO CASE
         CASE nProb=PPROB_NONE
            ? 'Ready!'
         CASE nProb=PPORB_OFFLINE
            ? 'Printer offline!'
         CASE nProb=PPROB_NOPAPER
            ? 'No paper!'
         OTHERWISE
            ? 'Error!'
      ENDCASE
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSPSTA()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSPSQ()
   $ONELINER$
      Determines the list of printers that service a queue
   $SYNTAX$
      NNETPSPSQ(<cPServer>,<cQueue>,[<cServer1>],[<cServer2>|
         <nConId>]) --> cPrinter

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <cQueue>  Designates a print queue.

      <cServer1>  Designates the file server of <cQueue>.  The default
      value designates the default server.

      <cServer2>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer2>.
      Therefore, the access rights can therefore depend on the specified file
      server.  Your workstation must be attached to <cServer2>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer2>.

   $RETURNS$
      NNETPSPSQ() returns a character string.  Each character (byte) indicates
      the number of a print server printer.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER PRINTERS SERVICING QUEUE
      NNETPSPSQ() determines the numbers of all the printers on <cPServer>
      that service <cQueue> on <cServer1>.  The list of printers is returned
      as a character string in which each character specifies a printer
      number.

   $EXAMPLES$
      Display a list that contains the printer number and printer name of all
      the printers on PSERVER that service QUEUE1 on the default server:

      cPrinters=NNETPSPSQ('PSERVER','QUEUE1')

      FOR i=1 TO Len(cPrinters)
         nNum:=Asc(SubStr(cPrinters,i,1)
         ? nNum,NNETPSPNAM('PSERVER',nNum)
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSPNAM(), NNETPSQL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSPSTA()
   $ONELINER$
      Queries the status of a print server printer
   $SYNTAX$
      NNETPSPSTA(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> nStatus

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can therefore depend on the specified file
      server.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSPSTA() returns a numeric value that specifies the current status
      of <nPrinter> on <cPServer>.

      Table 27.11:  Return Values of NNETPSPPSTA()
      <table>
          Value   CTPS.CH        Definition

          -1                     Call error
          0       PST_WAIT_JOB   Printer waiting for job
          1       PST_WAIT_FORM  Printer waiting for form
          2       PST_PRINT      Printer is processing job
          3       PST_PAUSED     Printer on hold
          4       PST_STOPPED    Printer stopped
          5       PST_MARK       Printer marking top of form
          6       PST_GO_DOWN    Printer ready for deinitialization
          7       PST_NOT_CON    Remote printer not connected
          8       PST_PRIVATE    Remote printer in private mode
         </table>

   $DESCRIPTION$
      NOVELL NET PRINT SERVER PRINTER STATUS
      With the aid of NNETPSPSTA(), applications can determine the status of
      <nPrinter> on <cPServer>.

   $EXAMPLES$
      Determine the status of printer 0 on print server PSERVER:

      #include "ctps.ch"

      nStat=NNETPSPSTA('PSERVER',0)

      DO CASE
         CASE nStat=PST_WAIT_JOB
            ? 'Printer waiting for job!'
         CASE nStat=PST_WAIT_FORM
            ? 'Printer waiting for form!'
         CASE nStat=PST_PRINT
            ? 'Printer is processing job!'
         CASE nStat=PST_PAUSED
            ? 'Printer on hold!'
         CASE nStat=PST_STOPPED
            ? 'Printer stopped!'
         CASE nStat=PST_MARK
            ? 'Printer is marking top of form!'
         CASE nStat=PST_GO_DOWN
            ? 'Printer ready for deinitialization!'
         CASE nStat=PST_NOT_CON
            ? 'Remote printer not connected!'
         CASE nStat=PST_PRIVATE
            ? 'Remote printer in private mode!'
         OTHERWISE
            ? 'Error!'
      ENDCASE
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSPROB()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSQL()
   $ONELINER$
      Determines the queues that are serviced by a print server printer
   $SYNTAX$
      NNETPSQL(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> aQueues

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can therefore depend on the specified file
      server.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSQL() returns an array with subarrays (two-dimensional array).
      Each subarray contains information about a serviced queue.  For the
      structure of the subarrays, see the following table:

      Table 27.12:  NNETPSQL() Subarray Structure
      <table>
          Position     Metasymbol     CTPS.CH      Definition

          1            cServer        QL_SERVER    File server
          2            cQName         QL_NAME      Queue name
          3            nPrior         QL_PRIOR     Queue priority
         </table>

      If an error occurs, the function returns an empty array.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER QUEUE LIST
      NNETPSQL() returns a list of all print queues that are serviced by
      <nPrinter> on <cPServer>.  The array also contains the name of queue's
      file server because a print server can access several file servers.

   $EXAMPLES$
      Determine the print queues for printer 0 on print server PSERVER, and
      display the queue's file server and name:

      #include "ctnet.ch"

      aQs=NNETPSQL('PSERVER',0)
      FOR i=1 TO Len(aQs)
         ? aQs[i,QL_SERVER],aQs[i,QL_NAME]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSPSQ()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSRRP()
   $ONELINER$
      Requests a remote printerÆs configuration information
   $SYNTAX$
      NNETPSRRP(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> aInfo

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSQL() returns a one-dimensional array that contains configuration
      information about the passed printer.  The elements of the array are
      defined in the table that follows.

      Table 27.13:  NNETPSRRP() Array Structure
      <table>
          Position     Metasymbol   CTPS.CH      Definition

          1            nType        RRP_TYPE     Printer type
          2            lInt         RRP_INT      Use interrupts
          3            nIRQ         RRP_IRQ      IRQ number
          4            nBuf         RRP_BUF      Rec. number of 512 byte buffers
          5            lXon         RRP_XON      Use Xon/XOff protocol
          6            nBaud        RRP_BAUD     Baud rate
          7            nData        RRP_DATA     Data bits
          8            nStop        RRP_STOP     Stop bits
          9            nParity      RRP_PARITY   Parity
          10           nSocket      RRP_SOCKET   Socket number for communication
                                                 with print server
         </table>

      For a list of possible remote printers, see the function NNETPSARP().
      The elements RRP_XON, RRP_BAUD, RRP_DATA, RRP_STOP, and RRP_PARITY are
      useful only if the remote printer is configured as serial printer.  The
      baud rate, stop bits, and parity are coded as numeric values:  0=300
      baud, 1=600 baud, 2=1200 baud, 3=2400 baud, 4=4800 baud, 5=9600 baud;
      0=0 stop bits, 1=1,5 stop bits, 2=1 stop bit; parity: 0=no, 1=even,
      2=odd.

      If an error occurs, the function returns an empty array.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER REQUEST REMOTE PRINTER
      Netware print servers are able to service printers that are connected to
      a workstation (remote printers).  NNETPSRRP() allows you to request a
      remote printer from a print server to emulate a remote printer from
      within a CA-Clipper application (see the sample program RPRINTER.PRG).

      For the emulation of a remote printer, the most important information
      within the return value is the socket number (RRP_SOCKET).  For the
      following setup of an SPX session, this socket number must be passed as
      target socket.

   $EXAMPLES$
      You can find a detailed example for the description of NNETPSRRP() on
      the CA-Clipper Tools disks under RPRINTER.PRG.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSARP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSSRM()
   $ONELINER$
      Sets the remote printer mode
   $SYNTAX$
      NNETPSSRM(<cPServer>,<nPrinter>,<lMode>,[<cServer>|
         <nConId>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <lMode>  Designates the remote mode for <nPrinter> on <cPServer>.
      If <lMode> is designated .F., the function selects the shared mode.  If
      <lMode> is designated .T., the function selects the private mode.

      <cServer> Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSSRM() returns .T. if the function has been executed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER REMOTE MODE
      Netware print servers are able to service printers that are connected to
      a workstation (remote printers).  A remote printer can operate in the
      shared or the private mode.  The default mode is the shared mode.  In
      the shared mode, the remote printer operates like a network printer that
      is directly connected to the print server.  In the private mode, the
      remote printer is used locally and cannot be used by the print server.
      NNETPSRM() allows you to select the mode of a remote printer.

   $EXAMPLES$
      Set printer 8 on print server PSERVER to the private mode:

      IF NNETPSRM('PSERVER',8,.T.)
         ? 'Printer 8 set to private mode!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSRRP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSSRVL()
   $ONELINER$
      Determines the file server for the print server
   $SYNTAX$
      NNETPSSRVL(<cPServer>,[<cServer>|<nConId>]) --> cServer

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSSRVL() returns a one-dimensional array.  The elements contain the
      names of the file servers on which <cPServer> is currently logged in.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER SERVER LIST
      NNETPSSRVL() allows you to determine all file servers on which
      <cPServer> is currently logged in.  <cPServer> must be logged in on a
      file server to access print queues on the file server.

   $EXAMPLES$
      Display a list of all the file servers on which PSERVER is logged in:

      aSrv=NNETPSSRVL('PSERVER')
      FOR i=1 TO Len(aSrv)
         ? aSrv[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSLIN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSSTAT()
   $ONELINER$
      Determines a print serverÆs status
   $SYNTAX$
      NNETPSSTAT(<cPServer>,[<cServer>|<nConId>]) --> nStatus

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSSTAT() returns the status of <cPServer>:

      Table 27.14:  Return Values of NNETPSSTAT()
      <table>
          Value   CTPS.CH        Definition

          -1                     Call error
          0       PSTAT_RUNNING  Normal operation mode
          1       PSTAT_GO_DOWN  Deinitialization phase
          2       PSTAT_DOWN     Deinitialized
         </table>

   $DESCRIPTION$
      NOVELL NET PRINT SERVER STATUS
      NNETPSSTAT() allows you to determine if <cPServer> is running in the
      normal operation mode or if its availability is going to end.

   $EXAMPLES$
      Determine and display the status of print server PSERVER:

      #include "ctps.ch"

      nStatus=NNETPSSTAT('PSERVER')
      DO CASE
         CASE nStatus=PSTAT_RUNNING
            ? 'Normal operation mode!'
         CASE nStatus=PSTAT_GO_DOWN
            ? 'Deinitialization phase!'
         CASE nStatus=PSTAT_DOWN
            ? 'Deinitialized!'
         OTHERWISE
            ? 'Error!'
      ENDCASE
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSDOWN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSTART()
   $ONELINER$
      Starts a print server printer
   $SYNTAX$
      NNETPSTART(<cPServer>,<nPrinter>,[<cServer>|<nConId>])
         --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSTART() returns .T. if the function has been executed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER (PRINTER) START
      NNETPSTART() can reactivate <nPrinter> on <cPServer> if <nPrinter> has
      been stopped by the Novell utility PCONSOLE or by NNETPSTOP().  This
      function requires operator rights for <cPServer>.

   $EXAMPLES$
      Stop and reactivate printer 0 on print server PSERVER:

      lSuccess=.T.
      lSuccess=lSuccess .AND. NNETPSTOP('PSERVER',0)
      lSuccess=lSuccess .AND. NNETPSTART('PSERVER',0)
      IF lSuccess
         ? 'Printer stopped and reactivated!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSTOP()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSTOP()
   $ONELINER$
      Stops a print server printer
   $SYNTAX$
      NNETPSTART(<cPServer>,<nPrinter>,[<nMode>],[<cServer>|
         <nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <nPrinter>  Designates the number of the printer on <cPServer>.
      Values between 0 and 15 are possible.

      <nMode>  Designates the currently active job mode.

      Table 27.15:  Job Modes
      <table>
          Value   CTPS.CH        Definition

          0       PSJ_HOLD       Stop job
          1       PSJ_RET2Q      Return job to queue
          2       PSJ_THROWAWAY  Discard job
         </table>

      The default value for <nMode> is 0, the stop job mode.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSTOP returns .T. if the function has been completed successfully.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER (PRINTER) STOP
      NNETPSTOP() allows you to stop <nPrinter> on <cPServer>.  In this state
      no additional print server outputs are processed on <nPrinter>.  By
      passing a value for <nMode>, you can specify what happens to a job that
      is currently being processed.  NNETPSTOP() requires operator rights for
      <cPServer>.

   $EXAMPLES$
      Stop printer 0 on print server PSERVER:

      IF NNETPSTOP('PSERVER',0)
         ? 'Printer 0 stopped!'
      ELSE
         ? 'Error'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSTART()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSTYPE()
   $ONELINER$
      Determines a print serverÆs type
   $SYNTAX$
      NNETPSTYPE(<cPServer>,[<cServer>|<nConId>]) --> nType

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSTYPE() returns the type of <cPServer>:

      Table 27.16:  Return Values of NNETPSTYPE()
      <table>
          Value   CTPS.CH        Definition

          -1                     Call error
          1       PSTYP_DOS      Dedicated DOS print server
          2       PSTYP_NLM      Netware loadable module
          3       PSTYP_FSVAP    VAP on file server
          4       PSTYP_BRGVAP   VAP on bridge
         </table>

   $DESCRIPTION$
      NOVELL NET PRINT SERVER TYPE
      Netware print servers are available for various platforms.  A print
      server can operate on a dedicated DOS station as an NLM on a Netware 3.x
      file server, as a VAP on a Netware 2.x file server, or as a VAP on a
      bridge.  NNETPSTYPE() allows you to determine the type of <cPServer>.

   $EXAMPLES$
      Determine and display the type of print server PSERVER:

      #include "ctps.ch"

      nType=NNETPSTYPE('PSERVER')
      DO CASE
         CASE nType=PSTYP_DOS
            ? 'Dedicated DOS'
         CASE nType=PSTYP_NLM
            ? 'Netware loadable module'
         CASE nType=PSTYP_FSVAP
            ? 'File server VAP'
         CASE nType=PSTYP_BRGVAP
            ? 'Bridge VAP'
         OTHERWISE
            ? 'Error!'
      ENDCASE
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSVER()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPSVER()
   $ONELINER$
      Determines a print serverÆs version
   $SYNTAX$
      NNETPSVER(<cPServer>,[<cServer>|<nConId>]) --> cVersion

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cPServer>  Designates the name of the print server that is
      accessed.

      <cServer>  Designates the name of the file server used to access
      <cPServer>.  The print server checks login information on <cServer>.
      Therefore, the access rights can depend on the specified file server.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPSVER() returns a character strings that contains the version of the
      print server in the form "Main_version.Sub_version.Revision_number".  If
      an error occurs, the function returns an empty string.

   $DESCRIPTION$
      NOVELL NET PRINT SERVER VERSION
      NNETPSVER() allows you to determine the version of a print server.

   $EXAMPLES$
      Determine the version of print server PSERVER:

      ? NNETPSVER('PSERVER')            // For example "1.2.1"
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPSTYPE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Semaphores
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      A semaphore controls certain states: for example, the states between two
      applications that run on different workstations.  To enable all stations
      to access existing semaphores, each Netware file server has a table
      available to manage these semaphores.

      Semaphores can be interpreted as variables kept on the file server.
      Each semaphore is assigned a name when it is created.  A semaphore name
      can be up to 127 characters long and is not case sensitive.  An
      application can access a semaphore by opening the semaphore with its
      name (NNETSEMOPN()).

      A semaphore can be opened by any number of workstations.  For each
      workstation, the semaphore has the same value.  The semaphore value
      cannot be modified; however, by using specific functions it can be
      incremented (NNETSEMSNG()) or decrements (NNETSEMWAI())
      by 1.

      Each semaphore is assigned information in addition to the semaphore
      value.  For each semaphore, the file server counts the number of
      stations currently accessing the semaphore.  This information can be
      determined with the function NNETSEMOPC().  For example, a semaphore
      named after an application can be used to limit a resource to this
      application.

      Semaphores are often used to implement logical lockings for any kind of
      resource.  A semaphore is assigned to each resource.  Before the
      resource is accessed, the application tries to decrement the semaphore's
      value by one (NNETSEMWAI()).  If the resulting value is negative, the
      resource is locked by another station.  When an application is finished
      using a semaphore's resource, the function NNETSEMSNG() must be called
      to increment the semaphore's value.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSEMCLO()
   $ONELINER$
      Closes a semaphore
   $SYNTAX$
      NNETSEMCLO(<nHandle>,[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the semaphore handle that is returned by
      NNETSEMOPN() when the semaphore is opened.

      <cServer>  Designates the name of the file server on which <nHandle>
      has been created.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID for your workstation on
      <cServer>.

   $RETURNS$
      NNETSEMCLO() returns .T. if the semaphore specified by <nHandle> has
      been closed successfully.  If an error occurs (for example, if the
      handle is invalid), the function returns .F..

   $DESCRIPTION$
      NOVELL NET SEMAPHOR CLOSE
      NNETSEMCLO() allows you to close a semaphore that is no longer needed.
      The semaphore is specified by a handle.  If the closing workstation is
      the only workstation using the semaphore, the related file server
      removes the semaphore from its semaphore table.

   $EXAMPLES$
      Open and close semaphore:

      nHandle=NNETSEMOPN("superacc")
      NNETSEMCLO(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSEMOPN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSEMOPC()
   $ONELINER$
      Determines the number of stations that have opened a particular semaphore
   $SYNTAX$
      NNETSEMOPC(<nHandle>,[<cServer>|<nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the semaphore handle that is returned by
      NNETSEMOPN() when the semaphore is opened.

      <cServer>  Designates the name of the file server on which <nHandle>
      has been created.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID for your workstation on
      <cServer>.

   $RETURNS$
      NNETSEMOPC() returns the number of stations that have opened the
      semaphore specified by <nHandle>.  If an error occurs (for example, if
      the handle is invalid), the function returns -1.

   $DESCRIPTION$
      NOVELL NET SEMAPHOR OPEN COUNT
      NNETSEMOPC() allows you to determine the number of stations currently
      accessing a specific semaphore.  The semaphore is specified by a handle.
      The file server manages two values for each semaphore.  This function
      determines the number of stations that have opened <nHandle>.  This
      information has nothing to do with the semaphore's value.

   $EXAMPLES$
      ■  Open semaphore TEST and determine the number of stations that
         have also opened this semaphore:

         nHandle=NNETSEMOPN("test")
         ? "Number of stations:", NNETSEMOPC(nHandle)

      ■  The evaluation of the return value of  NNETSEMOPC() in an "if"
         statement allows you to limit the access to a semaphore's resource.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSEMVAL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSEMOPN()
   $ONELINER$
      Opens and initializes a semaphore
   $SYNTAX$
      NNETSEMOPN(<cName>,[<nValue>],[<cServer>|<nConId>]),
         --> nHandle

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the name of the semaphore that is opened.

      <nValue>  Designates a start value between -128 and 127 for the
      semaphore <cName>.  The default value is 1.  The file server accepts the
      assignment only if <cName> is created by the function call.

      <nHandle>  Designates the semaphore handle that has been returned by
      NNETSEMOPN() when the semaphore is opened.

      <cServer>  Designates the name of the file server on which <cName>
      is created.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID for your workstation on
      <cServer>.

   $RETURNS$
      NNETSEMOPN() returns the handle of the semaphore that has been opened.
      The handle is used by the file server to manage the semaphores.  If an
      error occurs, the function returns 0.

   $DESCRIPTION$
      NOVELL NET SEMAPHOR OPEN
      NNETSEMOPN() allows you to open an existing semaphore or to create a new
      semaphore.  If the specified semaphore does not exist on the file
      server, the semaphore is created and entered into the file server's
      semaphore table.  The new semaphore can be assigned a start value by
      passing <nValue>.

      The function returns the handle used by the file server for the
      semaphore <cName>.  Handles are used to save variables because they are
      needed as identification characteristics for other operations.  Once a
      semaphore has been opened successfully, it is exclusively addressed with
      the handle returned by NNETSEMOPN().

   $EXAMPLES$
      ■  Create semaphore SUPERACC, and check to see if the semaphore
         has been opened successfully with the handle:

         nHandle=NNETSEMOPN("superacc")
         IF nHandle=0
            ? 'Error during opening the semaphore!'
         ENDIF

      ■  Create semaphore TEST and assign a start value of  3, if it
         does not already exist:

         nHandle=NNETSEMOPN("test",3)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSEMCLO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSEMSGN()
   $ONELINER$
      Increments a semaphore
   $SYNTAX$
      NNETSEMSGN(<nHandle>,[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the semaphore handle that is returned by
      NNETSEMOPN() when the semaphore is opened.

      <cServer>  Designates the name of the file server on which <nHandle>
      has been created.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID for your workstation on
      <cServer>.

   $RETURNS$
      NNETSEMSGN() returns .T. if the semaphore has been incremented
      successfully.  If an error occurs (for example, if the handle is
      invalid), the function returns .F..

   $DESCRIPTION$
      NOVELL NET SEMAPHOR SIGNAL
      With NNETSEMSGN(), a station signal is completed using a semaphore's
      <nHandle> resource.  The semaphore is specified by a handle.  Another
      station waiting for the semaphore can access the semaphore if
      NNETSEMSGN() has been executed successfully.

   $EXAMPLES$
      Open, lock, and release the semaphor:

      nHandle=NNETSEMOPN('Test')
      IF NNETSEMWAI(nHandle)
         // Execute action
         ...
         // Release semaphore
         NNETSEMSGN(nHandle)
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSEMWAI()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSEMVAL()
   $ONELINER$
      Determines a semaphore's value
   $SYNTAX$
      NNETSEMVAL(<nHandle>,[<cServer>|<nConId>]) --> nValue

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the semaphore handle that is returned by
      NNETSEMOPN() when the semaphore is opened.

      <cServer>  Designates the name of the file server on which <nHandle>
      has been created.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID for your workstation on
      <cServer>.

   $RETURNS$
      NNETSEMVAL() returns the current value of the semaphore <nHandle>.  If
      an error occurs (for example, if the handle is invalid), the function
      returns -1.

   $DESCRIPTION$
      NOVELL NET SEMAPHOR VALUE
      NNETSEMVAL() allows you to determine the current value of a semaphore.
      The semaphore is specified by a handle.  The file server manages two
      values for each semaphore.  This function determines the semaphore's
      value.  This information has nothing to do with the number of stations
      that have opened <nHandle>.

   $EXAMPLES$
      Open semaphore TEST, and determine its current value:

      nHandle=NNETSEMOPN("test")
      ? 'Value:',NNETSEMVAL(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSEMOPC()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSEMWAI()
   $ONELINER$
      Decrements a semaphore
   $SYNTAX$
      NNETSEMWAI(<nHandle>,[<nTimeout>],
         [<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the semaphore handle that is returned by
      NNETSEMOPN() when the semaphore is opened.

      <nTimeout>  Designates a time period in 1/18 seconds that
      NNETSEMWAI() must wait if the semaphore <nHandle> cannot be locked
      successfully.  The default value is 0.5 seconds (9).

      <cServer>  Designates the name of the file server on which <nHandle>
      has been created.  Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID for your workstation on
      <cServer>.

   $RETURNS$
      NNETSEMWAI() returns .T. if the semaphore has been locked successfully
      (the semaphore's value is greater than 0).  If the semaphore has not
      been locked successfully (the semaphoreÆs value is equal to 0), the
      function returns .F..

   $DESCRIPTION$
      NOVELL NET SEMAPHOR WAIT
      NNETSEMWAI() tries to lock a semaphore.  The semaphore is specified by a
      handle.  NNETSEMWAI() decrements the value of the semaphore <nHandle> by
      1.  A semaphore is locked if the value is greater than or equal to 0
      after it decrements..  In this case, NNETSEMWAI() returns .T..  If the
      value is negative, NNETSEMWAI() waits for a specific time period.  If
      the value does not become positive within the specified time period,
      NNETSEMWAI() resets the value to its start value and returns .F.. The
      time period is calculated by multiplying  <nTimeout>  with 1/18 seconds.

   $EXAMPLES$
      Open the semaphore, and then try to lock the semaphore:

      nHandle=NNETSEMOPN('TEST')
      IF NNETSEMWAI(nHandle)
         ? 'Semaphore locked successfully!'
      ELSE
         ? 'Semaphor could not be locked!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSEMSGN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Transition Tracking
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      <b>Novell Transaction Tracking System (TTS)</b>

       This chapter provides functions for the use of the TTS within a
       CA-Clipper application.  The use of the TTS within a CA-Clipper
       application requires more than start and termination or cancellation of
       a transaction with the related CA-Clipper Tools functions.  With regard
       to the architecture, the application must be oriented to the specifics
       of TTS.  The TTS takes into consideration only files managed on a server
       volume.

       Transaction tracking occurs only on the files that have been marked as
       transactional.  The transactional bit is an extended file attribute that
       can be set with the Novell utility FLAG.EXE or with the related
       CA-Clipper Tools function NNETEXTATT().  All files related to a .DBF
       file, (.NTX, .DBT) must also be marked as transactional.

       The time between the start and the termination or cancellation of a
       transaction should be as short as possible.  Avoid direct entries into
       database fields.  Use memory variables for data input and then update
       the database within a transaction.

       The reason for minimizing the transaction time is a characteristic of
       the Netware operating system that cannot be influenced by the
       application.  When data in a file is modified, Netware physically locks
       the affected file area.  In contrast to a logical locking with RLock(),
       the affected data cannot be read as long as the transaction is
       incomplete.  If the transaction has been terminated successfully, the
       database record is updated.  If the transaction has been interrupted,
       the record is reset to the previous value.  A successful read access by
       another workstation could lead to fatal logical errors.  The physical
       lock is removed automatically after the transaction has been completed
       or canceled.  If a workstation tries to access a physically locked area,
       CA-Clipper causes an ACCESS DENIED error message and evaluates the error
       block.  Normally, this results in a branch into the error recovery
       routine.  An error message box is displayed, and the user can cause a
       repetition of the operation that failed.  The error message text can be
       adapted to the running transaction.  However, the problem is that from
       the beginning the application is not able to determine whether the
       ACCESS DENIED error results from a running transaction or another error
       source.  Therefore, an application using the TTS should have a mechanism
       available that allows it to determine if a transaction is active for a
       specified group of files or not.  Using Netware semaphores, for example,
       allows you to check to see if a transaction is active, either during the
       error recovery or before a file is accessed.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDISTTS()
   $ONELINER$
      Turns off the Transaction Tracking System (TTS)
   $SYNTAX$
      NNETDISTTS([<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDISTTS() returns .T. if the TTS of the specified file server has
      been turned off successfully.  If an error occurs (for example,
      insufficient rights), the function returns .F..

   $DESCRIPTION$
      NOVELL NET DISABLE TRANSACTION TRACKING SYSTEM
      NNETDISTTS() allows you to temporarily turn off the TTS on a file
      server.  Console rights are required to turn off the TTS with
      NNETDISTTS().

   $EXAMPLES$
      Turn off the TTS on the default server:

      IF NNETDISTTS()
         ? 'TTS turned off successfully!'
      ELSE
         ? 'Error!
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETENTTS(), NNETISTTS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETENTTS()
   $ONELINER$
      Activates the Transaction Tracking System (TTS)
   $SYNTAX$
      NNETENTTS([<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETENTTS() returns .T. if the TTS has been activated successfully.  If
      an error occurs (for example, insufficient rights), the function returns
      .F..

   $DESCRIPTION$
      NOVELL NET ENABLE TRANSACTION TRACKING SYSTEM
      NNETENTTS() allows you to activate the TTS on the file server if it has
      been turned off with NNETDISTTS().  Console rights are required to
      activate the TTS.

   $EXAMPLES$
      Activate the TTS on file server TOOLS1:

      NNETENTTS('TOOLS1')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETDISTTS(), NNETISTTS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETISTTS()
   $ONELINER$
      Checks for the availability of the Transaction Tracking System (TTS)
   $SYNTAX$
      NNETISTTS([<lMode>],[<cServer>|<nConId>]) --> lAvailable

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <lMode>  Designates the test mode of NNETISTTS().  If .F. is passed,
      NNETISTTS() checks for the general availability of the TTS.   The
      default value is .F..  If .T. is passed, NNETISTTS() checks to see if an
      available TTS is activated or not.

      <cServer> Designates the name of the file server that is used.  Your
      workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETISTTS() returns .T. if the TTS is available (<lMode>=.F.) or
      activated (<lMode>=.T.).

   $DESCRIPTION$
      NOVELL NET IS TRANSACTION TRACKING SYSTEM
      NNETISTTS() allows applications using the TTS to check to see if the TTS
      is available or currently activated.

   $EXAMPLES$
      ■  Check for the availability of the TTS on the default server:

         IF NNETISTTS()
            ? 'TTS available!'
         ELSE
            ? 'TTS not available!'
         ENDIF

      ■  Check to see if the TTS is currently activated:

         IF NNETISTTS(.T.)
            ? 'TTS activated!'
         ELSE
            ? 'TTS not activated!'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETDISTTS(), NNETTTSBEG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETTTSAB()
   $ONELINER$
      Aborts a running transaction
   $SYNTAX$
      NNETTTSAB([<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer> Designates the name of the file server that is used.
      Your workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETTTSAB() returns .T. if the current transaction of <cServer> has been
      aborted.  If an error occurs, the function returns .F..

   $DESCRIPTION$
      NOVELL NET TRANSACTION TRACKING SYSTEM ABORT
      NNETTTSAB() allows you to abort the active transaction (rollback).  All
      modifications performed by the current workstation in flagged,
      transactional files on <cServer> since the start of the transaction with
      NNETTTSBEG() become invalid.  For example, NNETTTSAB() can be called if
      a successful termination of the transaction is impossible.  NNETTTSAB()
      removes all file lockings of files affected by the transaction.

   $NOTES$
      ■  When you use the Transactional Tracking System (TTS), always
         take into account that other stations might not be able to read files
         attached by the transaction (see the Introduction to this chapter).

   $EXAMPLES$
      Abort the transaction if the available disk space is too small:

      BEGIN SEQUENCE
         NNETTTSBEG()
         //
         // Data manipulation
         //
         IF DiskSpace() < 50000
            BREAK
         ENDIF
         //
         // Data manipulation
         //
         NNETTTSEND()
      RECOVER
         NNETTSAB()
      END
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETTTSEND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETTTSBEG()
   $ONELINER$
      Starts an explicit transaction
   $SYNTAX$
      NNETTTSBEG([<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer> Designates the name of the file server that is used.  Your
      workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETTTSBEG() returns .T. if a transaction on <cServer> has been opened
      successfully.  If an error occurs, the function returns .F..

   $DESCRIPTION$
      NOVELL NET TRANSACTION TRACKING SYSTEM BEGIN
      A call of NNETTTSBEG() starts an explicit transaction on <cServer>.
      After a transaction has been started, each write access to a marked,
      transactional file (the extended attribute transactional is set) is
      protocolled and becomes valid if the transaction is terminated.  During
      a running transaction, all file modifications can be undone.  If a
      failure occurs during a transaction (for example, a workstation crash),
      the Transactional Tracking System (TTS) backs up the transaction
      immediately.

      Only one transaction can be active per workstation.  This transaction
      includes all transactional files into which the data is written.

      A file on a server volume can be marked 'transactional' with
      NNETEXTATT().

   $NOTES$
      ■  When you use the TTS, always take into account that other
         stations might not be able to read files attached by the transaction
         (see the Introduction to this chapter).

   $EXAMPLES$
      Mark the file CLIENT.DBF as transactional, and start an explicit
      transaction:

      #include "ctnnet.ch"

      NNETEXTATT('CLIENT.DBF',EXA_TTS)

      IF .NOT. NNETTTSBEG()
         ? 'Transaction could not be started!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETTTSAB(), NNETTTSEND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETTTSEND()
   $ONELINER$
      Terminates a transaction
   $SYNTAX$
      NNETTTSEND([<cServer>|<nConId>]) --> nTransNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server that is used.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETTTSEND() returns the transaction number.  If the error occurs, the
      function returns -1.

   $DESCRIPTION$
      NOVELL NET TRANSACTION TRACKING SYSTEM END
      A call of NNETTTSEND() validates all write accesses to flagged,
      transactional files since the start of the transaction (NNETTTSBEG()).
      Before the end of a transaction, a buffer commit is executed.  At the
      end of a transaction, the file server assigns a transaction number, that
      can be used to determine when a transaction has been written
      successfully.

   $NOTES$
      ■  When you use the Transactional Tracking System (TTS), always
         take into account that other stations might not be able to read files
         attached by the transaction (see the Introduction to this chapter).

   $EXAMPLES$
      The following example demonstrates a typical transaction.  The
      transaction is embedded in a begin sequence structure.  If no problems
      occur, the transaction is completed normally at the end of the
      structure.  If problems do occur, a break causes a branch into the
      recover routine, where the transaction is undone by NNETTTSAB().

      BEGIN SEQUENCE
         NNETTTSBEG()
         //
         // Data manipulation
         //
         IF DiskSpace() < 50000
            BREAK
         ENDIF
         //
         // Data manipulation
         //
         NNETTTSEND()
      RECOVER
         NNETTSAB()
      END
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETTTSAB(), NNETTTSBEG()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETTTSSTA()
   $ONELINER$
      Determines the transaction status after completion
   $SYNTAX$
      NNETTTSSTA(<nTransNumber>,[<cServer>|<nConId>])
          --> lWritten

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nTransNumber>  Designates a transaction number, which has been
      returned by NNETTTSEND() at the end of a transaction.

      <cServer> Designates the name of the file server that is used.  Your
      workstation must be attached to <cServer>.

      <nConId> Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETTTSSTA() returns .T. if a terminated transaction has been written
      completely.  If the terminated transaction has not been written
      completely, the function returns .F..

   $DESCRIPTION$
      NOVELL NET TRANSACTION TRACKING SYSTEM STATUS
      A few seconds after a transaction has been terminated by NNETTTSEND(),
      Netware starts writing the transaction.  NNETTTSSTA() allows you to
      determine if a transaction that has been completed successfully is
      already written.  The first parameter that is passed contains the
      transaction number that has been returned by NNETTTSEND().

   $NOTES$
      ■  When you use the Transaction Tracking System (TTS), always
         take into account that other stations might not be able to read files
         attached by the transaction (see the Introduction to this chapter).

   $EXAMPLES$
      Terminate the transaction, and wait until the transaction has been
      written completely:

      nTrans=NNETTTSEND()

      WHILE !NNETTTSSTA(nTrans)
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETTTSEND()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Miscellaneous Functions
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      This chapter contains some useful functions that do not belong in any
      other chapter of network functions.  The functions HexToStr() and
      StrToHex() are not network functions, but these functions have been
      included in CA-Clipper Tools specifically for working with internet
      addresses that are returned or are required by functions such as
      NNETADR() or IPXOPEN().  The function NNETVER() is very useful if you
      are developing applications that access Netware 2.2 and Netware 3.11
      servers because the behavior of some CA-Clipper Tools functions depends
      on the Netware version used (for example, NNETRIGHTS(), NNETPURGE()).
      Other functions are available for only one Netware version (for example,
      NNETSNDLOG(), NNETSALLST()).
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      HexToStr()
   $ONELINER$
      Converts a hexadecimal string into a byte sequence
   $SYNTAX$
      HexToStr(<cHex>) --> cBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cHex>   Designates a character string of which two characters are
      recognized as a hexadecimal form of a byte.  <cHex> can contain only the
      characters "0" to "9" and "A" to "F".

   $RETURNS$
      HexToStr() returns a character string that contains a byte sequence in
      which each byte corresponds to two characters of its hexadecimal form.
      The return value is half as long as <cHex>.

   $DESCRIPTION$
      HexToStr() is useful when working with the internet addresses that are
      required in conjunction with the IPX/SPX functions of Point To Point
      communication.

   $EXAMPLES$
      Convert the hexadecimal string into a byte sequence:

      ? HexToStr('4130')   // "A0"
   $PLATFORMS$
      DOS
   $SEEALSO$
      StrToHex()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETDOWN()
   $ONELINER$
      Shuts down the file server
   $SYNTAX$
      NNETDOWN([<lMode>],[<cServer>|<nConId>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <lMode>  Designates whether  the file server is shut down only if
      the current workstation is the only logged in station (.F.) or if the
      server is shut down for all logged in stations (.T.).  The default value
      is .F..

      <cServer>  Designates the name of the file server that is used.
      Your workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETDOWN() returns .T. if the down process has been established.  If an
      error occurs, the function returns .F..

   $DESCRIPTION$
      NOVELL NET DOWN
      NNETDOWN() allows you to shut down a file server.

      Important!  If the parameter <lMode> is designated .T., all logged
      in stations are logged out immediately.  Data that is still in the
      buffer cannot be saved.

      This function requires supervisor rights on the related file server.

   $EXAMPLES$
      ■  Attempt to shut down the default file server:

         IF NNETDOWN()
            ? 'Successful!'
         ELSE
            ? 'Error'
         ENDIF

      ■  Wait until the server can be shut down safely:

         WHILE .NOT. NNETDOWN()
         ENDDO
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETERROR()
   $ONELINER$
      Returns the error most recently encountered by a Novell function
   $SYNTAX$
      NNETERROR() --> nErrorCode

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETERROR() returns the error that occurred most recently on the network
      as a numeric value.

   $DESCRIPTION$
      NOVELL NET ERROR
      This function returns the code for the error that occurred most recently
      in conjunction with NNETXXX() functions.  However, this error did not
      necessarily occur in the function most recently called.  All the
      possible error codes are in Appendix C.

   $EXAMPLES$
      Determine the last error that occurred:

      ? NNETERROR()         // e.g. 254
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETINFO()
   $ONELINER$
      Returns the information string of the Netware in use
   $SYNTAX$
      NNETINFO() --> cInfo

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETINFO() returns an information string to the Novell network software
      in use on the default file server.  The return has a maximum of 512
      characters.

   $DESCRIPTION$
      NOVELL NET INFO
      This function can call an information string contained in Novell network
      software.  This information always relates to the default file server.
      For example, the character string contains specifications regarding the
      company that sold the software being used.  This can be of particular
      interest for OEM users.

   $EXAMPLES$
      Display the information string:

      ? NNETINFO()         // String of up to 512 characters
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETVER()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSDATE()
   $ONELINER$
      Queries the Novell file server date
   $SYNTAX$
      NNETSDATE() --> dServerDate

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETSDATE() returns the default file server date.

   $DESCRIPTION$
      NOVELL NETSERVER DATE
      This function allows you to query the current default file server date.
      This date is then available in the corresponding date format under
      CA-Clipper.  This allows all applications to synchronize their dates
      within a Novell network.

   $EXAMPLES$
      ■  Query the default server date:

         ? NNETSDATE()         // e.g. 04/01/91

      ■  Pass the date with an AT to the CMOS-RAM:

         SetDate(NNETSDATE(), IsAt())
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETSTIME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSERNO()
   $ONELINER$
      Determines the Netware serial number
   $SYNTAX$
      NNETSERNO([<cServer>|<nConId>]) --> cSerNo

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server used.  Your
      workstation must be attached to <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETSERNO() returns a 12-character string that contains the serial
      number of the Netware on <cServer>.

   $DESCRIPTION$
      NOVELL NET SERIAL NUMBER
      NNETSERNO() allows you to determine the Netware serial number.  The
      number can be used to limit the usage of an application to a specific
      network.

   $NOTES$
      ■  Certain subversions of Netware prohibit the query of the
         serial number.  In this case, NNETSERNO() returns an empty string.

   $EXAMPLES$
      Display the Netware serial number of the default server:

      ? NNETSERNO()
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSFTLVL()
   $ONELINER$
      Determines the System Fault Tolerance (SFT) level of the Netware in use
   $SYNTAX$
      NNETSFTLVL() --> nSFTLevel

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETSFTLVL() returns the System Fault Tolerance (SFT) level of the
      Netware version on the default file server.

   $DESCRIPTION$
      NOVELL NET SYSTEM FAULT TOLERANCE LEVEL
      This function allows you to determine if a System Fault Tolerant version
      of Netware is available on the server, and on what level it is working.

   $EXAMPLES$
      Determine the SFT level:

      ? NNETSFTLVL            // e.g. 1
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETVER()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSPSTAT()
   $ONELINER$
      Determines the status of a server printer
   $SYNTAX$
      NNETSPSTAT(<nServerPrinter>) --> nPrinterStatus

      Netware: 2.2 only

   $ARGUMENTS$
      <nServerPrinter>  Designates one  of the five possible server
      printers for which the status is determined.  Values from 0 to 4 are
      valid.

   $RETURNS$
      NNETSPSTAT() returns the following status codes:

      Table 30.1:  Status Coding for Server Printer
      <table>
          Code    Definition

          0    Server printer ready (according to the server!)
          1    Server printer off-line
          2    Server printer paused from server console
          3    Server printer off-line and paused at server console
          -1   No corresponding printer available on server
         </table>

   $DESCRIPTION$
      NOVELL NETWORK SERVER PRINTER STATUS
      With NNETSPSTAT(), you can determine if a particular printer on the
      default server is currently online or offline.  If you receive a return
      value that is greater than or equal to 2, then the designated printer
      has been paused from the server console.

      If there is no corresponding printer on the default server, the function
      returns -1.

   $NOTES$
      ■  Further explanations regarding the returned values of 2 or 3
         can be found in the Novell Netware documentation, Versions 2.1 and
         later (in the Console Reference manual under Stop Printer).

   $EXAMPLES$
      ■  Determine the status of server printer 0:

         ? NNETSPSTAT(0)                  // 0  Printer online

      ■  Determine the status of server printer 4:

         ? NNETSPSTAT(4)                  // -1  No printer available
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNetwork()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETSTIME()
   $ONELINER$
      Queries the time on a Novell file server
   $SYNTAX$
      NNETSTIME() --> cServerTime

      Netware: 2.2 and 3.11

   $RETURNS$
      NNETSTIME() returns the default file server clock time in the format
      "HH:MM:SS".

   $DESCRIPTION$
      NOVELL NET SERVER TIME
      With NNETSTIME(), you can determine the clock time on the default file
      server.  The time, which is returned in the format "HH:MM:SS", can be
      passed with SetTime() to DOS and with ATs to the CMOS-RAM.  In this way,
      all applications within a network can be synchronized with regard to the
      clock time.

   $EXAMPLES$
      ■  Query the clock time of the default file server:

         ? NNETSTIME()                     // e.g. "10:28:30"

      ■  Pass the clock time with an AT to CMOS-RAM:

         SetTime(NNETSTIME(), IsAt())
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETSDATE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETVER()
   $ONELINER$
      Determines the version of the Netware in use
   $SYNTAX$
      NNETVER([<cDrive>]) --> cVersion

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDrive>  Designates a drive.  If this parameter is used, the
      returned version number is related to the file server to which the
      designated drive is mapped.

      ()  When called without a parameter, the version number of the default
      file server is returned.

   $RETURNS$
      NNETVER() returns the Novell version number in the format "N.NN".

   $DESCRIPTION$
      NOVELL NETWORK VERSION
      The function returns the version number of the Novell network software
      being used.  If no disk drive is specified, the version number is
      related to the default file server.  With a drive specification, the
      version number depends on the file server to which the disk drive is
      mapped.  The drive specification was taken into account because
      different drives can be mapped to different file server versions.

   $EXAMPLES$
      Display the version number:

      ? NNETVER()                   // e.g. 2.15
      ? NNETVER("T:")               // e.g. 3.01
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETSETSRV(), NNETSFTLVL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNetwork()
   $ONELINER$
      Determines whether or not a Novell network is active
   $SYNTAX$
      NNetwork() --> lNovellNetActive

      Netware: 2.2 and 3.11

   $RETURNS$
      NNetwork() returns .T. when you are working in a Novell network.

   $DESCRIPTION$
      NOVELL NETWORK
      With NNetwork(), you can determine if you are working with a Novell
      network.  If so, the NNETVER() function can determine the related
      version.

   $NOTES$
      ■  This function only tests to see if a Novell shell (requestor)
         has been loaded.

   $EXAMPLES$
      Determine if there a Novell network, version => 2.0/ELS I that is
      active:

      IF NNetwork()
         IF NNETVER() >= "2.0"
            NNETCAPBEG(1)                     // Start capture
         ENDIF
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETVER(), NNETINFO(), NNETSFTLVL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      StrToHex()
   $ONELINER$
      Converts a byte sequence into hexadecimal form
   $SYNTAX$
      StrToHex(<cBytes>) --> cHex

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cBytes>   Designates a character string that is recognized as a
      byte sequence.

   $RETURNS$
      StrToHex() returns a character string that contains each byte
      (character) of the passed string in its two-character, hexadecimal form.
      The returned string is exactly twice as long as <cBytes>.

   $DESCRIPTION$
      StrToHex() is useful when working with the internet addresses that are
      required in conjunction with the IPX/SPX functions of Point To Point
      communication.

   $EXAMPLES$
      Convert the byte sequence to hexadecimal form:

      ? StrToHex(Chr(27)+'A')   // "1B41"
   $PLATFORMS$
      DOS
   $SEEALSO$
      HexToStr()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Point-To-Point Communication
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      <b>Point-To-Point Communication</b>

       The CA-Clipper Tools contain functions that allow direct communication
       between workstations in Novell or NetBIOS compatible networks by
       bypassing the file server.  This type of communication is called Point-
       To-Point communication.

       The data exchange between two workstations is interrupt controlled.
       Incoming data is copied in the background to a receiving buffer and can
       then be read with CA-Clipper Tools functions.  As soon as the receiving
       buffer is full, incoming data is discarded.  Outgoing data is copied to
       a sending buffer.  While the CA-Clipper application continues, data is
       sent in the background from the sending buffer to the target address.
       Interrupt controlled sending of data is necessary to avoid a long wait
       when you send large datasets.  When you use IPX/SPX communication or one
       of two possible NetBIOS communication variants, the data is broken up
       into packets internally.  The packet size depends on the protocol used
       (IPX: 546 bytes, SPX: 534 bytes, NetBIOS: 512 bytes).  The packets are
       sent sequentially.

       Normally, the packet structure of the transmitted data is transparent
       and does not affect the handling of the data.  The receiving buffer of
       the target workstation receives the data in the same way that the data
       has been written to the sending buffer.  When you use IPX/SPX protocols
       in addition to the data, a header that is included in each IPX or SPX
       packet can be transmitted to the receiving buffer.   This header makes a
       number of packet specific functions possible.  The tables 31.1 and 31.2
       describe the structure of the IPX and SPX header.  The header positions
       start with 1, corresponding to string functions.

       The NetBIOS communication variants have no similar mechanism available.

       Table 31.1:  IPX Packet Header
       <table>
           Position     Length    Description

           1            2         Checksum
           3            2         Packet length in bytes
           5            1         Transmission control
           6            1         Packet type (4=IPX)
           7            4         Network number of target station
           11           6         Station ID of target station
           17           2         Target socket (High, Low format)
           19           4         Network number of source station
           23           6         Station ID of source station
           29           2         Source socket (High,  Low format)
          </table>

       Table 31.2:  SPX Packet Header
       <table>
           Position  Length  Description

           1         2       Check sum
           3         2       Packet length in bytes
           5         1       Transmission control
           6         1       Packet type (5=SPX)
           7         4       Network number of target station
           11        6       Station ID of target station
           17        2       Target socket (High, Low format)
           19        4       Network number of source station
           23        6       Stations ID of source station
           29        2       Source socket (High, Low format)
           31        1       Connection control
           32        1       Datastream type
           33        2       Connection number on source station (High, Low format)
           35        2       Connection number on target station (High, Low format)
           37        2       Sequence number (High, Low format)
           39        2       Acknowledge number (High, Low format)
           41        2       Allocation number (High, Low format)
          </table>

       When you install a communication buffer (a communication buffer can
       contain a sending and a receiving buffer), you receive a communication
       handle as a return value.  You should store this handle in a variable as
       it is absolutely necessary for further operations with the communication
       buffer.

       The functions for Point-To-Point communication fall into two groups:
       protocol specific functions and functions that can be used for any kind
       of communication buffer.  Protocol specific functions are functions for
       a connection setup: (IPXOPEN(), SPXESTBCON(), SPXLISTCON(), NBDOPEN(),
       NBSCALL(), and NBSLISTCON()).  The name of a protocol specific function
       always starts with three characters that describe the respective
       protocol  (IPX, SPX, NBD: NetBIOS Datagram, NBS: NetBIOS Session).

       Functions that write or read a buffer, or query the buffer status, are
       not protocol specific and can be used for any kind of communication
       buffer.  The names of these functions start with PPC (Point-To-Point
       Communication).  For example, the function PPCWRITE() is used to write
       data to a communication buffer.  The protocol specific process of the
       data is regulated internally.

      <b>IPX/SPX Communication</b>

       Novell Netware (including Netware Lite) allows the direct use of the IPX
       and SPX communication functions.  By loading the Novell NetBIOS emulator
       (NETBIOS.EXE), you can also use NetBIOS communication functions in
       Novell networks.  However, the use of the emulator compared to IPX/SPX
       reduces the performance and the available memory.  Therefore, you should
       use the IPX/SPX communication functions for applications running only in
       Novell networks.

       IPX (Internetwork Packet Exchange Protocol) is a rudimentary protocol
       whose main advantage is that data can be sent to all waiting
       workstations in an internal network with only one call.  However, IPX
       has no suitable handshake mechanism available that guarantees a
       successful delivery and a correct process of the sent data on the
       destination workstation.  (Related mechanisms can be implemented with
       the IPX functions of CA-Clipper Tools.  However, these mechanisms are
       application specific and have no general validity.)

       The SPX protocol (Sequenced Packet Exchange Protocol) only allows
       communication between two workstations within an internal network.  SPX
       has mechanisms available that guarantee the successful delivery of sent
       data.

       Unlike SPX, which can be seen as real Point-To-Point communication
       protocol, the IPX communication is implemented as a pseudo Point-To-
       Point communication.  When you use IPX, data for a specific workstation
       can be received by any workstation.  However,  a destination address is
       defined for interrupt controlled sending.  (This address can specify all
       workstations within an internal network.)  The destination address is
       not defined by the protocol, so it is not necessary to specify the
       destination address each time you access the send buffer.  When you use
       the SPX protocol, a connection between two workstations is established.

       The IPX/SPX communication between two workstations is based on two
       sockets on each side of the connection that can be opened and closed,
       similar to files.  Sockets are represented by numeric values between 1
       and 65535.  Some socket numbers are reserved either by the Netware
       operating system or by Novell for third party vendors. The sockets
       between 16384 and 20480 (4000h - 5000h) are the dynamic sockets, meaning
       there are no reserved sockets in this range.  A collision with socket
       numbers reserved by Netware can be avoided by using sockets out of that
       range.

      <b>NetBIOS Communication</b>

       The NetBIOS communication functions can be used in all networks that are
       based on NetBIOS specifications.  In CA-Clipper Tools, two kinds of
       NetBIOS communication have been implemented: NetBIOS datagram and
       NetBIOS session communication. The NetBIOS datagram communication can be
       compared to the IPX communication; a successful delivery of sent data on
       the destination workstation is not guaranteed by the protocol.  Like
       IPX, the datagram connection can also be implemented as pseudo Point-To-
       Point communication between two workstations.  Additionally, a
       workstation can communicate with a group of workstations or with all
       workstations in a network.

       Like an SPX connection, a session connection is a fixed connection
       between two workstations.  The dataflow between two workstations is
       supervised internally by a protocol that guarantees the delivery of sent
       data on the destination workstation.

       For the communication with other workstations in a NetBIOS network,
       NetBIOS names are used.  A NetBIOS name can be up to 15 characters long
       and is case sensitive.  NetBIOS differentiates between two kinds of
       names: station names that specify a workstation and are unique in a
       network, and group names that can be assigned to any number of stations.
       Each workstation contains a local name table with up to 20 NetBIOS
       names.  A workstation can be addressed with each name in the name table.
       Once you have defined single or group names, messages can be sent easily
       to a station or a group of stations.

       Because of the importance of NetBIOS names for the Point-To-Point
       communication, CA-Clipper Tools not only includes functions for the
       sending and receiving of data, but also functions for creating and
       deleting NetBIOS names.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      CLOSESOCK()
   $ONELINER$
      Closes the socket and all connected IPX/SPX handles
   $SYNTAX$
      CLOSESOCK(<nSocket>) --> NIL

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nSocket>  Designates the number of the socket that is closed.

   $RETURNS$
      CLOSESOCK() always returns NIL when closing a socket according to IPX.

   $DESCRIPTION$
      CLOSE SOCKET
      CLOSESOCK() allows you to close a socket that is used for IPX/SPX
      communication.  At the same time, all IPX/SPX communication buffers for
      which <nSocket> has been specified as the source socket are closed.  The
      related communication handles are then invalid.

   $EXAMPLES$
      Open and close the IPX receiving buffer with source socket 20000:

      nHandle=IPXOPEN(20000,2000)
      CLOSESOCKET(20000)  // nHandle is now invalid
   $PLATFORMS$
      DOS
   $SEEALSO$
      IPXOPEN(), OPENSOCK(), PPCCANCEL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IPXERROR()
   $ONELINER$
      Determines the error code of the last IPX/SPX call
   $SYNTAX$
      IPXERROR() --> nErrorCode

      Netware: 2.2 and 3.11

   $RETURNS$
      IPXERROR() returns the error code of the previous IPX/SPX call by a
      CA-Clipper Tools function.  There is a table containing the error codes
      in Appendix D.

   $DESCRIPTION$
      IPXERROR() allows you to locate the source of an error that occurred
      during the execution of a CA-Clipper Tools function for IPX/SPX
      communication (for example IPXOPEN() or SPXESTBCON()).  If the IPX/SPX
      call has been terminated without an error, IPXERROR() returns 0.

      IPXERROR() returns an error code that is the direct result of an IPX/SPX
      call.  If the IPX/SPX call initiates the interrupt controlled receiving
      of a packet, the error code cannot return any information about the
      success or failure of the receiving process.  You can use the
      PPCRECERR() and PPCSNDERR() functions to determine this information.

   $EXAMPLES$
      Open the socket.  If an error occurs, determine the reason for the
      error:

      IF OPENSOCK(20000)=0                           // Error?
         IF IPXERROR()=254
            ? 'Local socket table full!'
         ENDIF
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECERR(), PPCSNDERR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      IPXOPEN()
   $ONELINER$
      Opens the IPX sending and receiving buffer
   $SYNTAX$
      IPXOPEN(<nSourceSocket>,[<nRecBuffer>],
         [[<nSendBuffer>],[<cTargetAddr>]],
         [<nTargetSocket>],[<nPacket>],[<lHeader>])
          --> nHandle

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nSourceSocket>  Designates the number of the communication's source
      socket.

      <nRecBuffer>  Designates the selected size of the receiving buffer.
      If no value is passed for <nRecBuffer>, no receiving buffer is
      established.  The minimum size of the receiving buffer is <nPacket>.  If
      the value for <nRecBuffer> is too small, it is changed automatically by
      IPXOPEN().  The maximum size of the receiving buffer is 64 KByte.

      <nSendBuffer>  Designates the selected size of the sending buffer.
      If no value is passed for <nSendBuffer>, no sending buffer is
      established.  The minimum size of the sending buffer is <nPacket>.  If
      the value for <nSendBuffer> is too small, it is changed automatically by
      IPXOPEN().  The maximum size of the sending buffer is 64 KByte.

      <cTargetAddr>  Designates the target address for the sending
      operations.  The target address is a 20-character string that represents
      a 10-character hexadecimal byte sequence.  The leading eight characters
      of <cTargetAddr> specify the network number of the target.  The
      following 12 characters contain the station ID of the target station
      (node address).  <cTargetAddr> is mandatory to establish a sending
      buffer.

      <nTargetSocket>  Designates the number of the communication's target
      socket.  The default value is <nSourceSocket>.

      <nPacket>  Designates the packet size in bytes of the data that is
      sent.  The packet size can be between 1 and 546 bytes.  Values outside
      this range are changed automatically.  The default value is 546 Bytes.

      <lHeader>  Designates whether the data and the header (.T.), or the
      data (.F.) alone, are transmitted to the receiving buffer.

   $RETURNS$
      If an operation is successful, IPXOPEN() returns a communication handle.
      The return value contains a numeric value that is greater than 0.  You
      should store the handle in a variable because all further operations
      that refer to an established buffer require a communication handle.  If
      an error occurs, the function returns 0.

   $DESCRIPTION$
      IPXOPEN() allows you to establish a communication buffer for an IPX
      communication with other workstations in the network.  The communication
      buffer can contain a sending and receiving buffer through which data is
      processed.

      <nSourceSocket> is the socket address of the process that transmits the
      data (see the Introduction to this chapter).  The socket can be opened
      with the function OPENSOCK() before the call of IPXOPEN().  If
      <nSourceSocket> has not been opened, it is automatically opened by
      IPXOPEN().  If <nSourceSocket> is passed with 0, IPXOPEN() opens an
      available socket.

      The parameters <nRecBuffer> and <nSendBuffer> determine the size of the
      receiving and sending buffers.  The buffers are automatically designed
      for one IPX packet.  Each buffer can be up to 64 KByte.  However, the
      size of the buffer that is allocated by IPXOPEN() depends on the
      application and the configuration of the computer used.

      The parameter <cTargetAddr> is mandatory to establish a sending buffer.
      All following sending operations are addressed to <cTargetAddr>.
      Remember that an IPX communication is implemented as a pseudo Point-To-
      Point communication.  Data is received by any station addressed to the
      current workstation but is sent only to a defined target address.  The
      target address must be passed as a 20- character string (for example,
      "4921750400001B025A99"), where two characters represent one byte in
      hexadecimal code.

      If the current workstation is logged in to a Netware server, the
      destination's network address can be determined with NNETADR() , using
      the user name.  However, the target workstation must be logged in.
      Under Netware Lite, the leading eight characters of <cTargetAddr> must
      be passed with 0.  A character string consisting of
      "FFFFFFFFFFFFFFFFFFFF" specifies all stations within an internal network
      as the target address (broadcast packages).

      <nTargetSocket> allows you to determine the communication's target
      socket.  The default value is <nSourceSocket>.

      <nPacket> determines the maximum size of the data range of the IPX
      packets that are sent or received.  The maximum value (and the default
      value) is 564 bytes.  The value of <nPacket> is also valid for sending
      data.

      With <lHeader> you can determine if the header (30 bytes) of an IPX
      packet is transmitted to the receiving buffer.  The header can contain
      important information about the received packet.  For a description
      about the header structure, see the Introduction to this chapter.

      If the buffer has been established successfully, IPXOPEN() returns an
      integer value that is greater than 0, called a communication handle.  If
      a value has been passed for <nRecBuffer>, IPXOPEN() initiates an
      interrupt controlled receiving mechanism that receives incoming packets
      in the background and then copies to an receiving buffer.  The data can
      then be read with the PPCREAD() function within a CA-Clipper
      application.  If the receiving buffer is full, incoming data is
      discarded without notifying the sender.  Data should be removed from the
      receiving buffer and processed as soon as possible.  You should either
      read the contents of the buffer periodically (polling) or supervise the
      buffer on an event-oriented basis: for example, with the function
      PPCKEY().

   $NOTES$
      ■  IPX is a protocol that is not based on a connection.  There is
         no guarantee or verification of a successful delivery to the target
         workstation.  The implementation of specific protocols with the aid
         of CA-Clipper Tools functions can be necessary.  (For your
         information: Netware usually uses IPX communication, and Netware Lite
         exclusively uses IPX communication, which is now available under
         CA-Clipper with the IPXOPEN() function.)

      ■  Several communication buffers can be established for one
         source socket.  However, you cannot know when you establish the
         communication buffers how the data will be distributed to the
         receiving buffers.

      ■  Network addresses can be determined under Netware with
         "USERLIST /A", and under Netware Lite with "NET ULIST".

   $EXAMPLES$
      ■  Open the 5 KByte IPX receiving buffer for socket 20000:

         nHandle=IPXOPEN(20000,5120)
         IF nHandle=0
            ? 'Buffer could not be established!'
         ENDIF

      ■  Open the 2 KByte IPX sending buffer for socket 20000.  The
         target address is "4921750400001B025A99":

         nHandle=IPXOPEN(20000,,2048,"4921750400001B025A99")

      ■  Open the 1 KByte IPX sending and receiving buffer for socket
         20000.  The target address is the first workstation where user MIKE
         is currently logged in:

         nHandle=IPXOPEN(20000,1024,1024,NNETADR("MIKE"))

      ■  For this example, the current workstation must be logged into
         a file server.  As NNETADR() is based on Netware-API, this call
         cannot be used under Netware Lite.
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETADR(), PPCCANCEL(), PPCREAD(), PPCWRITE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ISIPX()
   $ONELINER$
      Checks for IPX support
   $SYNTAX$
      ISIPX() --> lInstalled

      Netware: 2.2 and 3.11

   $RETURNS$
      ISIPX() returns .T. if IPX support is available.  The IPX communication
      functions of CA-Clipper Tools can be used.

   $DESCRIPTION$
      ISIPX() allows you to check to see if IPX support is available.  If it
      is not, an application can be terminated.

   $EXAMPLES$
      Check to see if IPX support is available.  If it is not, terminate the
      program:

      IF ISIPX()
         nHandle=IPXOPEN(20000,2000)
      ELSE
         ? 'IPX support not available, load IPX.COM!'
         QUIT
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      ISNETBIOS(), ISSPX(), IPXOPEN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ISNETBIOS()
   $ONELINER$
      Checks for NetBIOS support
   $SYNTAX$
      ISNETBIOS() --> lInstalled

      Netware: 2.2 and 3.11

   $RETURNS$
      ISNETBIOS() returns .T. if NetBIOS support is available.  If the
      function returns .T., the NetBIOS communication functions of CA-Clipper
      Tools can be used.

   $DESCRIPTION$
      ISNETBIOS() allows you to check to see if NetBIOS support is available.
      If it is not, an application can be terminated.

   $EXAMPLES$
      Check to see if NetBIOS support is available.  If it is not, terminate
      the program:

      IF ISNETBIOS()
         nHandle=NBDOPEN("STAT1",2000)
      ELSE
         ? 'NetBIOS support not available!'
         QUIT
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      ISIPX(), ISSPX(), NBDOPEN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      ISSPX()
   $ONELINER$
      Checks for SPX support
   $SYNTAX$
      ISSPX() --> lInstalled

      Netware: 2.2 and 3.11

   $RETURNS$
      ISSPX() returns .T. if SPX support is available.  The SPX communication
      functions of CA-Clipper Tools can be used.

   $DESCRIPTION$
      ISSPX() allows you to check to see if SPX support is available.  If it
      is not, an application can be terminated.

   $EXAMPLES$
      Check to see if SPX support is available.  If it is not, terminate the
      program:

      IF ISSPX()
         nHandle=SPXLISTCON(20000,2000)
      ELSE
         ? 'SPX support not available, load IPX.COM!'
         QUIT
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      ISIPX(), ISNETBIOS(), SPXLISTCON()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBADDGROUP()
   $ONELINER$
      Adds a NetBIOS group name to the local name table
   $SYNTAX$
      NBADDGROUP(<cName>) --> nNamesum

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the group name that is added to the local name
      table.  The name can be up to 15 characters long and is case sensitive.

   $RETURNS$
      NBADDGROUP() returns the number that has been assigned to the group
      name.  If an error occurs (for example, if the name table is full), the
      function returns 0.

   $DESCRIPTION$
      NBADDGROUP() adds the group name <cName> to the local name table.  If
      the name has been added successfully, the name can be passed as the
      source name in the functions NBDOPEN(), NBSCALL(), or NBSLISTCON().  The
      workstation can receive datagrams addressed to the group <cName> or
      react to a connection request addressed to <cName>.

      A group name can be used on any number of workstations.  However, if
      <cName> is already used as the station name on a station, the call of
      NBADDGROUP() fails and the function returns 0.

   $EXAMPLES$
      Add the group name ACCOUNT to the local name table:

      IF NBADDGROUP('ACCOUNT')>0
         ? 'Name has been added successfully!'
      ELSE
         ? 'Name could not be added!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBADDNAME(), NBDELNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBADDNAME()
   $ONELINER$
      Adds a NetBIOS station name to the local name table
   $SYNTAX$
      NBADDNAME(<cName>) --> nNamenum

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the station name that is added to the local name
      table.  The name can be up to 15 characters long and is case sensitive.

   $RETURNS$
      NBADDNAME() returns the number that has been assigned to
      the station name.  If an error occurs (for example, if the name table is
      full), the function returns 0.

   $DESCRIPTION$
      NBADDNAME() adds the station name <cName> to the local name table.  If
      the name has been added successfully, the name can be passed as the
      source name in the functions NBDOPEN(), NBSCALL(), or NBSLISTCON().  The
      workstation can receive datagrams addressed to the group <cName> or
      react to a connection request addressed to <cName>.

      Unlike group names, station names must be unique.  If <cName> is already
      in use on another station or already defined as a group name,  the call
      of NBADDNAME() fails and the function returns 0.

   $EXAMPLES$
      Add the station name MIKE to the local name table:

      IF NBADDNAME('MIKE')>0
         ? 'Name has been added successfully!'
      ELSE
         ? 'Name could not be added!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBADDGROUP(), NBDELNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBDELNAME()
   $ONELINER$
      Deletes a NetBIOS name from the local name table
   $SYNTAX$
      NBDELNAME(<cName>) -->lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates a station or group name that is deleted from a
      local name table.  The name can be up to 15 characters long and is case
      sensitive.

   $RETURNS$
      NBDELNAME() returns .T. if <cName> has been deleted successfully from
      the local name table.  If an error occurs (for example, if the name is
      not in the name table), the function returns .F..

   $DESCRIPTION$
      NBDELNAME() allows you to delete a station or group name from the local
      name table.  For example, all names added to a table within an
      application can be deleted at the end of the program.

      When a name is deleted from a name table, all NetBIOS datagram and
      NetBIOS session communication buffers for which <cName> has been passed
      as source name are closed.  Related communication handles are then
      invalid.

   $EXAMPLES$
      Delete the NetBIOS name MIKE from the local name table:

      IF NBDELNAME('MIKE')
         ? 'Name has been deleted successfully!'
      ELSE
         ? 'Name  could not be deleted!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBADDGROUP(), NBADDNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBDOPEN()
   $ONELINER$
      Opens the NetBIOS datagram sending and receiving buffer
   $SYNTAX$
      NBDOPEN(<cSourceName>,[<nRecBuffer>],[<nSendBuffer>],
         [<cTargetName>],[<nPacket>]) --> nHandle

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cSourceName>  Designates the NetBIOS name of the communication's
      transmitting side.

      <nRecBuffer>  Designates the selected size of the receiving buffer.
      If no value is passed for <nRecBuffer>, no receiving buffer is
      established.  The minimum size of the receiving buffer is <nPacket>.  If
      the value for <nRecBuffer> is too small, it is changed automatically by
      NBDOPEN().  The maximum size of the receiving buffer is 64 KByte.

      <nSendBuffer>  Designates the selected size of the send buffer.  If
      no value is passed for <nSendBuffer>, no sending buffer is established.
      The minimum size of the sending buffer is <nPacket>.  If the value for
      <nSendBuffer> is too small, it is changed automatically by NBDOPEN().
      The maximum size of the sending buffer is 64 KByte.

      <cTargetName>  Designates a NetBIOS name that specifies the target
      station(s).

      <nPacket>  Designates the packet size of the data that is sent in
      bytes.  The packet size can be between 1 and 512 bytes.  Values outside
      this range are changed automatically.  The default value is 512 Bytes.

   $RETURNS$
      If an operation is successful, NBDOPEN() returns a communication handle.
      The return value contains a numeric value that is greater than 0.  You
      should store the handle in a variable because all further operations
      that refer to an established buffer require a communication handle.  If
      an error occurs, the function returns 0.

   $DESCRIPTION$
      NBDOPEN() allows you to establish a communication buffer for an NetBIOS
      datagram communication with other workstations in the network.  The
      communication buffer can contain the sending and receiving buffer
      through which data is processed.

      <nSourceName> is the NetBIOS name of the process that transmits the data
      (see the Introduction to this chapter).  The name can be added to the
      local name table with the functions NBADDNAME() or NBADDGROUP() before
      the call of NBDOPEN().  If <nSourceName> has not been added to the name
      table, it is added by NBDOPEN() automatically.  If the parameter
      <nTargetName> is passed, only data that is addressed to <cSourceName> is
      received.

      The parameters <nRecBuffer> and <nSendBuffer> determine the size of the
      receiving and sending buffer.  The buffers are automatically designed
      for one NetBIOS packet.  Each buffer can be up to 64 KByte.  However,
      the size of the buffer that is allocated by NBDOPEN() depends on the
      application and the configuration of the computer used.

      The parameter <cTargetName> is optional.  It controls the type of
      datagrams that are sent.  If <cTargetName> has been passed, the data
      that is sent can be received by all workstations on which the name table
      contains <cTargetName> (see the Introduction to this chapter).  If
      <cTargetName> is the name of a station, the data is sent to only one
      station.  If <cTargetName> contains a group name, the data can be
      received by any number of stations.  If <cTargetName> has not been
      passed, NBDOPEN() transmits "broadcast datagrams".  Broadcast datagrams
      do not contain a target address and can be received by all stations that
      wait for broadcast datagrams.

      <nPacket> determines the maximum size of the data range of the NetBIOS
      packets that are sent or received.  The maximum value (and the default
      value) is 512 bytes.  Smaller packets can be sent without failure, but
      larger packets are discarded.  The value of <nPacket> is also valid for
      use in sending data.

   $NOTES$
      ■  The NetBIOS datagram communication is not based on a
         connection.  There is no guarantee or verification of a successful
         delivery to the target workstation.  The implementation of specific
         protocols with the aid of CA-Clipper Tools functions can be
         necessary.

   $EXAMPLES$
      ■  Open the 5 KByte NetBIOS datagram receiving buffer for source
         name MICK:

         nHandle=NBDOPEN("MICK",5120)
         IF nHandle=0
            ? 'Buffer could not be established!'
         ENDIF

      ■  Open the 2 KByte NetBIOS datagram sending buffer for source
         name MICK.  The target address is the NetBIOS name KEITH:

         nHandle=IPXOPEN("MICK",,2048,"KEITH")

      ■  Open the 1 KByte NetBIOS sending and receiving buffer.  For
         the source and target address, see the example above:

         nHandle=NBDOPEN(,1024,1024,"KEITH")
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCCANCEL(), PPCREAD(), PPCWRITE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBERROR()
   $ONELINER$
      Determines the error code of the most recent NetBIOS call
   $SYNTAX$
      NBERROR() --> nErrorCode

      Netware: 2.2 and 3.11

   $RETURNS$
      NBERROR() returns the error code of the most recent NetBIOS call by a
      CA-Clipper Tools function.  There is a table containing the error codes
      in Appendix E.

   $DESCRIPTION$
      NBERROR() allows you to locate the source of an error that occurred
      during the execution of a CA-Clipper Tools function for NetBIOS
      communication (for example, NBDOPEN() or NBSCALL()).  If the NetBIOS
      call was terminated without an error, NBERROR() returns 0.

      NBERROR() returns an error code that is the direct result of a NetBIOS
      call.  If the NetBIOS call initiates the interrupt controlled receiving
      of a packet, the error code cannot return any information about the
      success or failure of the receiving process.  You can use the
      PPCRECERR() and PPCSNDERR() functions to determine this information.

   $EXAMPLES$
      Add a NetBIOS name to the name table.  If an error occurs, determine the
      error source:

      IF NBADDNAME('MIKE')=0                           // Error?
         IF NBERROR()=13
            ? 'Name already in local name table!'
         ENDIF
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECERR(), PPCSNDERR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBNAME()
   $ONELINER$
      Reads a NetBIOS name from the name table of a workstation
   $SYNTAX$
      NBNAME(<nPos>,[<cStatName>]) --> cName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPos>  Designates the position in the local name table that is
      read.

      <cStatName>  Designates a station name of the workstation from which
      the name table is read.  The default value specifies the local
      workstation.

   $RETURNS$
      NBNAME() returns the NetBIOS name on position <nPos> in the local name
      table of <cStatName>.  If an error occurs (for example, if <nPos> is not
      used or <cStatName> cannot be found), the function returns an empty
      string.

   $DESCRIPTION$
      Each NetBIOS workstation keeps a local name table with up to 20 NetBIOS
      names.  NBNAME() allows you to determine the names on each position of
      the table.  The names can be determined for the local workstation or for
      any workstation in the network, if you pass a NetBIOS station name
      <cStatName>.

      NBNAME() always returns a 15-character string.  All NetBIOS names are
      internally padded with blanks to a length of 15 characters.

   $EXAMPLES$
      ■  Read the name table of the local workstation:

         FOR i = 1 TO 20
            ? NBNAME(i)
         NEXT i

      ■  Read the name table of workstation MIKE:

         FOR i = 1 TO 20
            ? NBNAME(i,"MIKE")
         NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBADDGROUP(), NBADDNAME(), NBDELNAME(), NBNAMECNT(), NBNAMESTAT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBNAMECNT()
   $ONELINER$
      Determines the number of NetBIOS names on a workstation
   $SYNTAX$
      NBNAMECNT([<cStatName>]) --> nNames

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cStatName>  Designates the station name of the workstation from
      which the name table is read.  The default value is the local
      workstation.

   $RETURNS$
      NBNAMECNT() returns the number of established NetBIOS names on the
      station <cStatName>.  If an error occurs (for example, if <cStatName>
      has not been found), the function returns -1.

   $DESCRIPTION$
      Internally, each NetBIOS workstation keeps a local name table with up to
      20 NetBIOS names.  NBNAMECNT() allows you to determine the number of
      names in the table.  The number of names can be determined for the local
      workstation or for any workstation in the network, if you pass a NetBIOS
      station name <cStatName>.

   $EXAMPLES$
      ■  Determine the number of NetBIOS names on the local
         workstation:

         ? NBNAMECNT()

      ■  Determine the number of NetBIOS names on workstation MIKE:

         ? NBNAMECNT("MIKE")
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBNAME(), NBNAMESTAT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBNAMENUM()
   $ONELINER$
      Determines the number of a NetBIOS name
   $SYNTAX$
      NBNAMENUM(<cName>) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cName>  Designates the NetBIOS name for which the number is
      determined.

   $RETURNS$
      NBNAMENUM() returns the number of <cName>.  If an error occurs, the
      function returns -1.

   $DESCRIPTION$
      NetBIOS assigns a number to each new station or group name.  The name's
      number can be determined with NBNAMENUM().  If an error occurs (for
      example, if the name does not exist), the function returns -1.

   $EXAMPLES$
      Determine the number for the NetBIOS name ACCOUNT:

      nNumber=NBNAMENUM('ACCOUNT')
      IF nNumber <> -1
         ? 'Number for ACCOUNT:',nNumber
      ELSE
         ? 'Name does not exist!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBADDGROUP(), NBADDNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBNAMESTAT()
   $ONELINER$
      Determines the status of a NetBIOS name
   $SYNTAX$
      NBNAMESTAT(<nPos>,[<cStatName>]) --> nStatus

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nPos>  Designates the position in the local name table that is
      read.

      <cStatName>  Designates a station name of the workstation from which
      the name table is read.  The default station is the local workstation.

   $RETURNS$
      NBNAMESTAT() returns a bit mask that contains the status of the
      specified NetBIOS name.  The highest bit (bit 8) indicates if the name
      is a station name (not set) or a group name (set).  The three lower bits
      (bits 1 to 3) are seen as one unit.  Their value returns information
      about the current state of the specified name.  The following table
      contains a description of the three bits:

      Table 31.3:  Coding of Bits 1-3 in the NBNAMESTAT() Return Value
      <table>
          Value   Binary    Definition

          0       000       Name registration not finished
          4       100       Name registered properly
          5       101       Name already deleted, but sessions still to come
          6       110       Duplicate name
          7       111       Duplicate name, deletion in process
         </table>

      If an error occurs (for example, if <cStatName> has not been found), the
      function returns -1.

   $DESCRIPTION$
      Internally, each NetBIOS workstation keeps a local name table with up to
      20 NetBIOS names.  NBNAMESTAT() allows you to determine the status of
      each name in the table.  The status of a name in the name table can be
      determined for the local workstation or, by passing a NetBIOS station
      name <cStatName>, for any workstation in the network.

   $EXAMPLES$
      ■  Check to see if the first NetBIOS name on the local
         workstation is a station or group name:

         nStat=NBNAMESTAT(1)
         IF nStat=-1
            ? 'Error!'
         ELSE
            IF IsBit(nStat,8)
               ? 'Group name'
            ELSE
               ? 'Station name'
            ENDIF
         ENDIF

      ■  Check to see if the third NetBIOS name on the local
         workstation is registered properly:

         IF NumAnd(NBNAMESTAT(3),7)=4
            ? 'Name registered properly!'
         ELSE
            ? 'Name not properly registered!'
         ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBNAME(), NBNAMECNT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBRESET()
   $ONELINER$
      Resets the NetBIOS adapter
   $SYNTAX$
      NBRESET([<nMaxSessions>],[<nMaxNCBs>]) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nMaxSessions>  Designates the maximum number of sessions possible
      after the adapter has been reset.  The default value is 0.  The value 0
      sets the internal default value for the number of sessions (normally 6).

      <nMaxNCBs>  Is the maximum number of simultaneously active NCBs
      (Network Control Blocks) after the adapter has been reset.  The default
      value is 0.  The value 0 sets the internal default value for the number
      of NCBs (normally 12).

   $RETURNS$
      NBRESET() returns .T. if the adapter has been reset successfully.

   $DESCRIPTION$
      Important!  This function must not be called in networks that base
      the internal communication on the NetBIOS protocol.  The entire network
      can be brought to a standstill!   However, on a Novell workstation,
      where the NetBIOS emulator (NETBIOS.EXE) is loaded, the function
      NBRESET() can be called without any problems.

      When an adapter is reset, the local name table is deleted and all active
      sessions are terminated.  At the same time, the maximum number of
      sessions and the maximum number of NCBs (Network Control Blocks) can be
      redefined.  CA-Clipper Tools functions for the NetBIOS communication
      require two NCBs for each session communication buffer, and one NCB each
      for the datagram communication buffer, and the sending and receiving
      buffers.

   $EXAMPLES$
      Reset the NetBIOS adapter in a Novell network:

      IF NNetwork()
         NBRESET()
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCCANCEL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBSCALL()
   $ONELINER$
      Opens a NetBIOS session sending and receiving buffer and attempts a connection setup
   $SYNTAX$
      NBSCALL(<cSourceName>,[<nRecBuffer>],[<nSendBuffer>],
         <cTargetName>,[<nPacket>],[<nRecTimeout>],
         [<nSendTimeout>]) --> nHandle

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cSourceName>  Designates the NetBIOS name of the communication's
      transmitting side.

      <nRecBuffer>  Designates the selected size of the receiving buffer.
      If no value is passed for <nRecBuffer>, no receiving buffer is
      established.  The minimum size of the receiving buffer is <nPacket>.  If
      the value for <nRecBuffer> is too small, it is changed automatically by
      NBSCALL().  The maximum size of the receiving buffer is 64 KByte.

      <nSendBuffer>  Designates the selected size of the sending buffer.
      If no value is passed for <nSendBuffer>, no sending buffer is
      established.  The minimum size of the sending buffer is <nPacket>.  If
      the value for <nSendBuffer> is too small, it is changed automatically by
      NBSCALL().  The maximum size of the sending buffer is 64 KByte.

      <cTargetName>  Designates a NetBIOS name that specifies the target
      station.

      <nPacket>  Designates the packet size of the data that is sent in
      bytes.  The default value is 512 Bytes.

      <nRecTimeout>  Designates the timeout for the following receiving
      operations in 1/2 seconds.  The default value (0) designates no timeout.

      <nSendTimeout>  Designates the timeout for the following sending
      operations in 1/2 seconds.  The default value (0) designates no timeout.

   $RETURNS$
      If an operation is successful, NBSCALL() returns a communication handle.
      The return value contains a numeric value that is greater than 0.  You
      should store the handle in a variable because all further operations
      that refer to an established buffer require a communication handle.  If
      an error occurs, the function returns 0.

   $DESCRIPTION$
      NBSCALL() allows you to establish a communication buffer for a NetBIOS
      session communication with other workstations in the network.  The
      communication buffer can contain the sending and receiving buffer
      through which the interrupt controlled sending and receiving of data is
      processed.

      <nSourceName> is the NetBIOS name of the process that transmits the data
      (see the Introduction to this chapter).  The name can be added to the
      local name table with the functions NBADDNAME() or NBADDGROUP() before
      the call of NBSCALL().  If <nSourceName> has not been added to the name
      table, it is added by NBSCALL() automatically.

      The parameters <nRecBuffer> and <nSendBuffer> determine the size of
      receiving and sending buffers.  The buffers are automatically designed
      for one NetBIOS packet.  Each buffer can be up to 64 KByte.  However,
      the size of the buffer that is allocated by NBSCALL() depends on the
      application and the configuration of the computer used.

      The parameter <cTargetName> is mandatory.  The session is set up with
      the station specified by <cTargetName>.

      <nPacket> determines the maximum size of the data range of the NetBIOS
      packets that are sent or received.  The maximum value (and the default
      value) is 512 bytes.  Smaller packets can be sent without failure.
      However, larger packets are discarded.  The value of <nPacket> is also
      valid for use in sending data.

      The seconds for the timeout are not determined individually for each
      sending and receiving operation.  The timeout is set when the session is
      opened by passing the parameters <nRecTimeout> and <nSendTimeout>.  The
      parameters can contain numeric values that specify the timeout in steps
      of 1/2 second.

      If all parameters have been passed correctly and the buffers have been
      established successfully, NBSCALL() attempts to set up a session between
      the current workstation and the target station.  However, the target
      station must expect the connection setup.  If a CA-Clipper application
      is running on the target station, the function NBSLISTCON() must have
      been called.  If no acknowledgment is returned by the target station
      within the specified timeout, NBSCALL() releases the reserved buffers
      and returns 0.

      After a successful connection setup NBSCALL() returns a communication
      handle  that is greater than 0.  If a value has been passed for
      <nRecBuffer>, NBSCALL() initiates an interrupt controlled receiving
      mechanism that receives incoming packets in the background and then
      copies them to a receiving buffer.  The data can then be read with the
      PPCREAD() function within a CA-Clipper application.  If the receiving
      buffer is full, incoming data is discarded without notifying the sender.
      Data should be removed from the receiving buffer and processed as soon
      as possible.   You should either read the contents of the buffer
      periodically (polling) or supervise the buffer on an event-oriented
      basis: for example, with the function PPCKEY().

   $NOTES$
      ■  Unlike a NetBIOS datagram communication, a NetBIOS session
         communication is connection-oriented.  A connection is established
         between two stations.  As long as no error occurs, a successful
         delivery of sent packets is guaranteed.

   $EXAMPLES$
      ■  Attempt to set up a NetBIOS session connection to workstation
         MIKE.  If the setup is successful, a 5000 byte receiving buffer and a
         1000 byte sending buffer are established.  The source name on the
         local workstation is KEITH:

         nHandle=NBSCALL("MICK",5000,1000,"MIKE")
         IF nHandle=0
            ? 'Failure!'
         ENDIF

      ■  The destination side can wait for the connection with the
         following call:

         nHandle:=NBSLISTCON("MIKE",2000,2000)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBSLISTCON(), PPCCANCEL(), PPCKEY(), PPCREAD(), PPCWRITE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBSCONTARG()
   $ONELINER$
      Determines the target name of a NetBIOS communication session
   $SYNTAX$
      NBSCONTARG(<nHandle>) --> cNetBIOSName

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication buffer.

   $RETURNS$
      NBSCONTARG() returns the destination's NetBIOS name.  If <nHandle> does
      not specify a NetBIOS session communication buffer or the NetBIOS
      session connection is not active, the function returns an empty string.

   $DESCRIPTION$
      NBSCONTARG() allows you to determine the destination's NetBIOS name
      after a call of NBSLISTCON().  For example, if no target name has been
      passed for NBSLISTCON(), the function can establish a connection to any
      requesting station.  The name of this station can be queried with
      NBSCONTARG().

   $EXAMPLES$
      Wait for a NetBIOS session connection in the background.  After the
      connection has been set up, display the destination's NetBIOS name:

      nHandle=NBSLISTCON("MIKE",1000,1000)
      WHILE .NOT. PPCCONACT(nHandle)
      ENDDO
      ? 'Connection set up with ',NBSCONTARG(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBSLISTCON()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NBSLISTCON()
   $ONELINER$
      Opens the NetBIOS session sending and receiving buffer and waits for connection in the background
   $SYNTAX$
      NBSLISTCON(<cSourceName>,[<nRecBuffer>],
         [<nSendBuffer>],[<cTargetName>],[<nPacket>],
         [<nRecTimeout>],[<nSendTimeout>]) --> nHandle

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cSourceName>  Designates the NetBIOS name of the communication's
      transmitting side.

      <nRecBuffer>  Designates the selected size of the receiving buffer.
      If no value is passed for <nRecBuffer>, no receiving buffer is
      established.  The minimum size of the receiving buffer is  <nPacket>.
      If the value for <nRecBuffer> is too small, it is changed automatically
      by NBSLISTCON().  The maximum size of the receiving buffer is 64 KByte.

      <nSendBuffer>  Designates the selected size of the sending buffer.
      If no value is passed for <nSendBuffer>, no sending buffer is
      established.  The minimum size of the sending buffer is <nPacket>.  If
      the value for <nSendBuffer> is too small, it is changed automatically by
      NBSLISTCON().  The maximum size of the sending buffer is 64 KByte.

      <cTargetName>  Designates a NetBIOS name that specifies the target
      station.  If a value is passed for <cTargetName>, NBSLISTCON() waits for
      a connection request for this station.  The default value does not
      specify a target name.

      <nPacket>  Designates the packet size of the data that is sent in
      bytes.  The default value is 512 Bytes.

      <nRecTimeout>  Designates the timeout for the following receiving
      operations in 1/2 seconds.  The default value (0) designates no timeout.

      <nSendTimeout>  Designates the timeout for the following sending
      operations in 1/2 seconds.  The default value (0) designates no timeout.

   $RETURNS$
      If an operation is successful, NBSLISTCON() returns a communication
      handle.  The return value contains a numeric value that is greater than
      0.  You should store the handle in a variable because all further
      operations that refer to an established buffer require a communication
      handle.  If an error occurs, the function returns 0.

   $DESCRIPTION$
      NBSLISTCON() establishes a communication buffer for an NetBIOS session
      communication with other workstations in the network, and then waits for
      a connection setup through any other station.  The communication buffer
      can contain sending and receiving buffers through which the interrupt
      controlled sending and receiving of data is processed.

      <nSourceName> is the NetBIOS name of the process that transmits the data
      (see the Introduction to this chapter).  The name can be added to the
      local name table with the functions NBADDNAME() or NBADDGROUP() before
      the call of NBSLISTCON().  If <nSourceName> has not been added to the
      name table, it is added by NBSLISTCON() automatically.

      The parameters <nRecBuffer> and <nSendBuffer> specify the size of the
      receiving and sending buffers.  The buffers are automatically designed
      for one NetBIOS packet.  Each buffer can be up to 64 KByte in size.
      However, the size of the buffer that is allocated by NBSLISTCON()
      depends on the application and the configuration of the computer used.

      The parameter <cTargetName> is optional.  When a value is passed for
      <cTargetName>, NBSLISTCON() waits for a connection request for
      <cTargetName>.  Without <cTargetName>, NBSLISTCON() reacts to any
      connection request.

      <nPacket> determines the maximum size of the data range of the NetBIOS
      packets to be sent or received.  The maximum and default value is 512
      bytes.  Smaller packets can be sent without failure.  However, larger
      packets are discarded.  The value of <nPacket> is also valid for use in
      sending data.

      The seconds for the timeout are not determined individually for each
      sending and receiving operation.  The timeout is set when the session is
      opened by passing the parameters <nRecTimeout> and <nSendTimeout>.  The
      parameters can contain numeric values that specify the timeout in steps
      of 1/2 second.

      If all parameters have been passed correctly and the buffers have been
      established successfully, NBSLISTCON() returns a communication handle.
      A communication handle, however, does not indicate that a NetBIOS
      session has already been set up.  After NBSLISTCON() has been executed,
      a handler waits for a connection request in the background.  The
      communication handler, returned by NBSLISTCON(), cannot be used for
      sending and receiving before a connection has been established.  The
      current connection status after a call of NBSLISTCON() can be queried
      with PPCCONACT().  It is also possible to trigger a key trap with
      PPCKEY().

   $NOTES$
      ■  Unlike a NetBIOS datagram communication, a NetBIOS session
         communication is connection-oriented.  A connection is established
         between two stations.  As long as no error occurs, a successful
         delivery of sent packets is guaranteed.

   $EXAMPLES$
      ■  Wait for the setup of a NetBIOS session:

         nHandle=NBSLISTCON("MICK",1000)
         WHILE .NOT. PPCCONACT(nHandle)
         ENDDO

      ■  After a NetBIOS session has been set up successfully, send key
         code 255 to the keyboard buffer:

         #include "ctppc.ch"

         nHandle=NBSLISTCON("MICK",5000,1000)
         PPCKEY(nHandle,255,PPC_CONESTB)
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBSCALL(), PPCCANCEL(), PPCKEY(), PPCREAD(), PPCWRITE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      OPENSOCK()
   $ONELINER$
      Opens the socket for IPX or SPX communication
   $SYNTAX$
      OPENSOCK(<nSocket>) --> nOpen

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nSocket>  Designates the number of the socket that is opened.

   $RETURNS$
      OPENSOCK() returns the number of the socket if the socket has been
      opened successfully.  If an error occurs, the function returns 0.

   $DESCRIPTION$
      An IPX or SPX communication is handled through "sockets" (see the
      Introduction to this chapter).  OPENSOCK() allows you to explicitly open
      a socket before a call of IPXOPEN(), SPXESTBCON(), or SPXLISTCON().  If
      OPENSOCKET() is called with the argument 0, any available socket can be
      opened.  The socket's number is returned by OPENSOCK().

   $NOTES$
      ■  The functions IPXOPEN(), SPXESTBCON(), and SPXLISTCON() open
         the source socket automatically.  A call of OPENSOCKET() is not
         necessary.

   $EXAMPLES$
      ■  Open socket 20000:

         IF OPENSOCK(20000)=0
            ? 'Socket could not be opened!'
         ELSE
            ? 'Socket has been opened successfully!'
         ENDIF

      ■  Open any available socket:

         ? 'Socket',OPENSOCK(0),' opened!'
   $PLATFORMS$
      DOS
   $SEEALSO$
      CLOSESOCK(), IPXOPEN(), SPXESTBCON(), SPXLISTCON()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCBUFTYP()
   $ONELINER$
      Determines the communication buffer type
   $SYNTAX$
      PPCBUFTYP(<nHandle>) --> nBufferType

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication buffer.

   $RETURNS$
      PPCBUFTYP() returns a type code that indicates the protocol of the
      specified communication buffer.  For all possible types (IPX, SPX,
      NetBIOS Datagram, or NetBIOS session), the header file CTPPC.CH contains
      symbolic constants according to the following table.

      Table 31.4:  Possible Return Values of PPCBUFTYP()
      <table>
          Value   Sym. Con.    Definition

          1       PPC_IPX      IPX
          17      PPC_SPX      SPX
          2       PPC_NBD      NetBIOS datagram
          18      PPC_NBS      NetBIOS session
         </table>

      The numeric values might change in future versions, so you should use
      symbolic constants.  If an error occurs (for example, if the handle is
      invalid), the function returns -1.

   $DESCRIPTION$
      PPCBUFTYP() allows you to develop procedures that can work with any
      communication buffer.  With PPCBUFTYP(), protocol specific calls can be
      made, depending on the buffer type.

   $EXAMPLES$
      Determine the destination's name within a session and thereby
      differentiate between SPX and NetBIOS session buffers:

      #include "ctppc.ch"

      IF PPCBUFTYP(nHandle)=PPC_SPX
         ? 'Destination name:',SPXCONTARG(nHandle)
      ELSEIF PPCBUFTYP(nHandle)=PPC_NBS
         ? 'Destination name:',NBSCONTARG(nHandle)
      ELSE
         ? 'Error: No session buffer!'
      ENDIF
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCCANCEL()
   $ONELINER$
      Closes the communication handle and the connected buffers
   $SYNTAX$
      PPCCANCEL(<nHandle>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the handle of the communication buffer that is
      closed.

   $RETURNS$
      PPCCANCEL() returns .T. if the communication buffer has been closed
      successfully.  If an error occurs, the function returns .F..

   $DESCRIPTION$
      PPCCANCEL() allows you to close any communication buffer, independently
      of the protocol used (IPX, SPX, NetBIOS datagram or NetBIOS session).
      The handle of the selected communication buffer must be passed to
      PPCCANCEL().  PPCCANCEL() uninstalls the procedures for interrupt
      controlled sending and receiving and releases allocated memory.  When
      PPCCANCEL() is called, all data in the sending or receiving buffer is
      lost.  After a call of PPCCANCEL(), <nHandle> is invalid.

   $EXAMPLES$
      Open and close the communication buffer:

      nHandle=IPXOPEN(20000,546)
      // ...
      // Using the communication buffer ....
      // ...
      // Close communication buffer
      PPCCANCEL(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      CLOSESOCK(), NBDELNAME()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCCONACT()
   $ONELINER$
      Checks for an active communication connection
   $SYNTAX$
      PPCCONACT(<nHandle>) --> lAktive

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates a communication handle that identifies the
      communication buffer.

   $RETURNS$
      PPCCONACT() returns .T. if <nHandle> specifies an active connection.  If
      an inactive connection occurs, the function returns .F..

   $DESCRIPTION$
      PPCCONACT() is used mainly in conjunction with session- oriented
      protocols (SPX or NetBIOS session).  PPCCONACT() allows you to determine
      if a connection has been set up after the call of a function that waits
      for a connection setup in the background: for example, SPXLISTCON() or
      BSLISTCON().  You can also check to see if a connection is still active.
      If an error occurs (for example, if a connection has been canceled), the
      function returns .F..

   $NOTES$
      ■  When used for IPX or NetBIOS datagram connections, PPCCONACT()
         always returns .T..

   $EXAMPLES$
      Wait for an SPX connection setup:

      nHandle=SPXLISTCON(20000,1000)
      WHILE .NOT. PPCCONACT(nHandle)
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      NBSLISTCON(), SPXLISTCON()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCEVENT()
   $ONELINER$
      Queries the event code that most recently triggered a key trap
   $SYNTAX$
      PPCEVENT(<nHandle>) --> nEventCode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCEVENT() returns a numeric code that specifies the event that most
      recently triggered a key trap for the communication buffer defined by
      <nHandle>.  All possible event codes can be seen in the following table.

      Table 31.5:  Possible Return Values of PPCEVENT()
      <table>
          Value   Sym. Con.           Definition

          1       PPC_RECSUC          Packet received successfully
          2       PPC_RECFAIL         Packet received with errors
          4       PPC_RECBUFF75FULL   Receiving buffer more than 75% full
          8       PPC_RECPACKDISCARD  Packet discarded because of a full receiving
                                      buffer
          16      PPC_SNDFAIL         Failure during sending of a packet
          32      PPC_CONESTAB        Session set up successfully
          64      PPC_CONTERM         Session terminated
         </table>

      A value of 0 indicates that no event has been triggered through PPCKEY()
      since the installation of the event handler.  If an error occurs (for
      example, if the handle is invalid), PPCEVENT() returns -1.

   $DESCRIPTION$
      With the function PPCKEY() you can define a key code for each
      communication buffer to be triggered when a specified  event occurs.
      PPCEVENT() allows you to determine the last event.  Dependent on the
      return value of PPCEVENT(), various actions can be executed in the event
      handler.  If no event mask has been defined for the communication
      buffer, PPCEVENT() returns 0.

   $EXAMPLES$
      Open an SPX receiving buffer and wait for a connection in the
      background.  An event supervision is installed with PPCKEY() for the
      communication buffer.  The event handler displays a message when a
      connection is set up or canceled.  Additionally, the receiving buffer is
      read as soon as it is 75% full:

      #include "ctppc.ch"

      PRIVATE nHandle

      // Wait for connection on socket 20000
      // open receiving buffer of 5000 bytes

      nHandle:=SPXLISTCON(20000,5000)

      // install event handler
      // PPC_CONESTAB+PPC_CONTERM+PPC_RECBUFF75FULL=100

      PPCKEY(nHandle,255,100)
      SET KEY 255 TO handler
      WAIT

      PROCEDURE handler
         LOCAL nEvent:=PPCEVENT(nHandle)
         LOCAL cBuffer
         DO CASE
            CASE nEvent=PPC_CONESTB
               ? 'Connection set up!'
            CASE nEvent=PPC_CONTERM
               ? 'Connection terminated!'
            CASE nEvent=PPC_RECBUFF75FULL
               cBuffer=PPCREAD(nHandle)
         ENDCASE
      RETURN
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCKEY()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCKEY()
   $ONELINER$
      Supervises the communication buffer with key traps
   $SYNTAX$
      PPCKEY(<nHandle>,[<nKeyValue>],[<nEventMask>])
          --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

      <nKeyValue>  Designates the key code that is triggered when specific
      events occur.  All values of the CA-Clipper KEYBOARD command are valid.
      Without this parameter, a previously set buffer supervision is removed.

      <nEventMask>  Designates a numeric value that determines the events
      that trigger a key trap.  The value contains an OR operation of various
      events according to the following table.

      Table 31.6:  Event Codes for PPCKEY()
      <table>
          Value   Sym. Con.           Definition

          1       PPC_RECSUC          Packet received successfully
          2       PPC_RECFAIL         Packet received with errors
          4       PPC_RECBUFF75FULL   Receiving buffer more than 75% full
          8       PPC_RECPACKDISCARD  Packet discarded because of a full receiving
                                      buffer
          16      PPC_SNDFAIL         Failure during sending of a packet
          32      PPC_CONESTAB        Session set up successfully
          64      PPC_CONTERM         Session terminated
         </table>

      The default value (127) triggers a key trap on each event.  The symbolic
      constants are defined in the header file CTPPC.CH.

   $RETURNS$
      PPCKEY() returns .T. when a key code has been set or removed
      successfully.

   $DESCRIPTION$
      PPCKEY() allows you , independently of the protocol used (IPX, SPX,
      NetBIOS datagram, or NetBIOS session), to supervise a communication
      buffer within a wait state without having to control specific values
      (for example, the number of characters in buffer).  If an event that is
      specified by <nEventMask> occurs, PPCKEY() puts the key code <nKeyValue>
      into the keyboard buffer.  With a previously defined SET KEY procedure,
      you can react to the event immediately .  For example, with PPCEVENT()
      you can determine the event that triggered the key trap.

      If no key code is passed for PPCKEY(), the supervision for the
      communication handle is removed.

   $EXAMPLES$
      ■  Put key code 255 into the keyboard buffer at any event:

         IF PPCKEY(nHandle,255)
            ? 'Event handler installed successfully!'
         ELSE
            ? 'Event handler could not be installed!'
         ENDIF

      ■  Store key code 255 to the keyboard buffer when a packet is
         received:

         #include "ctppc.ch"

         PPCKEY(nHandle,255,PPC_RECSUC)

      ■  Store key code 255 to the keyboard buffer when a session is
         set up or canceled (only for SPX or NetBIOS session communication):

         #include "ctppc.ch"

         PPCKEY(nHandle,255,NumOr(PPC_CONESTB,PPC_CONTERM))

      ■  Remove the event supervision:

         PPCKEY(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCEVENT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCREAD()
   $ONELINER$
      Reads data from a communication receiving buffer
   $SYNTAX$
      PPCREAD(<nHandle>,[<nLength>],[<lNotDelete>])
          --> cString

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication buffer from which the
      receiving buffer is read.

      <nLength>  Designates the number of characters that are read.  The
      default value reads all characters.

      <lNotDelete>  Designates whether the characters are deleted (.F.) or
      not (.T.) after the buffer has been read.  The default value (.F.)
      indicates that the characters are deleted.

   $RETURNS$
      PPCREAD() returns a character string that contains the characters that
      have been read from the receiving buffer.  If an error occurs (for
      example, if the handle is invalid or the communication buffer has no
      receiving buffer), the function returns an empty string.

   $DESCRIPTION$
      PPCREAD() allows you to read data from the receiving buffer of any
      communication buffer, independently of the protocol used (IPX, SPX,
      NetBIOS datagram, or NetBIOS session).  The handle of the communication
      buffer must be specified with <nHandle>.  If only one communication
      handle is passed, the function returns all characters of the receiving
      buffer.  By designating <nLength>, a defined number of characters can be
      read.  With the parameter <lNotDelete>, you can specify if the buffer is
      cleared (.F.) or not (.T.) after the characters have been read.

      Reading only a defined number of characters can be useful if the header
      of a data packet is also transmitted to the receiving buffer during an
      IPX or SPX communication.  In this case, the header can be read first
      (30 or 42 characters).  The header contains information about the length
      of the data range that can then be read with a new call of PPCREAD()
      (see the introduction to this chapter).  In this way, the data that is
      read can be packet oriented.

   $NOTES$
      ■  Between a call of PPCRECCNT() and PPCREAD(), new data can be
         transmitted to the receiving buffer.

   $EXAMPLES$
      ■  Read and display all the characters from a receiving buffer:

         ? PPCREAD(nHandle)

      ■  Read the header and the data range of an IPX packet
         separately:

         // Open communication buffer
         // Force header transfer

         nHandle=IPXOPEN(20000,5000,,,,,.T.)

         // Read IPX header (30 bytes)
         cHeader=PPCREAD(nHandle,30)

         // Determine data range length
         // (Attention: high, low sequence)
         nLen=Bin2I(CharMirr(SubStr(cHeader,3,2)))-30
         // Read data range
         cData=PPCREAD(nHandle,nLen)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECCNT(), PPCWRITE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCRECCNT()
   $ONELINER$
      Determines the number of characters in a communication receiving buffer
   $SYNTAX$
      PPCRECCNT(<nHandle>) --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCRECCNT() returns the number of characters in the specified
      communication receiving buffer.  If an error occurs (for example, if the
      handle is invalid), the function returns -1.

   $DESCRIPTION$
      PPCRECCNT() determines the number of characters in the receiving buffer
      of a specified communication buffer, independently of the protocol used
      (IPX, SPX, NetBIOS datagram or NetBIOS session).  It allows you to check
      to see if new data has been received since the most recent readout.

   $EXAMPLES$
      Read the buffer if it contains characters:

      nCharacter=PPCRECCNT(nHandle)
      IF nCharacter>0
         cData=PPCREAD(nHandle)
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCREAD(), PPCSNDCNT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCRECDISC()
   $ONELINER$
      Determines the number of discarded packets
   $SYNTAX$
      PPCRECDISC(<nHandle>) --> nPackets

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCRECDISC() returns the number of packets that have been discarded
      because of a full buffer since the receiving buffer has been opened.  If
      an error occurs (for example, if the handle is invalid), the function
      returns -1.

   $DESCRIPTION$
      PPCRECDISC() determines the number of packets that have been discarded
      due to a full buffer, independently of the protocol used (IPX, SPX,
      NetBIOS datagram or NetBIOS session).  If more than 65535 packets have
      been discarded, the count restarts at 0.

   $EXAMPLES$
      Check to see if packets have been discarded:

      IF PPCRECDISC(nHandle)>0
         ? 'Data integrity not guaranteed!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECFAIL(), PPCRECTOT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCRECERR()
   $ONELINER$
      Determines the error code of the most recent receiving process
   $SYNTAX$
      PPCRECERR(<nHandle>) --> nErrorCode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCRECERR() returns the error code of the most recent receiving process
      for the specified receiving buffer.  If the packet has been received
      successfully, the function returns 0.  If an error occurs (for example,
      if the handle is invalid), the function returns -1.

   $DESCRIPTION$
      PPCRECERR() allows you to determine the error code of the most recent
      receiving operation, independently of the protocol used (IPX, SPX,
      NetBIOS datagram, or NetBIOS session).  The values are returned directly
      by the IPX/SPX or NetBIOS driver.  Therefore, the return value depends
      on the type of receiving buffer.  There is a description of the error
      codes for the IPX/SPX communication buffer and for the NetBIOS
      communication buffer in Appendices D and E.

      Packets that have been received but have been discarded due to a full
      buffer do not create an error code.

   $EXAMPLES$
      Check to see if the last packet has been received successfully:

      IF PPCRECERR(nHandle) = 0
         ? 'Packet has been received successfully!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      IPXERROR(), NBERROR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCRECFAIL()
   $ONELINER$
      Determines the number of packets received with a failure
   $SYNTAX$
      PPCRECFAIL(<nHandle>) --> nPackets

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCRECFAIL() returns the number of packets received with failure since
      the buffer has been opened.  If an error occurs (for example, if the
      handle is invalid), the function returns -1.

   $DESCRIPTION$
      PPCRECFAIL() determines the number of packets received with failure,
      independently of the protocol used (IPX, SPX, NetBIOS datagram, or
      NetBIOS session).  A faulty packet can be a packet for which the data
      length does not match the length defined in its header, or a packet that
      has been discarded because of a full buffer.  If a value of 65535
      packets has been exceeded, the count starts again at 0.

   $EXAMPLES$
      ■  Check to see if packets have been received with failure:

         IF PPCRECFAIL(nHandle)>0
            ? 'Data integrity not guaranteed!'
         ENDIF

      ■  Determine the number of faulty packets and the number of those
         packets that have been discarded due to a full buffer:

         ? 'Total of faulty packets:',PPCRECFAIL(nHandle)
         ? 'Discarded thereof:      ',PPCRECDISC(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECDISC(), PPCRECTOT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCRECFLSH()
   $ONELINER$
      Clears a communication receiving buffer
   $SYNTAX$
      PPCRECFLSH(<nHandle>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCRECFLSH() returns .T. if the receiving buffer has been cleared
      successfully.

   $DESCRIPTION$
      PPCRECFLSH() allows you to delete all characters from a receiving
      buffer, independently of the protocol used (IPX, SPX, NetBIOS datagram,
      or NetBIOS session).

   $EXAMPLES$
      Clear the receiving buffer:

      IF PPCRECFLSH(nHandle)
         ? 'Buffer has been cleared successfully!'
      ELSE
         ? 'Buffer could not be cleared!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCSNDFLSH()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCRECFREE()
   $ONELINER$
      Determines the number of free characters in a communication receiving buffer
   $SYNTAX$
      PPCRECFREE(<nHandle>) --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCRECFREE() returns the free memory in the specified communication
      receiving buffer in bytes.  If an error occurs (for example, if the
      handle is invalid), the function returns -1.

   $DESCRIPTION$
      PPCRECFREE() determines the number of characters that are still free in
      the receiving buffer of the specified communication buffer,
      independently of the protocol used (IPX, SPX, NetBIOS datagram, or
      NetBIOS session).

   $EXAMPLES$
      Read the buffer if less than 5460 characters are free:

      nCharacter=PPCRECFREE(nHandle)
      IF nCharacter<5460
         cData=PPCREAD(nHandle)
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCREAD(), PPCSNDFREE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCRECSIZE()
   $ONELINER$
      Determines the size of a communication receiving buffer
   $SYNTAX$
      PPCRECSIZE(<nHandle>) --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCRECSIZE() returns the size of the specified communication receiving
      buffer in bytes.  If an error occurs (for example, if the handle is
      invalid), the function returns -1.

   $DESCRIPTION$
      PPCRECSIZE() determines the size of a communication receiving buffer,
      independently of the protocol used (IPX, SPX, NetBIOS datagram, or
      NetBIOS session).

   $EXAMPLES$
      Determine the size of a communication receiving buffer:

      ? PPCRECSIZE(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCSNDSIZE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCRECTOT()
   $ONELINER$
      Determines the total number of received packets
   $SYNTAX$
      PPCRECTOT(<nHandle>) --> nPackets

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication receiving buffer.

   $RETURNS$
      PPCRECTOT() returns the number of packets received since the buffer has
      been opened.  If an error occurs (for example, if the handle is
      invalid), the function returns -1.

   $DESCRIPTION$
      PPCRECTOT() determines the total number of received packets,
      independently of the protocol used (IPX, SPX, NetBIOS datagram or
      NetBIOS session).  The value also contains faulty and discarded packets.
      If a value of 65535 packets has been exceeded, the count starts again at
      0.

   $EXAMPLES$
      Display the communication receiving buffer report:

      ? 'Total of received packets  :',PPCRECTOT(nHandle)
      ? 'Faulty thereof             :',PPCRECFAIL(nHandle)
      ? 'Discarded thereof          :',PPCRECDISC(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECDISC(), PPCRECFAIL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCSNDCNT()
   $ONELINER$
      Determines the number of characters in a communication sending buffer
   $SYNTAX$
      PPCSNDCNT(<nHandle>) --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication sending buffer.

   $RETURNS$
      PPCSNDCNT() returns the number of characters in the specified
      communication sending buffer.  If an error occurs (for example, if the
      handle is invalid), the function returns -1.

   $DESCRIPTION$
      PPCSNDCNT() determines the number of characters in the sending buffer of
      a specified communication buffer, independently of the protocol used
      (IPX, SPX, NetBIOS datagram, or NetBIOS session).  It allows you to
      check to see if data written to the buffer has already been sent.

   $EXAMPLES$
      Write characters into the receiving buffer, and wait until the
      characters have been sent:

      PPCWRITE(nHandle,cData)
      WHILE PPCSNDCNT(nHandle)>0
      ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCREAD(), PPCRECCNT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCSNDERR()
   $ONELINER$
      Determines the error code of the most recent sending process
   $SYNTAX$
      PPCSNDERR(<nHandle>) --> nErrorCode

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication sending buffer.

   $RETURNS$
      PPCSNDERR() returns the error code of the most recent sending process
      for the specified sending buffer.  If the packet has been sent
      successfully, the function returns 0.  If an error occurs (for example,
      if the handle is invalid), the function returns -1.

   $DESCRIPTION$
      PPCSNDERR() allows you to determine the error code of the most recent
      sending operation, independently of the protocol used (IPX, SPX, NetBIOS
      datagram, or NetBIOS session).  The values are returned directly by the
      IPX/SPX or NetBIOS driver, so the return value depends on the type of
      the receiving buffer.  There is a description of the error codes for the
      IPX/SPX communication buffer and for the NetBIOS communication buffer in
      Appendices D and E.

   $EXAMPLES$
      Check to see if the last packet has been sent successfully:

      IF PPCSNDERR(<nHandle>) = 0
         ? 'Packet has been sent successfully!'
      ELSE
         ? 'Error!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      IPXERROR(), NBERROR()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCSNDFAIL()
   $ONELINER$
      Determines the number of packets sent with failure
   $SYNTAX$
      PPCSNDFAIL(<nHandle>) --> nPackets

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication sending buffer.

   $RETURNS$
      PPCSNDFAIL() returns the number of packets sent with failure since the
      buffer has been opened.  If an error occurs (for example, if the handle
      is invalid), the function returns -1.

   $DESCRIPTION$
      PPCSNDFAIL() determines the number of packets sent with failure,
      independently of the protocol used (IPX, SPX, NetBIOS datagram, or
      NetBIOS session).  A faulty packet at an SPX or NetBIOS session
      connection can be a packet for which the receipt has not been
      acknowledged by the remote station.  If a value of 65535 packets has
      been exceeded, the count starts again at 0.

   $EXAMPLES$
      Check to see if packets have been sent with failure:

      IF PPCSNDFAIL(nHandle)>0
         ? 'Data integrity not guaranteed!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCSNDTOT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCSNDFLSH()
   $ONELINER$
      Clears a communication sending buffer
   $SYNTAX$
      PPCSNDFLSH(<nHandle>) --> lSuccess

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication sending buffer.

   $RETURNS$
      PPCSNDFLSH() returns .T. if the buffer has been cleared successfully.

   $DESCRIPTION$
      PPCSNDFLSH() allows you to delete all characters from a sending buffer,
      independently of the protocol used (IPX, SPX, NetBIOS datagram, or
      NetBIOS session).

   $EXAMPLES$
      Clear the sending buffer:

      IF PPCSNDFLSH(nHandle)
         ? 'Buffer has been cleared successfully!'
      ELSE
         ? 'Buffer could not be cleared!'
      ENDIF
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECFLSH()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCSNDFREE()
   $ONELINER$
      Determines the number of free characters in a communication sending buffer
   $SYNTAX$
      PPCSNDFREE(<nHandle>) --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication sending buffer.

   $RETURNS$
      PPCSNDFREE() returns the free memory in the specified communication
      sending buffer in bytes.  If an error occurs (for example, if the handle
      is invalid), the function returns -1.

   $DESCRIPTION$
      PPCSNDFREE() determines the number of characters that are still free in
      the sending buffer of the specified communication buffer, independently
      of the protocol used (IPX, SPX, NetBIOS datagram, or NetBIOS session).

   $EXAMPLES$
      Determine the free memory in a sending buffer:

      ? PPCSNDFREE(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECFREE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCSNDSIZE()
   $ONELINER$
      Determines the size of a communication sending buffer
   $SYNTAX$
      PPCSNDSIZE(<nHandle>) --> nBytes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication sending buffer.

   $RETURNS$
      PPCSNDSIZE() returns the size of the specified communication sending
      buffer.  If an error occurs (for example, if the handle is invalid), the
      function returns -1.

   $DESCRIPTION$
      PPCSNDSIZE() determines the size of a communication sending buffer,
      independently of the protocol used (IPX, SPX, NetBIOS datagram, or
      NetBIOS session).

   $EXAMPLES$
      Determine the size of a communication sending buffer:

      ? PPCSNDSIZE(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCRECSIZE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCSNDTOT()
   $ONELINER$
      Determines the total number of packets that have been sent
   $SYNTAX$
      PPCSNDTOT(<nHandle>) --> nPackets

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication sending buffer.

   $RETURNS$
      PPCSNDTOT() returns the number of packets that have been sent since the
      sending buffer has been open.  If an error occurs (for example, if the
      handle is invalid), the function returns -1.

   $DESCRIPTION$
      PPCSNDTOT() determines the total number of sent packets, independently
      of the protocol used (IPX, SPX, NetBIOS datagram, or NetBIOS session).
      The value also contains faulty packets.  If a value of 65535 packets has
      been exceeded, the count starts again at 0.

   $EXAMPLES$
      Display the communication sending buffer report:

      ? 'Total of sent packets :',PPCSNDTOT(nHandle)
      ? 'Faulty thereof        :',PPCSNDFAIL(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCSNDFAIL()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      PPCWRITE()
   $ONELINER$
      Writes data to a communication sending buffer
   $SYNTAX$
      PPCWRITE(<nHandle>,<cData>) --> nLength

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication buffer.

      <cData>  Designates a character string that contains the data that
      is written to the sending buffer.

   $RETURNS$
      PPCWRITE() returns the number of characters that could not be written to
      the sending buffer.  Therefore, a return value larger than 0 indicates
      an error (for example, when the sending buffer is full).

   $DESCRIPTION$
      PPCWRITE() allows you to write data into the sending buffer of a
      communication buffer, independently of the protocol used (IPX, SPX,
      NetBIOS datagram, or NetBIOS session).  The parameter <nHandle> contains
      the handle of the communication buffer.  The data must be passed as a
      character string (<cData>).  PPCWRITE() transmits the data to the
      sending buffer.  The data is sent from the sending buffer, in an
      interrupt controlled transmission in the background.  If the sending
      buffer does not have enough memory to accept all the characters,
      PPCWRITE() returns the number of characters that could not be
      transmitted to the sending buffer.

   $EXAMPLES$
      ■  Open the IPX sending buffer for a broadcast message, and send
         the message "Good morning!":

         nHandle=IPXOPEN(20000,,546,'FFFFFFFFFFFFFFFFFFFF')
         PPCWRITE(nHandle,'Good morning!')

      ■  Send data from the character string <cData>, and take into
         account that the sending buffer might be full:

         nRest=Len(cData)
         WHILE nRest>0
            nRest = PPCWRITE(nHandle,Right(cData,nRest))
         ENDDO
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCREAD(), PPCSNDCNT()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPXCONTARG()
   $ONELINER$
      Determines the target internet address of an SPX communication
   $SYNTAX$
      SPXCONTARG(<nHandle>) --> cInterNetAddr

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nHandle>  Designates the communication buffer.

   $RETURNS$
      SPXCONTARG() returns the destination's internet address.  If <nHandle>
      does not specify an SPX communication buffer or the SPX connection is
      not active, the function returns an empty string.

   $DESCRIPTION$
      SPXCONTARG() allows you to determine the destination's internet address
      after a successful call of SPXLISTCON().  The address is returned as a
      20-character hexadecimal string that contains 10 bytes in hexadecimal
      form.  The leading eight characters indicate the destination's network
      number.  The following 12 characters indicate the station ID (node
      address).

   $EXAMPLES$
      Wait for an SPX connection in the background.  After the connection has
      been set up, display the destination's internet address:

      nHandle=SPXLISTCON(20000,1000,1000)
      WHILE .NOT. PPCCONACT(nHandle)
      ENDDO
      ? 'Connection set up with ',SPXCONTARG(nHandle)
   $PLATFORMS$
      DOS
   $SEEALSO$
      SPXLISTCON()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPXESTBCON()
   $ONELINER$
      Opens the SPX sending and receiving buffer and tries a connection setup
   $SYNTAX$
      SPXESTBCON(<nSourceSocket>,[<nRecBuffer>],
         [<nSendBuffer>],<cTargetAddr>,[<nTargetSocket>],
         [<nPacket>],[<lHeader>],[<nRepeat>],[<lWatchDog>],
         [<nECBs>]) --> nHandle

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nSourceSocket>  Designates the socket number of the communication's
      transmitting side.

      <nRecBuffer>  Designates the selected size of the receiving buffer.
      If no value is passed for <nRecBuffer>, no receiving buffer is
      established.  The minimum size of the receiving buffer is <nPacket>.  If
      the value for <nRecBuffer> is too small, it is changed automatically by
      SPXESTBCON().  The maximum size of the receiving buffer is 64 KByte.

      <nSendBuffer>  Designates the selected size of the sending buffer.
      If no value is passed for <nSendBuffer>, no sending buffer is
      established.  The minimum size of the sending buffer is <nPacket>.  If
      the value for <nSendBuffer> is too small, it is changed automatically by
      SPXESTBCON().  The maximum size of the sending buffer is 64 KByte.

      <cTargetAddr>  Designates the destination's internet address.  The
      target address is a 20-character string that represents a 10-character
      byte sequence.  The leading eight characters of <cTargetAddr> contain
      the network number of the target station.  The remaining 12 characters
      specify the station ID of the target station (node address).

      <nTargetSocket>  Designates the socket number of the communication's
      remote side.  The default value is <nSourceSocket>.

      <nPacket>  Designates the packet size of the data that is sent.  The
      packet size can be between 1 and 534 bytes.  Values outside of this
      range are changed automatically.  The default value is 534 Bytes.

      <lHeader>  Designates whether the data range and the header of the
      packet (.T.) or the data range alone (.F.) are transmitted to the
      receiving buffer.

      <nRepeat>  Designates the number of repeat attempts if a faulty
      packet transmission occurs.  The value is valid for all sending
      operations processed during a session.  A value of 0 indicates that SPX
      assumes the standard repeat value.

      <lWatchDog>  Designates whether the watchdog is activated (.T.) or
      not (.F.).  This parameter allows the supervision of the connection with
      watchdog, an SPX internal mechanism.  If the supervision is activated,
      watchdog checks in regular intervals to see if the remote station is
      still responding.  The default value (.T.) activates the watchdog.

      <nECBs>  Designates the number of ECBs (Event Control Blocks) that
      are added to the listening pool for the current connection.  The default
      value is 2.  With a higher value, the performance can be improved (for
      example, when working with slow computers).

   $RETURNS$
      If an operation is successful, SPXESTBCON() returns a communication
      handle.  The return value contains a numeric value that is greater than
      0.  You should store the handle in a variable because all further
      operations that refer to an established buffer require a communication
      handle.  If an error occurs, the function returns 0.

   $DESCRIPTION$
      SPXESTCON() allows you to establish a communication buffer for an SPX
      communication with another station in the network.  SPXESTCON() also
      tries to set up an SPX connection (session) to this station.  The
      communication buffer can contain a sending and receiving buffer through
      which the interrupt controlled sending and receiving of data is
      processed.

      <nSourceSocket> is the socket number of the communication's transmitting
      side (see the Introduction to this chapter).  The socket can be opened
      with the function OPENSOCK() before the call of SPXESTBCON().  If
      <nSourceSocket> has not been opened, it is opened by SPXESTBCON()
      automatically.  If 0 is passed for <nSourceSocket>, SPXESTBCON() opens
      any available socket.

      The parameters <nRecBuffer> and <nSendBuffer> determine the size of the
      receiving and sending buffers.  The buffers are automatically designed
      for one NetBIOS packet.  Each buffer can be up to 64 KByte in size.
      However, the size of the buffer that is allocated by SPXESTBCON()
      depends on the application and the configuration of the computer used.

      The remote partner is specified by <cTargetAddr>.  The target address
      must be passed as a 20-character string (for example,
      "4921750400001B025A99").  Two bytes each represent one byte in
      hexadecimal form.  For an SPX communication, the target address must be
      unique.  It is not allowed to pass a broadcast address
      ("FFFFFFFFFFFFFFFFFFFF").  Application specific mechanisms are required
      to determine the stations waiting for a connection (for example, the
      storage of the net addresses of the waiting stations in a database or in
      the bindery).  If the current workstation is logged into a Netware
      server, the network address of a logged in remote station can be
      determined with the function NNETADR() by passing the user name.  Under
      Netware Lite, the leading eight characters of <cTargetAddr> (network
      number) must be passed with 0.

      <nTargetSocket> is the destination's internet address.  The default
      value is <nSourceSocket>.

      <nPacket> determines the maximum size of the data range of the SPX
      packets that are sent or received.  The maximum value (and the default
      value) is 536 bytes.  Smaller packets can be sent without failure.
      However, larger packets are discarded.  The value of <nPacket> is also
      valid for use in sending data.

      With <lHeader> you can determine if the header of an SPX packet (42
      bytes) is transmitted to the receiving buffer.  The header can contain
      important information about the received packet.  For a description
      about the header structure, see the Introduction to this chapter.

      The number of repeat attempts for faulty sending operations during the
      session can be specified with <nRepeat>.  A value of 0 sets an SPX
      internal standard value.

      A session is supervised by an SPX watchdog.  If the watchdog determines
      that the remote station is not responding, a key trap can be triggered
      (see PPCKEY()).  The connection flag for the session is set to .F..  If
      you want to deactivate the watchdog, the parameter <lWatchdog> can be
      designated .F..

      SPX needs Event Control Blocks (ECBs) for receiving data and for
      administration purposes.  The ECBs are created and managed by
      SPXESTBCON() automatically.  The default value is two ECBs for each SPX
      session.  The value can be increased if slow computers are used.
      However, you cannot prevent data loss that is the result of a full
      receiving buffer.

      If all parameters have been set correctly and the buffers have been
      established successfully, SPXESTBCON() tries to set up a session between
      the current workstation and the target station.  However, the target
      station must expect the connection setup.  If a CA-Clipper application
      is running on the target station, the function SPXLISTCON() must have
      been called.  If no acknowledgment is returned by the target station
      within a specified timeout (about 30 seconds), SPXESTBCON() releases the
      reserved buffer and returns 0.

      After a successful connection setup, SPXESTBCON() returns a
      communication handle that is greater than 0.  If a value has been passed
      for <nRecBuffer>, SPXESTBCON() initiates an interrupt controlled
      receiving mechanism that receives incoming packets in the background and
      then copies them to a receiving buffer.  The data can then be read with
      the PPCREAD() function within a CA-Clipper application.  If the
      receiving buffer is full, incoming data is discarded without notifying
      the sender.  Data should be removed from the receiving buffer and
      processed as soon as possible.  You should either read the contents of
      the buffer periodically (polling) or supervise the buffer on an event-
      oriented basis (for example, with the function PPCKEY()).

   $NOTES$
      ■  Unlike an IPX communication, an SPX communication is
         connection-oriented.  A connection is established between two
         stations.  As long as no error occurs, a successful delivery of sent
         packets is guaranteed.

   $EXAMPLES$
      ■  Attempt to set up an SPX connection to the target address
         "4921750400001B025A99".  If the connection can be set up, establish a
         5000 byte receiving buffer and a 1000 byte sending buffer.  The
         source and destination socket number is 20000:

         nHandle=SPXESTBCON(20000,5000,1000,"4921750400001B025A99")
         IF nHandle=0
            ? 'Error during connection setup!'
         ENDIF

      ■  The remote station can wait for the connection with the
         following call:

         nHandle:=SPXLISTCON(20000,2000,2000)
   $PLATFORMS$
      DOS
   $SEEALSO$
      PPCCANCEL(), PPCKEY(), PPCREAD(), PPCWRITE()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      SPXLISTCON()
   $ONELINER$
      Opens the SPX sending and receiving buffer and waits for a connection in the background
   $SYNTAX$
      SPXLISTCON(<nSourceSocket>,[<nRecBuffer>],
         [<nSendBuffer>],[<nPacket>],[<lHeader>],
         [<nRepeat>],[<lWatchDog>],[<nECBs>]) --> nHandle

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <nSourceSocket>  Designates the socket number of the communication's
      transmitting side.

      <nRecBuffer>  Designates the selected size of the receiving buffer.
      If no value is passed for <nRecBuffer>, no receiving buffer is
      established.  The minimum size of the receiving buffer is <nPacket>.  If
      the value for <nRecBuffer> is too small, it is changed automatically by
      SPXLISTCON().  The maximum size of the receiving buffer is 64 KByte.

      <nSendBuffer>  Designates the selected size of the sending buffer.
      If no value is passed for <nSendBuffer>, no sending buffer is
      established.  The minimum size of the sending buffer is <nPacket>.  If
      the value for <nSendBuffer> is too small, it is changed automatically by
      SPXLISTCON().  The maximum size of the sending buffer is 64 KByte.

      <nPacket>  Designates the packet size of the data that is sent.  The
      packet size can be between 1 and 534 bytes.  Values outside of this
      range are changed automatically.  The default value is 534 Bytes.

      <lHeader>  Specifies whether only the data range (.F.) or the data
      range and the header of the packet (.T.) are to be transmitted to the
      receiving buffer.

      <nRepeat>  Designates the number of repeat attempts if a faulty
      packet transmission occurs.  The value is valid for all sending
      operations processed during a session.  A value of 0 indicates that SPX
      assumes the standard repeat value.

      <lWatchDog>  Designates whether the watchdog is activated (.T.) or
      not (.F).  This parameter allows the supervision of the connection with
      watchdog, an SPX internal mechanism.  If the supervision is activated,
      watchdog checks in regular intervals to see if the remote station is
      still responding.  The default value (.T.) activates the watchdog.

   $RETURNS$
      SPXLISTCON() returns a communication handle if the buffer has been
      established successfully.  If an error occurs, the function returns 0.

   $DESCRIPTION$
      SPXLISTCON() allows you to establish a communication buffer for an SPX
      communication with another station in the network.  SPXLISTCON() also
      installs a handler that waits for a connection setup by any other
      station.  The communication buffer can contain a sending and receiving
      buffer through which the interrupt controlled sending and receiving of
      data is processed.

      <nSourceSocket> is the socket number of the communication's transmitting
      side (see the Introduction to this chapter).  The socket can be opened
      with the function OPENSOCK() before the call of SPXLISTCON().  If
      <nSourceSocket> has not been opened, it is opened by SPXLISTCON()
      automatically.  If 0 is passed for <nSourceSocket>, SPXLISTCON() opens
      any available socket.

      The parameters <nRecBuffer> and <nSendBuffer> determine the size of the
      receiving and sending buffer.  The buffers are automatically designed
      for one NetBIOS packet.  Each buffer can be up to 64 KByte in size.
      However, the size of the buffer that is allocated by SPXLISTCON()
      depends on the application and the configuration of the computer used.

      <nPacket> determines the maximum size of the data range of the SPX
      packets that are sent or received.  The maximum value (and the default
      value) is 536 bytes.  Smaller packets can be sent without failure.
      However, larger packets are discarded.  The value of <nPacket> is also
      valid for use in sending data.

      With <lHeader> you can determine if the header of an SPX packet (42
      bytes) is transmitted to the receiving buffer.  The header can contain
      important information about the received packet.  For a description of
      the header structure, see the Introduction to this chapter.

      The number of repeat attempts for faulty send operations during the
      session can be specified with <nRepeat>.  A value of 0 sets an SPX
      internal standard value.

      A session is supervised by an SPX watchdog.  If the watchdog determines
      that the remote station is not responding, a key trap can be triggered
      (see PPCKEY()).  The connection flag for the session is set to .F..  If
      you want to deactivate the watchdog, the parameter <lWatchdog> can be
      designated .F..

      SPX needs Event Control Blocks (ECBs) for receiving data and for
      administration purposes.  The ECBs are created and managed by
      SPXLISTCON() automatically.  The default value is two ECBs for each SPX
      session.  The value can be increased if slow computers are used.
      However, you cannot prevent data loss that is the result of a full
      receiving buffer.

      If all parameters have been passed correctly and the buffers have been
      established successfully, SPXLISTCON() returns a communication handle.
      However, a communication handle does not indicate that an SPX has
      already been set up.  After SPXLISTCON() has been executed, a handler
      waits for a connection request in the background.  The communication
      handler, returned by SPXLISTCON(), cannot be used for sending and
      receiving before a connection has been established.  The current
      connection status after a call of SPXLISTCON() can be queried with
      PPCCONACT().  It is also possible to trigger a key trap with PPCKEY().

   $NOTES$
      ■  Unlike an IPX communication, an SPX communication is
         connection-oriented.  A connection is established between two
         stations.  As long as no error occurs, a successful delivery of sent
         packets is guaranteed.

   $EXAMPLES$
      ■  Wait for an SPX connection setup:

         nHandle=SPXLISTCON(20000,1000)
         WHILE .NOT. PPCCONACT(nHandle)
         ENDDO

      ■  After an SPX connection has been set up successfully, put key
         code 255 into the keyboard buffer:

         #include "ctppc.ch"

         nHandle=SPXLISTCON(20000,5000,1000)
         PPCKEY(nHandle,255,PPC_CONESTB)
   $PLATFORMS$
      DOS
   $SEEALSO$
      SPXESTBCON(), PPCCANCEL(), PPCKEY(), PPCREAD()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Devices and Forms
   $ONELINER$
      Introduction
   $CATEGORY$
      Intro
   $DESCRIPTION$
      Netware provides the ability to manage printer and form information in a
      database (NET$PRN.DAT).  The functions of this chapter allow a read
      access to the contents of NET$PRN.DAT and make it possible to connect an
      application's printer management with Netware.
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPDEV()
   $ONELINER$
      Determines the names of defined devices
   $SYNTAX$
      NNETPDEV([<cServer>,<nConId>]) --> aDevices

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server for which the
      device definition is used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPDEV() returns a one-dimensional array that contains the names of
      the defined devices.

   $DESCRIPTION$
      NOVELL NET PRINT DEVICES
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  NNETPDEV() allows you to access this database and use
      the information in your application.  The function returns an array that
      contains the names of the defined devices.

   $EXAMPLES$
      Determine and display the defined devices:

      aDevices = NNETPDEV()
      FOR i = 1 TO Len(aDevices)
      ? aDevices[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPFORMS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPFLEN()
   $ONELINER$
      Determines the page length of a form definition
   $SYNTAX$
      NNETPFLEN(<cForm>,[<cServer>|<nConId>]) --> nLength

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cForm>  Designates the name of the form for which the page length
      is determined.

      <cServer>  Designates the name of the file server for which the
      form's definitions are used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPFLEN() returns the number of lines per page for <cForm>.  If an
      error occurs (for example, if <cForm> is not found), the function
      returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT FORM LENGTH
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  The CA-Clipper Tools functions allow you to access this
      database and use the information in your application.  With NNETPFLEN(),
      you can determine the number of lines per page for <cForm>.  The number
      of lines has an informative character only and is not evaluated by
      Netware.

   $EXAMPLES$
      Query the page length for the form INVOICE:

      ? NNETPFLEN('INVOICE')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPFWDTH()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPFNUM()
   $ONELINER$
      Determines the number of the form
   $SYNTAX$
      NNETPFNUM(<cForm>,[<cServer>|<nConId>]) --> nNumber

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cForm>  Designates the name of the form for which the number is
      determined.

      <cServer>  Designates the name of the file server for which the
      formÆs definitions are used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPFNUM() returns the number of <cForm> in the definition file.  A
      return value of -1 indicates an error.

   $DESCRIPTION$
      NOVELL NET PRINT FORM NUMBER
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  A name and a unique number are assigned to each form.
      NNETPFNUM() allows you to determine the form number of <cForm>.

   $EXAMPLES$
      Determine the number for the form INVOICE:

      ? NNETPFNUM('INVOICE')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPFORMS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPFORMS()
   $ONELINER$
      Determines the names of the defined forms
   $SYNTAX$
      NNETPFORMS([<cServer>,<nConId>]) --> aForms

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cServer>  Designates the name of the file server for which the
      formÆs definitions are used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPFORMS() returns a one-dimensional array that contains the names of
      the defined forms.

   $DESCRIPTION$
      NOVELL NET PRINT FORMS
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  NNETPFORMS() allows you to access this database and use
      the information in your application.  The function returns an array that
      contains the names of the defined forms.

   $EXAMPLES$
      Determine and define the defined forms:

      aForms = NNETPFORMS()
      FOR i = 1 TO Len(aForms)
      ? aForms[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPDEV()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPFUNCO()
   $ONELINER$
      Determines the control sequences of a function definition
   $SYNTAX$
      NNETPFUNCO(<cDevice>,<cFunc>,[<cServer>,<nConId>])
         --> cControl

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDevice>  Designates the name of the device that is processed.

      <cFunc>  Designates the name of a function that is established for
      <cDevice>.

      <cServer>  Designates the name of the file server for which the
      device definitions are used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPFUNCO() returns the control sequence defined in NET$PRN.DAT for the
      function <cFunc> of <cDevice>.

   $DESCRIPTION$
      NOVELL NET PRINT FUNCTION CODES
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  For each device, functions are defined to put the device
      into specific modes.  With NNETPFUNCO(), you can determine the control
      sequence for <cFunc> of <cDevice>.  This allows you to link the printer
      control to the Netware printer management within your application.

   $EXAMPLES$
      Determine the control sequence for the reset function of the device
      HPLJ, and send it to the printer:

      PrintSend(NNETPFUNCO('HPLJ', 'RESET'))
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPFUNCS()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPFUNCS()
   $ONELINER$
      Determines the function name for a device
   $SYNTAX$
      NNETPFUNCS(<cDevice>,[<cServer>,<nConId>]) --> aFuncs

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDevice>  Designates the name for the device for which the
      functions are determined.

      <cServer>  Designates the name of the file server for which the
      device definitions are used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPFUNCS() returns a one-dimensional array that contains the names of
      the functions defined for <cDevice>.

   $DESCRIPTION$
      NOVELL NET PRINT FUNCTIONS
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  For each device, functions are defined to put the device
      into specific modes.  NNETPFUNCS() returns a list of functions defined
      for <cDevice>.  This allows you to link the printer control to the
      Netware printer management within your application.

   $EXAMPLES$
      Determine and display the functions for device HPLJ:

      aFuncs = NNETPFUNCS('HPLJ')
      FOR i = 1 TO Len(aFuncs)
      ? aFuncs[i]
      NEXT i
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPFUNCO()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPFWDTH()
   $ONELINER$
      Determines the form width of a form definition
   $SYNTAX$
      NNETPFWDTH(<cForm>,[<cServer>|<nConId>]) --> nLength

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cForm>  Designates the name of the form for which the form width
      (characters per line) is determined.

      <cServer>  Designates the name of the file server for which the form
      definitions are to be used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPFWDTH() returns the number of characters per line for <cForm>.  If
      an error occurs (for example, if <cForm> is not found), the function
      returns -1.

   $DESCRIPTION$
      NOVELL NET PRINT FORM WIDTH
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  The CA-Clipper Tools functions allow you to access this
      database and use the information in your application.  With
      NNETPFWDTH(), you can determine the number of characters per line for
      <cForm>.  The number of lines has an informative character only and is
      not evaluated by Netware.

   $EXAMPLES$
      Query the number of characters for the form INVOICE:

      ? NNETPFWDTH('INVOICE')
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPFLEN()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPMODES()
   $ONELINER$
      Determines the mode name for a device
   $SYNTAX$
      NNETPMODES(<cDevice>,[<cServer>,<nConId>]) --> aModes

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDevice>  Designates the name of the device for which the modes are
      determined.

      <cServer>  Designates the name of the file server for which the
      device definitions are used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates the connection ID of your workstation on
      <cServer>.

   $RETURNS$
      NNETPMODES() returns a one-dimensional array that contains the names of
      the modes defined for <cDevice>.

   $DESCRIPTION$
      NOVELL NET PRINT MODES
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  For each device you can define modes that contain
      functions for <cDevice>.  NNETPMODES() returns a list of modes defined
      for <cDevice>.

   $EXAMPLES$
      Determine and display the modes for device HPLJ:

      aModes = NNETPMODES('HPLJ')
      FOR i = 1 TO Len(aModes)
      ? aModes[i]
      NEXT[i]
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPMODFU()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Function
   $NAME$
      NNETPMODFU()
   $ONELINER$
      Determines the functions of a mode definition
   $SYNTAX$
      NNETPMODFU(<cDevice>,<cModus>,[<cServer>,<nConId>])
         --> aFuncs

      Netware: 2.2 and 3.11

   $ARGUMENTS$
      <cDevice>  Designates the name of the device that is processed.

      <cMode>  Designates the name of a mode established for <cDevice>.

      <cServer>  Designates the name of the file server for which the
      device definitions are used.  Your workstation must be attached to
      <cServer>.

      <nConId>  Designates connection ID of your workstation on <cServer>.

   $RETURNS$
      NNETPMODFU() returns a one-dimensional array that contains the names of
      the functions for  <cMode> of <cDevice>.

   $DESCRIPTION$
      NOVELL NET PRINT MODE FUNCTIONS
      Netware allows you to manage printer and form information in a database
      (NET$PRN.DAT).  For each device you can define modes that contain a
      number of functions for <cDevice>.  NNETPMODFU() returns a list of the
      functions for <cMode> .

   $EXAMPLES$
      Determine and display the functions of the plain mode for device HPLJ:

      aFuncs = NNETPMODFU('HPLJ', 'PLAIN')
      FOR i = 1 TO Len(aFuncs)
      ? aFuncs[i]
      NEXT[i]
   $PLATFORMS$
      DOS
   $SEEALSO$
      NNETPMODES()
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Appendix A - Key Codes
   $ONELINER$
      A - Key Codes
   $CATEGORY$
      Appendix
   $DESCRIPTION$
      Key Codes
      <table>
           When using the DSetKBIOS( ), KBDEMULATE( ), KEYSEND( ), KEYREAD( ),
           GetKXLat( ), GetKXTab( ), and SCANKEY( ) functions use of the symbols
           defined in the CTSCAN.CH header file is recommended for key codes.
           After installation, you will find this file in the <ClipperRoot>\INCLUDE
           directory.

           By converting the coding used in the CA-Clipper Tools release from
           Summer '87 to BIOS coding, CA-Clipper keyboard functions now offer even
           greater capabilities.  In this way keys can be handled that could not be
           differentiated before.  For example, the decimal key on the numeric key
           pad of an extended keyboard has an ASCII value of 46 and a scan code of
           83, while the period key in the alpha field also has an ASCII value of
           46, but returns a scan code of 52.

           For compatibility reasons the previous system for key codes can also be
           used.  To do this you must link either the #include CT.CH file, or the
           EXTERNAL_S87KEYS statement contained therein.  This old system should
           however only be used for existing applications and is not recommended
           for the use in new applications.

       Symbolic constants for keys are coded as follows:

           <RootName>_[<ShiftStateKey>]_[<NumBlock>]_<Keyname>

           Where the following applies:

           <RootName>:        KS (for keyboard scan)
           <ShiftStateKey>:   CTRL, ALT, SHIFT
           <NumBlock>:        PAD
           <Keyname>:         a-Z, 0-9, F1-F12, etc.

       Examples:

           KS_A               KS_ALT_F1
           KS_PAD_ENTER       KS_CTRL_PAD_DIV
           KS_CTRL_B          KS_SH_F12
           KS_PAD_MUL         KS_ALT_PAD_MINUS

           Appendix Table A-1:  Letters and Numbers

           Key    ASCII    Scan     Symb.
           Name   Code     Code     Const.
          </table>
       A       65      30       KS_A
       B       66      48       KS_B
       C       67      46       KS_C
       D       68      32       KS_D
       E       69      18       KS_E
       F       70      33       KS_F
       G       71      34       KS_G
       H       72      35       KS_H
       I       73      23       KS_I
       J       74      36       KS_J
       K       75      37       KS_K
       L       76      38       KS_L
       M       77      50       KS_M
       N       78      49       KS_N
       O       79      24       KS_O
       P       80      25       KS_P
       Q       81      16       KS_Q
       R       82      19       KS_R
       S       83      31       KS_S
       T       84      20       KS_T
       U       85      22       KS_U
       V       86      47       KS_V
       W       87      17       KS_W
       X       88      45       KS_X
       Y       89      44       KS_Y
       Z       90      21       KS_Z
       a       97      30       KS_a
       b       98      48       KS_b
       c       99      46       KS_c
       d       100     32       KS_d
       e       101     18       KS_e
       f       102     33       KS_f
       g       103     34       KS_g
       h       104     35       KS_h
       i       105     23       KS_i
       j       106     36       KS_j
       k       107     37       KS_k
       l       108     38       KS_l
       m       109     50       KS_m
       n       110     49       KS_n
       o       111     24       KS_o
       p       112     25       KS_p
       q       113     16       KS_q
       r       114     19       KS_r
       s       115     31       KS_s
       t       116     20       KS_t
       u       117     22       KS_u
       v       118     47       KS_v
       w       119     17       KS_w
       x       120     45       KS_x
       y       121     44       KS_y
       z       122     44       KS_z
       1       49      2        KS_1
       2       50      3        KS_2
       3       51      4        KS_3
       4       52      5        KS_4
       5       53      6        KS_5
       6       54      7        KS_6
       7       55      8        KS_7
       8       56      9        KS_8
       9       57      10       KS_9
       0       48      11       KS_0
       ---

       Appendix Table A-2:  Letters and Numbers with CTRL & ALT
       <table>
           Key          ASCII   Scan     Symb.
           Name         Code    Code     Const.

           CTRL+A       1       30       KS_CTRL_A
           CTRL+B       2       48       KS_CTRL_B
           CTRL+C       3       46       KS_CTRL_C
           CTRL+D       4       32       KS_CTRL_D
           CTRL+E       5       18       KS_CTRL_E
           CTRL+F       6       33       KS_CTRL_F
           CTRL+G       7       34       KS_CTRL_G
           CTRL+H       8       35       KS_CTRL_H
           CTRL+I       9       23       KS_CTRL_I
           CTRL+M       13      50       KS_CTRL_M
           CTRL+N       14      49       KS_CTRL_N
           CTRL+R       18      19       KS_CTRL_R
           CTRL+S       19      31       KS_CTRL_S
           CTRL+T       20      20       KS_CTRL_T
           CTRL+U       21      22       KS_CTRL_U
           CTRL+V       22      47       KS_CTRL_V
           CTRL+W       23      17       KS_CTRL_W
           CTRL+X       24      45       KS_CTRL_X
           CTRL+Y       25      44       KS_CTRL_Y
           CTRL+Z       26      21       KS_CTRL_Z
           ALT+A        0       30       KS_ALT_A
           ALT+B        0       48       KS_ALT_B
           ALT+C        0       46       KS_ALT_C
           ALT+D        0       32       KS_ALT_D
           ALT+E        0       18       KS_ALT_E
           ALT+F        0       33       KS_ALT_F
           ALT+G        0       34       KS_ALT_G
           ALT+H        0       35       KS_ALT_H
           ALT+I        0       23       KS_ALT_I
           ALT+J        0       36       KS_ALT_J
           ALT+K        0       37       KS_ALT_K
           ALT+L        0       38       KS_ALT_L
           ALT+M        0       50       KS_ALT_M
           ALT+N        0       49       KS_ALT_N
           ALT+O        0       24       KS_ALT_O
           ALT+P        0       25       KS_ALT_P
           ALT+Q        0       16       KS_ALT_Q
           ALT+R        0       19       KS_ALT_R
           ALT+S        0       31       KS_ALT_S
           ALT+T        0       20       KS_ALT_T
           ALT+U        0       22       KS_ALT_U
           ALT+V        0       47       KS_ALT_V
           ALT+W        0       17       KS_ALT_W
           ALT+X        0       45       KS_ALT_X
           ALT+Y        0       21       KS_ALT_Y
           ALT+Z        0       44       KS_ALT_Z
           ALT+1        0       120      KS_ALT_1
           ALT+2        0       121      KS_ALT_2
           ALT+3        0       122      KS_ALT_3
           ALT+4        0       123      KS_ALT_4
           ALT+5        0       124      KS_ALT_5
           ALT+6        0       125      KS_ALT_6
           ALT+7        0       126      KS_ALT_7
           ALT+8        0       127      KS_ALT_8
           ALT+9        0       128      KS_ALT_9
           ALT+0        0       129      KS_ALT_0
          </table>

       Appendix Table A-3:  Function keys/all combinations
       <table>
           Key          ASCII   Scan     Symb.
           Name         Code    Code     Const.

           F1           0       59       KS_F1
           F2           0       60       KS_F2
           F3           0       61       KS_F3
           F4           0       62       KS_F4
           F5           0       63       KS_F5
           F6           0       64       KS_F6
           F7           0       65       KS_F7
           F8           0       66       KS_F8
           F9           0       67       KS_F9
           F10          0       68       KS_F10
           F11          0       133      KS_F11
           F12          0       134      KS_F12
           SHIFT+F1     0       84       KS_SH_F2
           SHIFT+F2     0       85       KS_SH_F2
           SHIFT+F3     0       86       KS_SH_F3
           SHIFT+F4     0       87       KS_SH_F4
           SHIFT+F5     0       88       KS_SH_F5
           SHIFT+F6     0       89       KS_SH_F6
           SHIFT+F7     0       90       KS_SH_F7
           SHIFT+F8     0       91       KS_SH_F8
           SHIFT+F9     0       92       KS_SH_F9
           SHIFT+F10    0       93       KS_SH_F10
           SHIFT+F11    0       135      KS_SH_F11
           SHIFT+F12    0       136      KS_SH_F12
           CTRL+F1      0       94       KS_CTRL_F1
           CTRL+F2      0       95       KS_CTRL_F2
           CTRL+F3      0       96       KS_CTRL_F3
           CTRL+F4      0       97       KS_CTRL_F4
           CTRL+F5      0       98       KS_CTRL_F5
           CTRL+F6      0       99       KS_CTRL_F6
           CTRL+F7      0       100      KS_CTRL_F7
           CTRL+F8      0       101      KS_CTRL_F8
           CTRL+F9      0       102      KS_CTRL_F9
           CTRL+F10     0       103      KS_CTRL_F10
           CTRL+F11     0       137      KS_CTRL_F11
           CTRL+F12     0       138      KS_CTRL_F12
           ALT+F1       0       104      KS_ALT_F1
           ALT+F2       0       105      KS_ALT_F2
           ALT+F3       0       106      KS_ALT_F3
           ALT+F4       0       107      KS_ALT_F4
           ALT+F5       0       108      KS_ALT_F5
           ALT+F6       0       109      KS_ALT_F6
           ALT+F7       0       110      KS_ALT_F7
           ALT+F8       0       111      KS_ALT_F8
           ALT+F9       0       112      KS_ALT_F9
           ALT+F10      0       113      KS_ALT_F10
           ALT+F11      0       139      KS_ALT_F11
           ALT+F12      0       140      KS_ALT_F12
          </table>

       Appendix Table A-4:  Backspace, ESC, and TAB
       <table>
           Key          ASCII   Scan     Symb.
           Name         Code    Code     Const.

           BS           8       14       KS_BS
           ESC          27      1        KS_ESC
           TAB          9       15       KS_TAB
           SHIFT+TAB    0       15       KS_SH_TAB
           ALT+BS       0       14       KS_ALT_BS
           ALT+ESC      0       1        KS_ALT_ESC
           ALT+TAB      0       165      KS_ALT_TAB
          </table>

       Appendix Table A-5:  Combinations with ENTER
       <table>
           Key               ASCII   Scan     Symb.
           Name              Code    Code     Const.

           ENTER             13      28       KS_ENTER
           CTRL+ENTER        10      28       KS_CTRL_ENTER
           ALT+ENTER         0       28       KS_ALT_ENTER
           PAD-ENTER         13      224      KS_PAD_ENTER
           CTRL+PAD-ENTER    10      224      KS_CTRL_PAD_ENTER
           ALT+PAD-ENTER     0       166      KS_ALT_PAD_ENTER
          </table>

       Appendix Table A-6:  Cursor block/Numeric Key Pad
       <table>
           Key               ASCII   Scan     Symb.
           Name              Code    Code     Const.

           INS               224     82       KS_INS
           DEL               224     83       KS_DEL
           HOME              224     71       KS_HOME
           END               224     79       KS_END
           PAGE UP           224     73       KS_PGUP
           PAGE DOWN         224     81       KS_PGDN
           <Up arrow>        224     72       KS_UP
           <-                224     75       KS_LEFT
           <Down arrow>      224     80       KS_DOWN
           ->                224     77       KS_RIGHT
           CTRL+INS          224     146      KS_CTRL_INS
           CTRL+DEL          224     147      KS_CTRL_DEL
           CTRL+HOME         224     119      KS_CTRL_HOME
           CTRL+END          224     117      KS_CTRL_END
           CTRL+PAGE UP      224     132      KS_CTRL_PGUP
           CTRL+PAGE DOWN    224     118      KS_CTRL_PGDN
           CTRL+<Up arrow>   224     141      KS-CTRL_UP
           CTRL+<-           224     115      KS_CTRL_LEFT
           CTRL+<Dn arrow>   224     145      KS_CTRL_DOWN
           CTRL+->           224     116      KS_CTRL_RIGHT
          </table>

       There are no separate KS_ALT_<grey cursor keys> codes!

       Appendix Table A-7: Cursor Block (grey cursor keys)
       <table>
           Key               ASCII   Scan     Symb.
           Name              Code    Code     Const.

           PAD-INS           0       82       KS_PAD_INS
           PAD-DEL           0       83       KS_PAD_DEL
           PAD-HOME          0       71       KS_PAD_HOME
           PAD-END           0       79       KS_PAD_END
           PAD-PAGE UP       0       73       KS_PAD_PGUP
           PAD-PAGE DOWN     0       81       KS_PAD_PGDN
           PAD-<Up arrow>    0       72       KS_PAD_UP
           PAD-<-            0       75       KS_PAD_LEFT
           PAD-<Down arrow>  0       80       KS_PAD_DOWN
           PAD-->            0       77       KS_PAD_RIGHT
           CTRL+PAD-INS      0       146      KS_CTRL_PAD_INS
           CTRL+PAD-DEL      0       147      KS_CTRL_PAD_DEL
           CTRL+PAD-HOME     0       119      KS_CTRL_PAD_HOME
           CTRL+PAD-END      0       117      KS_CTRL_PAD_END
           CTRL+PAD-PGUP     0       132      KS_CTRL_PAD_PGUP
           CTRL+PAD-PGDN     0       118      KS_CTRL_PAD_PGDN
           CTRL+PAD-<Uparr>  0       141      KS_CTRL_PAD_UP
           CTRL+PAD-<-       0       115      KS_CTRL_PAD_LEFT
           CTRL+PAD-<Dnarr>  0       145      KS_CTRL_PAD_DOWN
           CTRL+PAD-->       0       116      KS_CTRL_PAD_RIGHT
           ALT+PAD-INS       0       162      KS_ALT_PAD_INS
           ALT+PAT-DEL       0       163      KS_ALT_PAD_DEL
           ALT+PAD-HOME      0       151      KS_ALT_PAD_HOME
           ALT+PAD-END       0       159      KS_ALT_PAD_END
           ALT+PAD-PGUP      0       153      KS_ALT_PAD_PGUP
           ALT+PAD-PGDN      0       161      KS_ALT_PAD_PGDN
           ALT+PAD-<Uparr>   0       152      KS_ALT_PAD_UP
           ALT+PAD-<-        0       155      KS_ALT_PAD_LEFT
           ALT+PAD-<Dnarr>   0       160      KS_ALT_PAD_DOWN
           ALT+PAD-->        0       157      KS_ALT_PAD_RIGHT
          </table>

       Appendix Table A-8:  Numeric Block (grey cursor keys)
       <table>
           Key               ASCII   Scan     Symb.
           Name              Code    Code     Const.

           PAD-DIV           47      224      KS_PAD_DIV
           PAD-MUL           42      55       KS_PAD_MUL
           PAD-MINUS         45      74       KS_PAD_MINUS
           PAD-PLUS          43      78       KS_PAD_PLUS
           CTRL+PAD-DIV      0       149      KS_CTRL_PAD_DIV
           CTRL+PAD-MUL      0       150      KS_CTRL_PAD_MUL
           CTRL+PAD-MINUS    0       142      KS_CTRL_PAD_MINUS
           CTRL+PAD-PLUS     0       144      KS_CTRL_PAD_PLUS
           ALT+PAD-DIV       0       164      KS_ALT_PAD_DIV
           ALT+PAD-MUL       0       55       KS_ALT_PAD_MUL
           ALT+PAD-MINUS     0       74       KS_ALT_PAD_MINUS
           ALT+PAD-PLUS      0       78       KS_ALT_PAD_PLUS
          </table>

       Appendix Table A-9:  Numeric Block/Period/Comma
       <table>
           Key               ASCII   Scan     Symb.
           Name              Code    Code     Const.

           PAD_1             49      79       KS_PAD_1
           PAD_2             50      80       KS_PAD_2
           PAD_3             51      81       KS_PAD_3
           PAD_4             52      75       KS_PAD_4
           PAD_5             53      76       KS_PAD_5
           PAD_6             54      77       KS_PAD_6
           PAD_7             55      71       KS_PAD_7
           PAD_8             56      72       KS_PAD_8
           PAD_9             57      73       KS_PAD_9
           PAD_0             48      82       KS_PAD_0
           PAD_DECIMAL       44      83       KS_PAD_DECIMAL
           DOT               46      52       KS_PAD_DOT
           COMMA             44      51       KS_PAD_COMMA
          </table>

   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Appendix B - MS/PC-DOS Extended Errors
   $ONELINER$
      B - MS/PC-DOS Extended Errors
   $CATEGORY$
      Appendix
   $DESCRIPTION$
      MS/PC-DOS Extended Error Codes
      ---

       MS/PC-DOS Extended Error Codes
       <table>
           Error Codes        Definition

           1                  Invalid function number
           2                  File not found
           3                  Path not found
           4                  Too many open files (no handles left)
           5                  Access denied
           6                  Invalid handle
           7                  Memory control blocks destroyed
           8                  Insufficient memory
           9                  Invalid memory block address
           10                 Invalid environment
           11                 Invalid format
           12                 Invalid access code
           13                 Invalid data
           14                 Reserved
           15                 Invalid drive was specified
           16                 Attempt to remove current directory
           17                 Not same device
           18                 No more files
           19                 Attempt to write on write-protected disk
           20                 Unknown unit
           21                 Drive not ready
           22                 Unknown command
           23                 Cyclic redundancy check (CRC) - bad sector
           24                 Bad request structure length
           25                 Seek error
           26                 Unknown media type
           27                 Sector not found
           28                 Printer out of paper
           29                 Write fault
           30                 Read fault
           31                 General failure
           32                 Sharing violation
           33                 Lock violation
           34                 Invalid disk change
           35                 FCB unavailable
           36                 Sharing buffer overflow
           37-49
           50                 Network request not supported
           51                 Remote computer not listening
           52                 Duplicate name on network
           53                 Network path not found
           54                 Network busy
           55                 Network device no longer exists
           56                 NETBIOS command limit exceeded
           57                 System error; NETBIOS error
           58                 Incorrect response from network
           59                 Unexpected network error
           60                 Incompatible remote adapter
           61                 Print queue full
           62                 Not enough space for print file
           63                 Print file was canceled
           64                 Network name was deleted
           65                 Access denied
           66                 Network device type incorrect
           67                 Network name not found
           68                 Network name limit exceeded
           69                 NETBIOS session limit exceeded
           70                 Sharing temporarily paused
           71                 Network request not accepted
           72                 Print or disk redirection is paused
           73-79              Reserved
           80                 File exists
           81                 Reserved
           82                 Cannot make directory entry
           83                 Fail on INT
           84                 Too many redirections
           85                 Duplicate redirections
           86                 Invalid password
           87                 Invalid parameter
           88                 Network data fault
          </table>
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Appendix C - Novell Error Codes
   $ONELINER$
      C - Novell Error Codes
   $CATEGORY$
      Appendix
   $DESCRIPTION$
      Novell Error Codes
      ---

       This section describes the Novell error codes that will occur in
       conjunction with NNETxxxxxx() functions.  The error from the previously
       called function must be determined using NNETERROR().  Some of the error
       codes, like 254 or 255 have multiple meanings, and only permit a precise
       definition of the nature of the error in conjunction with the network
       function used.

       Error codes 1 - 18, as well as 32 - 33 are DOS error messages and
       correspond to those described in Appendix C:

       MS/PC-DOS Extended Error Codes
       <table>
           Error Codes    Definition

           128            File in use error
           129            No more file handles
           130            No more open privileges
           131            I/O error on network
           132            No create privileges
           133            No create or delete privileges
           136            Invalid file handle
           137            No search privileges
           138            No delete privileges
           140            No modify privileges
           147            No read privileges
           148            No write privileges or read-only
           150            Server out of memory
           151            No disk space for spool file
           152            Volume does not exist
           153            Directory full
           154            Renaming across volumes
           156            No more trustees
           158            Invalid filename
           161            Directory I/O error
           198            No console operator
           208            Queue error
           209            No queue
           210            No queue server
           211            No queue rights
           212            Queue full
           213            No queue job
           214            No queue rights
           234            No such member
           339            Invalid name
           240            Wildcard not allowed
           241            Invalid bindery security
           242            No object read privilege
           248            Already attached to server
           251            Invalid parameters
           252            Unknown file server.  No such object
           253            Bad station number
           254            Bindery locked
                          Directory locked
                          Packet not deliverable
                          Spool directory error
                          Timeout failure
           255            Bad printer error
                          File extension error
                          File name error
                          Hardware failure
                          Invalid drive number
                          No files found error
                          No response from server
                          Path not locatable
                          Queue full error
                          Bindery error
          </table>
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Appendix D - IPX and SPX Error Codes
   $ONELINER$
      D - IPX and SPX Error Codes
   $CATEGORY$
      Appendix
   $DESCRIPTION$
      IPX and SPX Error Codes
      ---

       IPX and SPX Error Codes
       <table>
           Value        Description

           236          SPX connection severed
           237          SPX connection failed or terminated, no answer from target
           238          Invalid SPX connection
           239          Local SPX connection table is full
           249          Event control block (ECB) cannot be canceled
           252          SPX listen canceled
           253          Invalid packet length
           254          Packet not deliverable, socket table full
           255          Local socket already open, destination socket not open,
                        general network failure
          </table>
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Appendix E - NetBIOS Error Codes
   $ONELINER$
      E - NetBIOS Error Codes
   $CATEGORY$
      Appendix
   $DESCRIPTION$
      NetBIOS Error Codes
      ---

       NetBIOS Error Codes
       <table>
           Value        Description

           1            Invalid buffer length
           3            Illegal command
           5            Time out
           6            Incomplete message
           7            Send No ACK operation failed
           8            Illegal local session number (LSN)
           9            No resource available
           10           Session terminated
           11           Commannd cancelled
           13           Name already in local name table
           14           Local name table full
           15           Name has active sessions
           17           Local session table full
           18           Session open failed
           19           Invalid NetBIOS name number
           20           Call Name not in network
           21           Invalid name oder name not found
           22           Name already exsists on remote station
           23           Name deleted
           24           Abnormal session termination
           25           Name conflict
           33           Adapter busy
           34           Too many pending commands
           35           Invalid adapter number
           36           Command completed during cancel
           38           Command cannot be canceled
           48           Name conflict with other environment
           53           Out of resources (temporary)
           56           Requested resource not available
           57           Invalid addess of network control block (NCB)
           58           Reset not allowed in POST routine
           78-79        Network status error
           246-250      Adapter error
           252          Adapter open not successful
           253          Unexpected adapter close
           254          NetBIOS not active
          </table>
   $PLATFORMS$
      DOS
   $END$
 */

/* $DOC$
   $TEMPLATE$
      Document
   $NAME$
      Appendix F - Print Server Error Codes
   $ONELINER$
      F - Print Server Error Codes
   $CATEGORY$
      Appendix
   $DESCRIPTION$
      Print Server Error Codes
      ---

       Print Server Error Codes
       <table>
           Value        Description

           64           No SPX connections available
           65           SPX not initialized
           66           Print server not found
           67           Unable to get server address
           68           Connect to server failed
           69           Out of sockets
           70           Already attached to print server
           71           IPX not initialized
           257          Too many file servers
           258          File server not found
           259          Bindery locked
           260          Print Server maxed out
           261          No response from print server
           262          Already attached to print server
           263          Cannot attach to print server
           264          No account balance
           265          No credit left
           266          Intruder detection lock
           267          Too many connections
           268          Print server account disabled
           269          Illegal time
           270          Illegal station
           271          Out of grace logins
           272          Login disabled
           273          Invalid account name
           274          Password expired
           275          Access denied
           276          Login not successful
           512          Invalid queue specified
           513          No rights for queue
           514          Queue halted
           515          Cannot attach to queue
           516          Too many queue servers
           768          Invalid request
           769          Out of memory
           770          Invalid printer specified
           771          Illegal parameter
           772          Printer busy
           773          Cannot detach from primary server
           774          Print server going down
           775          Not connected
           776          Remote printer already in use
           777          No active job
           778          Not attached to server
           779          Notify object already in list
           780          Print Server down
           781          Notify object not in list
           782          No rights
           1024         Identification verification not successful
           1025         Printer is not defined as remote printer
          </table>
   $PLATFORMS$
      DOS
   $END$
 */
